section {*FUNCTION\_\_DPDA\_TO\_CFG\_STD*}
theory
  FUNCTION__DPDA_TO_CFG_STD

imports
  PRJ_12_04_06_01__ENTRY

begin

definition F_SDPDA_TO_CFG_STD__SpecInput :: "
  ('state, 'event, 'stack) epda
  \<Rightarrow> bool"
  where
    "F_SDPDA_TO_CFG_STD__SpecInput G \<equiv>
  valid_simple_dpda G"

definition F_SDPDA_TO_CFG_STD__SpecOutput :: "
  ('state, 'event, 'stack) epda
  \<Rightarrow> ('nonterminal, 'event) cfg
  \<Rightarrow> bool"
  where
    "F_SDPDA_TO_CFG_STD__SpecOutput Gi Go \<equiv>
  valid_cfg Go
  \<and> epdaS.marked_language Gi = cfgSTD.marked_language Go"

theorem F_SDPDA_TO_CFG_STD__makes_CFG: "
  valid_simple_dpda G
  \<Longrightarrow> valid_cfg (F_SDPDA_TO_CFG_STD G)"
  apply(simp add: valid_cfg_def F_SDPDA_TO_CFG_STD_def)
  apply(rule conjI)
   apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
  apply(rule conjI)
   apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
   apply(rule finite_two_set)
       apply(force)
      apply(force)
     apply(force)
    apply(force)
   apply(simp add: inj_on_def)
  apply(rule conjI)
   apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
   apply(rule finite_three_set)
       apply(force)
      apply(force)
     apply(force)
    apply(force)
   apply(simp add: inj_on_def)
  apply(rule conjI)
   apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
  apply(rule conjI)
   apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
  apply(rule conjI)
   apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_def)
   apply(rule conjI)
    apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
    apply(clarsimp)
    apply(rename_tac x)(*strict*)
    apply(case_tac "edge_event x")
     apply(rename_tac x)(*strict*)
     apply(clarsimp)
    apply(rename_tac x a)(*strict*)
    apply(clarsimp)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_read_def)
   apply(rule conjI)
    apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
    apply(clarsimp)
    apply(rename_tac x)(*strict*)
    apply(case_tac "edge_push x")
     apply(rename_tac x)(*strict*)
     apply(clarsimp)
     apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_pop_def)
    apply(rename_tac x a list)(*strict*)
    apply(clarsimp)
   apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
   apply(clarsimp)
   apply(rename_tac x)(*strict*)
   apply(case_tac "edge_push x")
    apply(rename_tac x)(*strict*)
    apply(clarsimp)
   apply(rename_tac x a list)(*strict*)
   apply(clarsimp)
   apply(case_tac "edge_event x")
    apply(rename_tac x a list)(*strict*)
    apply(clarsimp)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_push_def)
    apply(rule finite_two_set)
        apply(rename_tac x a list)(*strict*)
        apply(force)
       apply(rename_tac x a list)(*strict*)
       apply(force)
      apply(rename_tac x a list)(*strict*)
      apply(force)
     apply(rename_tac x a list)(*strict*)
     apply(force)
    apply(rename_tac x a list)(*strict*)
    apply(simp add: inj_on_def)
   apply(rename_tac x a list aa)(*strict*)
   apply(clarsimp)
  apply(rule conjI)
   apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_def)
   apply(rule conjI)
    apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
    apply(clarsimp)
    apply(rename_tac x)(*strict*)
    apply(case_tac "edge_event x")
     apply(rename_tac x)(*strict*)
     apply(clarsimp)
    apply(rename_tac x a)(*strict*)
    apply(clarsimp)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_read_def)
   apply(rule conjI)
    apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
    apply(clarsimp)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_final_def)
    apply(case_tac "epda_marking G={}")
     apply(clarsimp)
    apply(rule finite_two_set)
        apply (metis notFinite_subset)
       apply(force)
      apply(force)
     apply(force)
    apply(simp add: inj_on_def)
   apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
   apply(clarsimp)
   apply(rename_tac x)(*strict*)
   apply(case_tac "edge_push x")
    apply(rename_tac x)(*strict*)
    apply(clarsimp)
   apply(rename_tac x a list)(*strict*)
   apply(clarsimp)
   apply(case_tac "edge_event x")
    apply(rename_tac x a list)(*strict*)
    apply(clarsimp)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_push_def)
   apply(rename_tac x a list aa)(*strict*)
   apply(clarsimp)
  apply(clarsimp)
  apply(rename_tac e)(*strict*)
  apply(erule disjE)
   apply(rename_tac e)(*strict*)
   apply(rule conjI)
    apply(rename_tac e)(*strict*)
    apply(rule disjI2)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_def)
    apply(erule disjE)
     apply(rename_tac e)(*strict*)
     apply(clarsimp)
     apply(rename_tac e x)(*strict*)
     apply(subgoal_tac "valid_epda_step_label G x")
      apply(rename_tac e x)(*strict*)
      prefer 2
      apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
     apply(rename_tac e x)(*strict*)
     apply(subgoal_tac "\<exists>y. edge_pop x=[y]")
      apply(rename_tac e x)(*strict*)
      prefer 2
      apply(rule_tac
      G="G"
      in valid_pda_edge_pop_single)
       apply(rename_tac e x)(*strict*)
       apply(simp add: valid_simple_dpda_def valid_dpda_def)
      apply(rename_tac e x)(*strict*)
      apply(force)
     apply(rename_tac e x)(*strict*)
     apply(case_tac "edge_event x")
      apply(rename_tac e x)(*strict*)
      apply(clarsimp)
     apply(rename_tac e x a)(*strict*)
     apply(clarsimp)
     apply(rename_tac e x a y)(*strict*)
     apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_read_def)
     apply(clarsimp)
     apply(rename_tac x a y qt)(*strict*)
     apply(simp add: valid_epda_step_label_def)
     apply(simp add: may_terminated_by_def append_language_def kleene_star_def)
     apply(clarsimp)
     apply(rename_tac x a y qt aa ab)(*strict*)
     apply(erule_tac
      P="[] = aa \<and> y = epda_box G"
      in disjE)
      apply(rename_tac x a y qt aa ab)(*strict*)
      apply(clarsimp)
      apply(rename_tac x a qt ab)(*strict*)
      apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
     apply(rename_tac x a y qt aa ab)(*strict*)
     apply(clarsimp)
     apply(rename_tac x a y qt ab)(*strict*)
     apply(rule_tac
      A="set(edge_pop x)"
      in set_mp)
      apply(rename_tac x a y qt ab)(*strict*)
      apply(force)
     apply(rename_tac x a y qt ab)(*strict*)
     apply(rule_tac
      t="edge_pop x"
      and s="[y]"
      in ssubst)
      apply(rename_tac x a y qt ab)(*strict*)
      apply(force)
     apply(rename_tac x a y qt ab)(*strict*)
     apply(simp (no_asm))
    apply(rename_tac e)(*strict*)
    apply(erule disjE)
     apply(rename_tac e)(*strict*)
     apply(clarsimp)
     apply(rename_tac e x)(*strict*)
     apply(subgoal_tac "valid_epda_step_label G x")
      apply(rename_tac e x)(*strict*)
      prefer 2
      apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
     apply(rename_tac e x)(*strict*)
     apply(subgoal_tac "\<exists>y. edge_pop x=[y]")
      apply(rename_tac e x)(*strict*)
      prefer 2
      apply(rule_tac
      G="G"
      in valid_pda_edge_pop_single)
       apply(rename_tac e x)(*strict*)
       apply(simp add: valid_simple_dpda_def valid_dpda_def)
      apply(rename_tac e x)(*strict*)
      apply(force)
     apply(rename_tac e x)(*strict*)
     apply(case_tac "edge_push x")
      apply(rename_tac e x)(*strict*)
      apply(clarsimp)
      apply(rename_tac e x y)(*strict*)
      apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_pop_def)
      apply(clarsimp)
      apply(rename_tac x y)(*strict*)
      apply(simp add: valid_epda_step_label_def)
      apply(clarsimp)
      apply(simp add: may_terminated_by_def append_language_def kleene_star_def)
      apply(clarsimp)
      apply(rename_tac x y a)(*strict*)
      apply(erule disjE)
       apply(rename_tac x y a)(*strict*)
       apply(clarsimp)
       apply(rename_tac x)(*strict*)
       apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
      apply(rename_tac x y a)(*strict*)
      apply(clarsimp)
      apply(rename_tac x y)(*strict*)
      apply(rule_tac
      A="set(edge_pop x)"
      in set_mp)
       apply(rename_tac x y)(*strict*)
       apply(force)
      apply(rename_tac x y)(*strict*)
      apply(rule_tac
      t="edge_pop x"
      and s="[y]"
      in ssubst)
       apply(rename_tac x y)(*strict*)
       apply(force)
      apply(rename_tac x y)(*strict*)
      apply(simp (no_asm))
     apply(rename_tac e x a list)(*strict*)
     apply(clarsimp)
    apply(rename_tac e)(*strict*)
    apply(clarsimp)
    apply(rename_tac e x)(*strict*)
    apply(subgoal_tac "valid_epda_step_label G x")
     apply(rename_tac e x)(*strict*)
     prefer 2
     apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
    apply(rename_tac e x)(*strict*)
    apply(subgoal_tac "\<exists>y. edge_pop x=[y]")
     apply(rename_tac e x)(*strict*)
     prefer 2
     apply(rule_tac
      G="G"
      in valid_pda_edge_pop_single)
      apply(rename_tac e x)(*strict*)
      apply(simp add: valid_simple_dpda_def valid_dpda_def)
     apply(rename_tac e x)(*strict*)
     apply(force)
    apply(rename_tac e x)(*strict*)
    apply(case_tac "edge_push x")
     apply(rename_tac e x)(*strict*)
     apply(clarsimp)
    apply(rename_tac e x a list)(*strict*)
    apply(clarsimp)
    apply(rename_tac e x a list y)(*strict*)
    apply(case_tac "edge_event x")
     apply(rename_tac e x a list y)(*strict*)
     apply(clarsimp)
     apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_push_def)
     apply(clarsimp)
     apply(rename_tac x a list y qs qt)(*strict*)
     apply(simp add: valid_epda_step_label_def)
     apply(clarsimp)
     apply(simp add: may_terminated_by_def append_language_def kleene_star_def)
     apply(clarsimp)
     apply(rename_tac x a list y qs qt aa ab)(*strict*)
     apply(erule_tac
      P="[] = aa \<and> y = epda_box G"
      in disjE)
      apply(rename_tac x a list y qs qt aa ab)(*strict*)
      apply(clarsimp)
      apply(rename_tac x a list qs qt ab)(*strict*)
      apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
     apply(rename_tac x a list y qs qt aa ab)(*strict*)
     apply(clarsimp)
     apply(rename_tac x a list y qs qt ab)(*strict*)
     apply(rule_tac
      A="set(edge_pop x)"
      in set_mp)
      apply(rename_tac x a list y qs qt ab)(*strict*)
      apply(force)
     apply(rename_tac x a list y qs qt ab)(*strict*)
     apply(rule_tac
      t="edge_pop x"
      and s="[y]"
      in ssubst)
      apply(rename_tac x a list y qs qt ab)(*strict*)
      apply(force)
     apply(rename_tac x a list y qs qt ab)(*strict*)
     apply(simp (no_asm))
    apply(rename_tac e x a list y aa)(*strict*)
    apply(clarsimp)
   apply(rename_tac e)(*strict*)
   apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_def)
   apply(erule disjE)
    apply(rename_tac e)(*strict*)
    apply(clarsimp)
    apply(rename_tac e x)(*strict*)
    apply(subgoal_tac "valid_epda_step_label G x")
     apply(rename_tac e x)(*strict*)
     prefer 2
     apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
    apply(rename_tac e x)(*strict*)
    apply(subgoal_tac "\<exists>y. edge_pop x=[y]")
     apply(rename_tac e x)(*strict*)
     prefer 2
     apply(rule_tac
      G="G"
      in valid_pda_edge_pop_single)
      apply(rename_tac e x)(*strict*)
      apply(simp add: valid_simple_dpda_def valid_dpda_def)
     apply(rename_tac e x)(*strict*)
     apply(force)
    apply(rename_tac e x)(*strict*)
    apply(case_tac "edge_event x")
     apply(rename_tac e x)(*strict*)
     apply(clarsimp)
    apply(rename_tac e x a)(*strict*)
    apply(clarsimp)
    apply(rename_tac e x a y)(*strict*)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_read_def)
    apply(clarsimp)
    apply(rename_tac x a y qt)(*strict*)
    apply(simp add: valid_epda_step_label_def)
    apply(simp add: option_to_set_def)
    apply(simp add: may_terminated_by_def append_language_def kleene_star_def)
    apply(clarsimp)
    apply(rename_tac x a y qt aa ab)(*strict*)
    apply(erule_tac
      P="[] = aa \<and> y = epda_box G"
      in disjE)
     apply(rename_tac x a y qt aa ab)(*strict*)
     apply(clarsimp)
     apply(rename_tac x a qt ab)(*strict*)
     apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
    apply(rename_tac x a y qt aa ab)(*strict*)
    apply(clarsimp)
    apply(rename_tac x a y qt ab)(*strict*)
    apply(rule_tac
      A="set(edge_pop x)"
      in set_mp)
     apply(rename_tac x a y qt ab)(*strict*)
     apply(force)
    apply(rename_tac x a y qt ab)(*strict*)
    apply(rule_tac
      t="edge_pop x"
      and s="[y]"
      in ssubst)
     apply(rename_tac x a y qt ab)(*strict*)
     apply(force)
    apply(rename_tac x a y qt ab)(*strict*)
    apply(simp (no_asm))
   apply(rename_tac e)(*strict*)
   apply(erule disjE)
    apply(rename_tac e)(*strict*)
    apply(clarsimp)
    apply(rename_tac e x)(*strict*)
    apply(subgoal_tac "valid_epda_step_label G x")
     apply(rename_tac e x)(*strict*)
     prefer 2
     apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
    apply(rename_tac e x)(*strict*)
    apply(subgoal_tac "\<exists>y. edge_pop x=[y]")
     apply(rename_tac e x)(*strict*)
     prefer 2
     apply(rule_tac
      G="G"
      in valid_pda_edge_pop_single)
      apply(rename_tac e x)(*strict*)
      apply(simp add: valid_simple_dpda_def valid_dpda_def)
     apply(rename_tac e x)(*strict*)
     apply(force)
    apply(rename_tac e x)(*strict*)
    apply(case_tac "edge_push x")
     apply(rename_tac e x)(*strict*)
     apply(clarsimp)
     apply(rename_tac e x y)(*strict*)
     apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_pop_def)
    apply(rename_tac e x a list)(*strict*)
    apply(clarsimp)
   apply(rename_tac e)(*strict*)
   apply(clarsimp)
   apply(rename_tac e x)(*strict*)
   apply(subgoal_tac "valid_epda_step_label G x")
    apply(rename_tac e x)(*strict*)
    prefer 2
    apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
   apply(rename_tac e x)(*strict*)
   apply(subgoal_tac "\<exists>y. edge_pop x=[y]")
    apply(rename_tac e x)(*strict*)
    prefer 2
    apply(rule_tac
      G="G"
      in valid_pda_edge_pop_single)
     apply(rename_tac e x)(*strict*)
     apply(simp add: valid_simple_dpda_def valid_dpda_def)
    apply(rename_tac e x)(*strict*)
    apply(force)
   apply(rename_tac e x)(*strict*)
   apply(case_tac "edge_push x")
    apply(rename_tac e x)(*strict*)
    apply(clarsimp)
   apply(rename_tac e x a list)(*strict*)
   apply(clarsimp)
   apply(rename_tac e x a list y)(*strict*)
   apply(case_tac "edge_event x")
    apply(rename_tac e x a list y)(*strict*)
    apply(clarsimp)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_push_def)
    apply(clarsimp)
    apply(rename_tac x a list y qs qt)(*strict*)
    apply(simp add: valid_epda_step_label_def)
    apply(clarsimp)
    apply(rule conjI)
     apply(rename_tac x a list y qs qt)(*strict*)
     prefer 2
     apply(simp add: may_terminated_by_def append_language_def kleene_star_def)
     apply(clarsimp)
     apply(rename_tac x a list y qs qt aa ab)(*strict*)
     apply(erule_tac
      P="[] = aa \<and> y = epda_box G"
      in disjE)
      apply(rename_tac x a list y qs qt aa ab)(*strict*)
      apply(clarsimp)
      apply(rename_tac x a list qs qt ab)(*strict*)
      apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
     apply(rename_tac x a list y qs qt aa ab)(*strict*)
     apply(clarsimp)
     apply(rename_tac x a list y qs qt ab)(*strict*)
     apply(rule_tac
      A="set(edge_pop x)"
      in set_mp)
      apply(rename_tac x a list y qs qt ab)(*strict*)
      apply(force)
     apply(rename_tac x a list y qs qt ab)(*strict*)
     apply(rule_tac
      t="edge_pop x"
      and s="[y]"
      in ssubst)
      apply(rename_tac x a list y qs qt ab)(*strict*)
      apply(force)
     apply(rename_tac x a list y qs qt ab)(*strict*)
     apply(simp (no_asm))
    apply(rename_tac x a list y qs qt)(*strict*)
    apply(simp add: may_terminated_by_def append_language_def kleene_star_def)
    apply(clarsimp)
    apply(rename_tac x a list y qs qt aa ab)(*strict*)
    apply(erule_tac
      P="a # list = ab @ [epda_box G]"
      in disjE)
     apply(rename_tac x a list y qs qt aa ab)(*strict*)
     apply(clarsimp)
     apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
     apply(clarsimp)
     apply(rule_tac
      A="set(ab @ [epda_box G])"
      in set_mp)
      apply(rename_tac x a list y qs qt aa ab)(*strict*)
      apply(force)
     apply(rename_tac x a list y qs qt aa ab)(*strict*)
     apply(rule_tac
      t="ab @ [epda_box G]"
      and s="a # list"
      in ssubst)
      apply(rename_tac x a list y qs qt aa ab)(*strict*)
      apply(force)
     apply(rename_tac x a list y qs qt aa ab)(*strict*)
     apply(simp (no_asm))
    apply(rename_tac x a list y qs qt aa ab)(*strict*)
    apply(force)
   apply(rename_tac e x a list y aa)(*strict*)
   apply(force)
  apply(rename_tac e)(*strict*)
  apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_def)
  apply(erule disjE)
   apply(rename_tac e)(*strict*)
   apply(clarsimp)
   apply(rename_tac e x)(*strict*)
   apply(case_tac "edge_event x")
    apply(rename_tac e x)(*strict*)
    apply(clarsimp)
   apply(rename_tac e x a)(*strict*)
   apply(clarsimp)
   apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_read_def)
   apply(clarsimp)
   apply(rename_tac x a)(*strict*)
   apply(subgoal_tac "valid_epda_step_label G x")
    apply(rename_tac x a)(*strict*)
    prefer 2
    apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
   apply(rename_tac x a)(*strict*)
   apply(subgoal_tac "\<exists>y. edge_pop x=[y]")
    apply(rename_tac x a)(*strict*)
    prefer 2
    apply(rule_tac
      G="G"
      in valid_pda_edge_pop_single)
     apply(rename_tac x a)(*strict*)
     apply(simp add: valid_simple_dpda_def valid_dpda_def)
    apply(rename_tac x a)(*strict*)
    apply(force)
   apply(rename_tac x a)(*strict*)
   apply(clarsimp)
   apply(rename_tac x a y)(*strict*)
   apply(simp add: valid_epda_step_label_def option_to_set_def)
   apply(simp add: may_terminated_by_def append_language_def kleene_star_def)
   apply(clarsimp)
   apply(rename_tac x a y aa ab)(*strict*)
   apply(erule_tac
      P="[] = aa \<and> y = epda_box G"
      in disjE)
    apply(rename_tac x a y aa ab)(*strict*)
    apply(clarsimp)
    apply(rename_tac x a ab)(*strict*)
    apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
   apply(rename_tac x a y aa ab)(*strict*)
   apply(clarsimp)
   apply(rename_tac x a y ab)(*strict*)
   apply(rule_tac
      A="set(edge_pop x)"
      in set_mp)
    apply(rename_tac x a y ab)(*strict*)
    apply(force)
   apply(rename_tac x a y ab)(*strict*)
   apply(rule_tac
      t="edge_pop x"
      and s="[y]"
      in ssubst)
    apply(rename_tac x a y ab)(*strict*)
    apply(force)
   apply(rename_tac x a y ab)(*strict*)
   apply(simp (no_asm))
  apply(rename_tac e)(*strict*)
  apply(erule disjE)
   apply(rename_tac e)(*strict*)
   apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_final_def)
   apply(clarsimp)
   apply(rename_tac i A)(*strict*)
   apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
   apply(force)
  apply(rename_tac e)(*strict*)
  apply(clarsimp)
  apply(rename_tac e x)(*strict*)
  apply(case_tac "edge_push x")
   apply(rename_tac e x)(*strict*)
   apply(clarsimp)
  apply(rename_tac e x a list)(*strict*)
  apply(clarsimp)
  apply(case_tac "edge_event x")
   apply(rename_tac e x a list)(*strict*)
   prefer 2
   apply(rename_tac e x a list aa)(*strict*)
   apply(clarsimp)
  apply(rename_tac e x a list)(*strict*)
  apply(clarsimp)
  apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_push_def)
  apply(subgoal_tac "valid_epda_step_label G x")
   apply(rename_tac e x a list)(*strict*)
   prefer 2
   apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
  apply(rename_tac e x a list)(*strict*)
  apply(subgoal_tac "\<exists>y. edge_pop x=[y]")
   apply(rename_tac e x a list)(*strict*)
   prefer 2
   apply(rule_tac
      G="G"
      in valid_pda_edge_pop_single)
    apply(rename_tac e x a list)(*strict*)
    apply(simp add: valid_simple_dpda_def valid_dpda_def)
   apply(rename_tac e x a list)(*strict*)
   apply(force)
  apply(rename_tac e x a list)(*strict*)
  apply(clarsimp)
  apply(rename_tac e x a list y)(*strict*)
  apply(erule disjE)
   apply(rename_tac e x a list y)(*strict*)
   apply(clarsimp)
   apply(rename_tac x a list y)(*strict*)
   apply(simp add: valid_epda_step_label_def option_to_set_def)
   apply(rule conjI)
    apply(rename_tac x a list y)(*strict*)
    apply(simp add: may_terminated_by_def append_language_def kleene_star_def)
    apply(clarsimp)
    apply(rename_tac x a list y aa ab)(*strict*)
    apply(erule_tac
      P="[] = aa \<and> y = epda_box G"
      in disjE)
     apply(rename_tac x a list y aa ab)(*strict*)
     apply(clarsimp)
     apply(rename_tac x a list ab)(*strict*)
     apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
    apply(rename_tac x a list y aa ab)(*strict*)
    apply(clarsimp)
    apply(rename_tac x a list y ab)(*strict*)
    apply(rule_tac
      A="set(edge_pop x)"
      in set_mp)
     apply(rename_tac x a list y ab)(*strict*)
     apply(force)
    apply(rename_tac x a list y ab)(*strict*)
    apply(rule_tac
      t="edge_pop x"
      and s="[y]"
      in ssubst)
     apply(rename_tac x a list y ab)(*strict*)
     apply(force)
    apply(rename_tac x a list y ab)(*strict*)
    apply(simp (no_asm))
   apply(rename_tac x a list y)(*strict*)
   apply(simp add: may_terminated_by_def append_language_def kleene_star_def)
   apply(clarsimp)
   apply(rename_tac x a list y aa ab)(*strict*)
   apply(erule_tac
      P="a # list = ab @ [epda_box G]"
      in disjE)
    apply(rename_tac x a list y aa ab)(*strict*)
    apply(clarsimp)
    apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
    apply(clarsimp)
    apply(rule_tac
      A="set(ab @ [epda_box G])"
      in set_mp)
     apply(rename_tac x a list y aa ab)(*strict*)
     apply(force)
    apply(rename_tac x a list y aa ab)(*strict*)
    apply(rule_tac
      t="ab @ [epda_box G]"
      and s="a # list"
      in ssubst)
     apply(rename_tac x a list y aa ab)(*strict*)
     apply(force)
    apply(rename_tac x a list y aa ab)(*strict*)
    apply(simp (no_asm))
   apply(rename_tac x a list y aa ab)(*strict*)
   apply(force)
  apply(rename_tac e x a list y)(*strict*)
  apply(clarsimp)
  apply(rename_tac x a list y qs)(*strict*)
  apply(simp add: valid_epda_step_label_def option_to_set_def)
  apply(clarsimp)
  apply(subgoal_tac "y \<in> epda_gamma G")
   apply(rename_tac x a list y qs)(*strict*)
   apply(clarsimp)
   apply(simp add: may_terminated_by_def append_language_def kleene_star_def)
   apply(clarsimp)
   apply(rename_tac x a list y qs aa ab)(*strict*)
   apply(erule_tac
      P="a # list = ab @ [epda_box G]"
      in disjE)
    apply(rename_tac x a list y qs aa ab)(*strict*)
    apply(clarsimp)
    apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
    apply(clarsimp)
    apply(rule_tac
      A="set(ab @ [epda_box G])"
      in set_mp)
     apply(rename_tac x a list y qs aa ab)(*strict*)
     apply(force)
    apply(rename_tac x a list y qs aa ab)(*strict*)
    apply(rule_tac
      t="ab @ [epda_box G]"
      and s="a # list"
      in ssubst)
     apply(rename_tac x a list y qs aa ab)(*strict*)
     apply(force)
    apply(rename_tac x a list y qs aa ab)(*strict*)
    apply(simp (no_asm))
   apply(rename_tac x a list y qs aa ab)(*strict*)
   apply(force)
  apply(rename_tac x a list y qs)(*strict*)
  apply(simp add: may_terminated_by_def append_language_def kleene_star_def)
  apply(clarsimp)
  apply(rename_tac x a list y qs aa ab)(*strict*)
  apply(erule_tac
      P="[] = aa \<and> y = epda_box G"
      in disjE)
   apply(rename_tac x a list y qs aa ab)(*strict*)
   apply(clarsimp)
   apply(rename_tac x a list qs ab)(*strict*)
   apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
  apply(rename_tac x a list y qs aa ab)(*strict*)
  apply(clarsimp)
  apply(rename_tac x a list y qs ab)(*strict*)
  apply(rule_tac
      A="set(edge_pop x)"
      in set_mp)
   apply(rename_tac x a list y qs ab)(*strict*)
   apply(force)
  apply(rename_tac x a list y qs ab)(*strict*)
  apply(rule_tac
      t="edge_pop x"
      and s="[y]"
      in ssubst)
   apply(rename_tac x a list y qs ab)(*strict*)
   apply(force)
  apply(rename_tac x a list y qs ab)(*strict*)
  apply(simp (no_asm))
  done

lemma cfgRM_produce_and_eliminate_from_Cons: "
  valid_simple_dpda G
  \<Longrightarrow> valid_epda_step_label G \<lparr>edge_src = src, edge_event = Some a, edge_pop = [xb], edge_push = [xb], edge_trg = epdaS_conf_state c2\<rparr>
  \<Longrightarrow> \<lparr>edge_src = src, edge_event = Some a, edge_pop = [xb], edge_push = [xb], edge_trg = epdaS_conf_state c2\<rparr> \<in> epda_delta G
  \<Longrightarrow> epdaS_conf_stack c2 = xb # s
  \<Longrightarrow> epdaS_conf_scheduler c2 \<in> cfgRM_produce_and_eliminate_from (F_SDPDA_TO_CFG_STD G) (cons_l2   (epdaS_conf_state c2) xb)
  \<Longrightarrow> a # epdaS_conf_scheduler c2 \<in> cfgRM_produce_and_eliminate_from (F_SDPDA_TO_CFG_STD G) (cons_l2   src xb)"
  apply(simp add: cfgRM_produce_and_eliminate_from_def)
  apply(clarsimp)
  apply(rename_tac d i e)(*strict*)
  apply(rule_tac
      x="derivation_append (der2 \<lparr>cfg_conf = [teA (cons_l2   src xb)]\<rparr> \<lparr>prod_lhs=cons_l2 src xb,prod_rhs=[teB a,teA (cons_l2   (epdaS_conf_state c2) xb)]\<rparr> \<lparr>cfg_conf = [teB a,teA (cons_l2   (epdaS_conf_state c2) xb)]\<rparr>) (derivation_map d ((\<lambda>v. \<lparr>cfg_conf = [teB a] @ (cfg_conf v)\<rparr>))) (Suc 0)"
      in exI)
  apply(rule context_conjI)
   apply(rename_tac d i e)(*strict*)
   apply(rule cfgRM.derivation_append_preserves_derivation)
     apply(rename_tac d i e)(*strict*)
     apply(rule cfgRM.der2_is_derivation)
     apply(simp add: cfgRM_step_relation_def)
     apply(rule conjI)
      apply(rename_tac d i e)(*strict*)
      apply(simp add: F_SDPDA_TO_CFG_STD_def)
      apply(rule disjI2)
      apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_def)
      apply(rule disjI1)
      apply(rule_tac
      x="\<lparr>edge_src = src, edge_event = Some a, edge_pop = [xb], edge_push = [xb], edge_trg = epdaS_conf_state c2\<rparr>"
      in bexI)
       apply(rename_tac d i e)(*strict*)
       prefer 2
       apply(force)
      apply(rename_tac d i e)(*strict*)
      apply(clarsimp)
      apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_read_def)
     apply(rename_tac d i e)(*strict*)
     apply(rule_tac
      x="[]"
      in exI)
     apply(rule_tac
      x="[]"
      in exI)
     apply(clarsimp)
    apply(rename_tac d i e)(*strict*)
    apply(rule cfgRM_derivation_map_preserves_derivation)
     apply(rename_tac d i e)(*strict*)
     apply(rule F_SDPDA_TO_CFG_STD__makes_CFG)
     apply(force)
    apply(rename_tac d i e)(*strict*)
    apply(force)
   apply(rename_tac d i e)(*strict*)
   apply(simp add: der2_def derivation_map_def)
  apply(rename_tac d i e)(*strict*)
  apply(rule conjI)
   apply(rename_tac d i e)(*strict*)
   apply(rule cfgRM.derivation_belongs)
      apply(rename_tac d i e)(*strict*)
      apply(rule F_SDPDA_TO_CFG_STD__makes_CFG)
      apply(force)
     apply(rename_tac d i e)(*strict*)
     apply(simp add: der2_def derivation_append_def)
    apply(rename_tac d i e)(*strict*)
    apply(simp add: cfg_configurations_def F_SDPDA_TO_CFG_STD_def)
    apply(simp add: valid_epda_step_label_def)
    apply(rule_tac
      w="[xb]"
      in may_terminated_by_decompose2)
      apply(rename_tac d i e)(*strict*)
      apply(force)
     apply(rename_tac d i e)(*strict*)
     apply(force)
    apply(rename_tac d i e)(*strict*)
    apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
   apply(rename_tac d i e)(*strict*)
   apply(force)
  apply(rename_tac d i e)(*strict*)
  apply(rule conjI)
   apply(rename_tac d i e)(*strict*)
   apply(simp add: der2_def derivation_append_def derivation_map_def)
  apply(rename_tac d i e)(*strict*)
  apply(rule_tac
      x="Suc i"
      in exI)
  apply(rule_tac
      x="if i=0 then Some \<lparr>prod_lhs = cons_l2 src xb, prod_rhs = [teB a, teA (cons_l2   (epdaS_conf_state c2) xb)]\<rparr> else e"
      in exI)
  apply(rename_tac d i e)(*strict*)
  apply(clarsimp)
  apply(simp add: der2_def derivation_append_def derivation_map_def)
  apply(clarsimp)
  done

lemma cfgRM_produce_and_eliminate_from_Cons2: "
  valid_simple_dpda G
  \<Longrightarrow> valid_epda_step_label G \<lparr>edge_src = src, edge_event = None, edge_pop = [A], edge_push = [B, A], edge_trg = q\<rparr>
  \<Longrightarrow> \<lparr>edge_src = src, edge_event = None, edge_pop = [A], edge_push = [B, A], edge_trg = q\<rparr> \<in> epda_delta G
  \<Longrightarrow> w \<in> cfgRM_produce_and_eliminate_from (F_SDPDA_TO_CFG_STD G) (cons_l2   q B)
  \<Longrightarrow> w \<in> cfgRM_produce_and_eliminate_from (F_SDPDA_TO_CFG_STD G) (cons_l2   src A)"
  apply(simp add: cfgRM_produce_and_eliminate_from_def)
  apply(clarsimp)
  apply(rename_tac d i e)(*strict*)
  apply(rule_tac
      x="derivation_append (der2 \<lparr>cfg_conf = [teA (cons_l2   src A)]\<rparr> \<lparr>prod_lhs=cons_l2 src A,prod_rhs=[teA (cons_l2   q B)]\<rparr> \<lparr>cfg_conf = [teA (cons_l2   q B)]\<rparr>) d (Suc 0)"
      in exI)
  apply(rule context_conjI)
   apply(rename_tac d i e)(*strict*)
   apply(rule cfgRM.derivation_append_preserves_derivation)
     apply(rename_tac d i e)(*strict*)
     apply(rule cfgRM.der2_is_derivation)
     apply(simp add: cfgRM_step_relation_def)
     apply(rule conjI)
      apply(rename_tac d i e)(*strict*)
      apply(simp add: F_SDPDA_TO_CFG_STD_def)
      apply(rule disjI2)
      apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_def)
      apply(rule disjI2)
      apply(rule disjI2)
      apply(rule_tac
      x="\<lparr>edge_src = src, edge_event = None, edge_pop = [A], edge_push = [B, A], edge_trg = q\<rparr>"
      in bexI)
       apply(rename_tac d i e)(*strict*)
       prefer 2
       apply(force)
      apply(rename_tac d i e)(*strict*)
      apply(clarsimp)
      apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_push_def)
     apply(rename_tac d i e)(*strict*)
     apply(rule_tac
      x="[]"
      in exI)
     apply(rule_tac
      x="[]"
      in exI)
     apply(clarsimp)
    apply(rename_tac d i e)(*strict*)
    apply(force)
   apply(rename_tac d i e)(*strict*)
   apply(simp add: der2_def derivation_map_def)
  apply(rename_tac d i e)(*strict*)
  apply(rule conjI)
   apply(rename_tac d i e)(*strict*)
   apply(rule cfgRM.derivation_belongs)
      apply(rename_tac d i e)(*strict*)
      apply(rule F_SDPDA_TO_CFG_STD__makes_CFG)
      apply(force)
     apply(rename_tac d i e)(*strict*)
     apply(simp add: der2_def derivation_append_def)
    apply(rename_tac d i e)(*strict*)
    apply(simp add: cfg_configurations_def F_SDPDA_TO_CFG_STD_def)
    apply(simp add: valid_epda_step_label_def)
    apply(rule_tac
      w="[A]"
      in may_terminated_by_decompose2)
      apply(rename_tac d i e)(*strict*)
      apply(force)
     apply(rename_tac d i e)(*strict*)
     apply(force)
    apply(rename_tac d i e)(*strict*)
    apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
   apply(rename_tac d i e)(*strict*)
   apply(force)
  apply(rename_tac d i e)(*strict*)
  apply(rule conjI)
   apply(rename_tac d i e)(*strict*)
   apply(simp add: der2_def derivation_append_def derivation_map_def)
  apply(rename_tac d i e)(*strict*)
  apply(rule_tac
      x="Suc i"
      in exI)
  apply(rule_tac
      x="if i=0 then Some \<lparr>prod_lhs = cons_l2 src A, prod_rhs = [teA (cons_l2   q B)]\<rparr> else e"
      in exI)
  apply(clarsimp)
  apply(simp add: der2_def derivation_append_def derivation_map_def)
  apply(clarsimp)
  done

lemma SDPDA_FB_executing_edge_strict: "
  valid_simple_dpda G
  \<Longrightarrow> e \<in> epda_delta G
  \<Longrightarrow> FB_executing_edge e
  \<Longrightarrow> edge_pop e = edge_push e"
  apply(simp add: valid_simple_dpda_def)
  apply(clarsimp)
  apply(erule_tac
      x="e"
      in ballE)
   prefer 2
   apply(force)
  apply(simp add: FB_executing_edge_def)
  apply(clarsimp)
  done

lemma F_SDPDA_TO_CFG_STD__40_imp_41_hlp: "
  valid_simple_dpda G
  \<Longrightarrow> valid_cfg GP
  \<Longrightarrow> F_SDPDA_TO_CFG_STD__edges_l3 G \<subseteq> cfg_productions GP
  \<Longrightarrow> \<forall>p \<in> cfg_productions GP. p \<notin> F_SDPDA_TO_CFG_STD__edges_l3 G \<longrightarrow> (\<exists>q A. prod_lhs p = cons_l2 q A)
  \<Longrightarrow> epdaS.derivation G d
  \<Longrightarrow> epdaS.belongs G d
  \<Longrightarrow> d 0 = Some (pair None \<lparr>epdaS_conf_state = qi, epdaS_conf_scheduler = x, epdaS_conf_stack = A # s\<rparr>)
  \<Longrightarrow> d j = Some (pair e \<lparr>epdaS_conf_state = q, epdaS_conf_scheduler = [], epdaS_conf_stack = A # s\<rparr>)
  \<Longrightarrow> \<forall>k \<le> j. \<forall>e c. d k = Some (pair e c) \<longrightarrow> (\<exists>w. epdaS_conf_stack c = w @ A # s)
  \<Longrightarrow> d (Suc j) = Some (pair e' \<lparr>epdaS_conf_state = qt, epdaS_conf_scheduler = [], epdaS_conf_stack = s\<rparr>)
  \<Longrightarrow> x \<in> cfgRM_produce_and_eliminate_from GP (cons_l3 qi A qt)"
  apply(induct j arbitrary: d e q e' qt A s qi x rule: less_induct)
  apply(rename_tac x d e q e' qt A s qi xa)(*strict*)
  apply(clarsimp)
  apply(case_tac x)
   apply(rename_tac x d e q e' qt A s qi xa)(*strict*)
   apply(simp add: cfgRM_produce_and_eliminate_from_def)
   apply(subgoal_tac "\<exists>e1 e2 c1 c2. d 0 = Some (pair e1 c1) \<and> d (Suc 0) = Some (pair (Some e2) c2) \<and> epdaS_step_relation G c1 e2 c2")
    apply(rename_tac x d e q e' qt A s qi xa)(*strict*)
    prefer 2
    apply(rule_tac
      m="Suc 0"
      in epdaS.step_detail_before_some_position)
      apply(rename_tac x d e q e' qt A s qi xa)(*strict*)
      apply(force)
     apply(rename_tac x d e q e' qt A s qi xa)(*strict*)
     apply(force)
    apply(rename_tac x d e q e' qt A s qi xa)(*strict*)
    apply(force)
   apply(rename_tac x d e q e' qt A s qi xa)(*strict*)
   apply(clarsimp)
   apply(rename_tac d q qt A s e2)(*strict*)
   apply(subgoal_tac "\<exists>x. edge_pop e2=[x]")
    apply(rename_tac d q qt A s e2)(*strict*)
    prefer 2
    apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def)
    apply(clarsimp)
    apply(erule_tac
      x="e2"
      and P="\<lambda>e2. length (edge_pop e2) = Suc 0"
      in ballE)
     apply(rename_tac d q qt A s e2)(*strict*)
     prefer 2
     apply(simp add: epdaS_step_relation_def)
    apply(rename_tac d q qt A s e2)(*strict*)
    apply(case_tac "edge_pop e2")
     apply(rename_tac d q qt A s e2)(*strict*)
     apply(force)
    apply(rename_tac d q qt A s e2 a list)(*strict*)
    apply(case_tac list)
     apply(rename_tac d q qt A s e2 a list)(*strict*)
     apply(force)
    apply(rename_tac d q qt A s e2 a list aa lista)(*strict*)
    apply(clarsimp)
   apply(rename_tac d q qt A s e2)(*strict*)
   apply(subgoal_tac "\<lparr>prod_lhs = cons_l3 q A qt, prod_rhs = []\<rparr> \<in> cfg_step_labels GP")
    apply(rename_tac d q qt A s e2)(*strict*)
    prefer 2
    apply(simp add: cfg_step_labels_def)
    apply(rule_tac
      A="F_SDPDA_TO_CFG_STD__edges_l3 G"
      in set_mp)
     apply(rename_tac d q qt A s e2)(*strict*)
     apply(force)
    apply(rename_tac d q qt A s e2)(*strict*)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_def)
    apply(rule disjI2)
    apply(rule disjI1)
    apply(rule_tac
      x="e2"
      in bexI)
     apply(rename_tac d q qt A s e2)(*strict*)
     prefer 2
     apply(simp add: epdaS_step_relation_def)
    apply(rename_tac d q qt A s e2)(*strict*)
    apply(case_tac "edge_push e2")
     apply(rename_tac d q qt A s e2)(*strict*)
     prefer 2
     apply(rename_tac d q qt A s e2 a list)(*strict*)
     apply(simp add: epdaS_step_relation_def)
     apply(clarsimp)
    apply(rename_tac d q qt A s e2)(*strict*)
    apply(clarsimp)
    apply(rename_tac d q qt A s e2 x)(*strict*)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_pop_def)
    apply(simp add: epdaS_step_relation_def)
   apply(rename_tac d q qt A s e2)(*strict*)
   apply(rule_tac
      x="der2 \<lparr>cfg_conf = [teA (cons_l3   q A qt)]\<rparr> \<lparr>prod_lhs=cons_l3 q A qt,prod_rhs=[]\<rparr> \<lparr>cfg_conf = []\<rparr>"
      in exI)
   apply(rename_tac d q qt A s e2)(*strict*)
   apply(rule conjI)
    apply(rename_tac d q qt A s e2)(*strict*)
    apply(rule cfgRM.der2_is_derivation)
    apply(simp add: cfgRM_step_relation_def)
    apply(simp add: cfg_step_labels_def)
   apply(rename_tac d q qt A s e2)(*strict*)
   apply(rule conjI)
    apply(rename_tac d q qt A s e2)(*strict*)
    prefer 2
    apply(simp add: der2_def)
    apply(force)
   apply(rename_tac d q qt A s e2)(*strict*)
   apply(rule cfgRM.der2_belongs)
     apply(rename_tac d q qt A s e2)(*strict*)
     apply(simp add: cfg_configurations_def)
     apply (metis cfg_step_labels_def prod_lhs_in_nonterms)
    apply(rename_tac d q qt A s e2)(*strict*)
    apply(force)
   apply(rename_tac d q qt A s e2)(*strict*)
   apply(simp add: cfg_configurations_def)
  apply(rename_tac x d e q e' qt A s qi xa nat)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e q e' qt A s qi xa nat)(*strict*)
  apply(rename_tac n)
  apply(rename_tac d e q e' qt A s qi xa n)(*strict*)
  apply(subgoal_tac "\<exists>e1 e2 c1 c2. d 0 = Some (pair e1 c1) \<and> d (Suc 0) = Some (pair (Some e2) c2) \<and> epdaS_step_relation G c1 e2 c2")
   apply(rename_tac d e q e' qt A s qi xa n)(*strict*)
   prefer 2
   apply(rule_tac
      m="Suc n"
      in epdaS.step_detail_before_some_position)
     apply(rename_tac d e q e' qt A s qi xa n)(*strict*)
     apply(force)
    apply(rename_tac d e q e' qt A s qi xa n)(*strict*)
    apply(force)
   apply(rename_tac d e q e' qt A s qi xa n)(*strict*)
   apply(force)
  apply(rename_tac d e q e' qt A s qi xa n)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e q e' qt A s qi xa n e2 c2)(*strict*)
  apply(subgoal_tac "\<exists>x. edge_pop e2=[x]")
   apply(rename_tac d e q e' qt A s qi xa n e2 c2)(*strict*)
   prefer 2
   apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def)
   apply(clarsimp)
   apply(erule_tac
      x="e2"
      and P="\<lambda>e2. length (edge_pop e2) = Suc 0"
      in ballE)
    apply(rename_tac d e q e' qt A s qi xa n e2 c2)(*strict*)
    prefer 2
    apply(simp add: epdaS_step_relation_def)
   apply(rename_tac d e q e' qt A s qi xa n e2 c2)(*strict*)
   apply(case_tac "edge_pop e2")
    apply(rename_tac d e q e' qt A s qi xa n e2 c2)(*strict*)
    apply(force)
   apply(rename_tac d e q e' qt A s qi xa n e2 c2 a list)(*strict*)
   apply(case_tac list)
    apply(rename_tac d e q e' qt A s qi xa n e2 c2 a list)(*strict*)
    apply(force)
   apply(rename_tac d e q e' qt A s qi xa n e2 c2 a list aa lista)(*strict*)
   apply(clarsimp)
  apply(rename_tac d e q e' qt A s qi xa n e2 c2)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e q e' qt A s qi xa n e2 c2 x)(*strict*)
  apply(case_tac "FB_executing_edge e2")
   apply(rename_tac d e q e' qt A s qi xa n e2 c2 x)(*strict*)
   apply(simp add: FB_executing_edge_def)
   apply(clarsimp)
   apply(rename_tac d e q e' qt A s qi xa n e2 c2 x y)(*strict*)
   apply(subgoal_tac "edge_pop e2=edge_push e2")
    apply(rename_tac d e q e' qt A s qi xa n e2 c2 x y)(*strict*)
    apply(clarsimp)
    apply(subgoal_tac "\<exists>x. xa=y # x \<and> c2=\<lparr>epdaS_conf_state = edge_trg e2, epdaS_conf_scheduler = x, epdaS_conf_stack = A # s\<rparr>")
     apply(rename_tac d e q e' qt A s qi xa n e2 c2 x y)(*strict*)
     prefer 2
     apply(simp add: epdaS_step_relation_def)
     apply(case_tac c2)
     apply(rename_tac d e q e' qt A s qi xa n e2 c2 x y epdaS_conf_statea epdaS_conf_schedulera epdaS_conf_stacka)(*strict*)
     apply(clarsimp)
     apply(rename_tac d e q e' qt s n e2 x y epdaS_conf_scheduler)(*strict*)
     apply(simp add: option_to_list_def)
    apply(rename_tac d e q e' qt A s qi xa n e2 c2 x y)(*strict*)
    apply(clarsimp)
    apply(rename_tac d e q e' qt A s qi n e2 x y xb)(*strict*)
    apply(erule_tac
      x="n"
      in meta_allE)
    apply(clarsimp)
    apply(erule_tac
      x="derivation_drop d (Suc 0)"
      in meta_allE)
    apply(erule_tac
      x="if n=0 then None else e"
      in meta_allE)
    apply(erule_tac
      x="q"
      in meta_allE)
    apply(erule_tac
      x="e'"
      in meta_allE)
    apply(erule_tac
      x="qt"
      in meta_allE)
    apply(erule_tac
      x="A"
      in meta_allE)
    apply(erule_tac
      x="s"
      in meta_allE)
    apply(erule_tac
      x="edge_trg e2"
      in meta_allE)
    apply(erule_tac
      x="xb"
      in meta_allE)
    apply(erule_tac meta_impE)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb)(*strict*)
     apply(rule_tac
      m="0"
      in epdaS.derivation_drop_preserves_derivation_prime)
      apply(rename_tac d e q e' qt A s qi n e2 x y xb)(*strict*)
      apply(force)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb)(*strict*)
     apply(force)
    apply(rename_tac d e q e' qt A s qi n e2 x y xb)(*strict*)
    apply(erule_tac meta_impE)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb)(*strict*)
     apply(rule_tac epdaS.derivation_drop_preserves_belongs)
       apply(rename_tac d e q e' qt A s qi n e2 x y xb)(*strict*)
       apply(force)
      apply(rename_tac d e q e' qt A s qi n e2 x y xb)(*strict*)
      apply(force)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb)(*strict*)
     apply(force)
    apply(rename_tac d e q e' qt A s qi n e2 x y xb)(*strict*)
    apply(erule_tac meta_impE)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb)(*strict*)
     apply(simp add: derivation_drop_def)
    apply(rename_tac d e q e' qt A s qi n e2 x y xb)(*strict*)
    apply(erule_tac meta_impE)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb)(*strict*)
     apply(simp add: derivation_drop_def)
     apply(clarsimp)
    apply(rename_tac d e q e' qt A s qi n e2 x y xb)(*strict*)
    apply(erule_tac meta_impE)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb)(*strict*)
     apply(clarsimp)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb k ea c)(*strict*)
     apply(erule_tac
      x="Suc k"
      in allE)
     apply(clarsimp)
     apply(simp add: derivation_drop_def)
     apply(case_tac k)
      apply(rename_tac d e q e' qt A s qi n e2 x y xb k ea c)(*strict*)
      apply(clarsimp)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb k ea c nat)(*strict*)
     apply(clarsimp)
    apply(rename_tac d e q e' qt A s qi n e2 x y xb)(*strict*)
    apply(erule_tac meta_impE)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb)(*strict*)
     apply(simp add: derivation_drop_def)
    apply(rename_tac d e q e' qt A s qi n e2 x y xb)(*strict*)
    apply(simp add: cfgRM_produce_and_eliminate_from_def)
    apply(clarsimp)
    apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
    apply(rule_tac
      x="derivation_append (der2 \<lparr>cfg_conf = [teA (cons_l3   qi A qt)]\<rparr> \<lparr>prod_lhs=cons_l3 qi A qt,prod_rhs=[teB y,teA (cons_l3   (edge_trg e2) A qt)]\<rparr> \<lparr>cfg_conf = [teB y]@[teA (cons_l3   (edge_trg e2) A qt)]\<rparr>) (derivation_map da (\<lambda>c. \<lparr>cfg_conf=[teB y]@(cfg_conf c)\<rparr>)) (Suc 0)"
      in exI)
    apply(subgoal_tac "\<lparr>prod_lhs = cons_l3 qi A qt, prod_rhs = [teB y, teA (cons_l3   (edge_trg e2) A qt)]\<rparr> \<in> cfg_productions GP")
     apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
     prefer 2
     apply(rule_tac
      A="F_SDPDA_TO_CFG_STD__edges_l3 G"
      in set_mp)
      apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
      apply(force)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
     apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_def)
     apply(rule disjI1)
     apply(rule_tac
      x="e2"
      in bexI)
      apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
      prefer 2
      apply(simp add: epdaS_step_relation_def)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
     apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_read_def)
     apply(clarsimp)
     apply(simp add: epdaS_step_relation_def)
     apply(clarsimp)
     apply(rename_tac d e q e' qt s n e2 x y xb da i ea)(*strict*)
     apply(subgoal_tac "\<lparr>epdaS_conf_state = qt, epdaS_conf_scheduler = [], epdaS_conf_stack = s\<rparr> \<in> epdaS_configurations G ")
      apply(rename_tac d e q e' qt s n e2 x y xb da i ea)(*strict*)
      apply(simp add: epdaS_configurations_def)
     apply(rename_tac d e q e' qt s n e2 x y xb da i ea)(*strict*)
     apply(rule_tac epdaS.belongs_configurations)
      apply(rename_tac d e q e' qt s n e2 x y xb da i ea)(*strict*)
      apply(force)
     apply(rename_tac d e q e' qt s n e2 x y xb da i ea)(*strict*)
     apply(force)
    apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
    apply(rule context_conjI)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
     apply(rule cfgRM.derivation_append_preserves_derivation)
       apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
       apply(rule cfgRM.der2_is_derivation)
       apply(simp add: cfgRM_step_relation_def)
       apply(rule_tac
      x="[]"
      in exI)
       apply(rule_tac
      x="[]"
      in exI)
       apply(clarsimp)
      apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
      apply(rule cfgRM.derivation_map_preserves_derivation2)
       apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
       apply(force)
      apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
      apply(rule cfgRM_step_relation_contextOK1)
      apply(clarsimp)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
     apply(simp add: der2_def derivation_map_def)
    apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
    apply(rule conjI)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
     apply(rule cfgRM.derivation_append_preserves_belongs)
       apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
       apply(force)
      apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
      apply(rule cfgRM.der2_belongs)
        apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
        apply(simp add: cfg_configurations_def)
        apply (metis prod_lhs_in_nonterms)
       apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
       apply(simp add: cfg_step_labels_def)
      apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
      apply(simp only: cfg_configurations_def)
      apply(subgoal_tac "setA [teB y, teA (cons_l3   (edge_trg e2) A qt)] \<subseteq> cfg_nonterminals GP")
       apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
       apply(subgoal_tac "setB [teB y, teA (cons_l3   (edge_trg e2) A qt)] \<subseteq> cfg_events GP")
        apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
        apply(force)
       apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
       apply(rule prod_rhs_in_cfg_events)
        apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
        apply(force)
       apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
       apply(force)
      apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
      apply(rule prod_rhs_in_nonterms)
       apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
       apply(force)
      apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
      apply(force)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
     apply(force)
    apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
    apply(rule conjI)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
     apply(simp add: derivation_append_def der2_def derivation_map_def)
    apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
    apply(rule_tac
      x="Suc i"
      in exI)
    apply(simp add: derivation_append_def)
    apply(case_tac i)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea)(*strict*)
     apply(clarsimp)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb da)(*strict*)
     apply(subgoal_tac "False")
      apply(rename_tac d e q e' qt A s qi n e2 x y xb da)(*strict*)
      apply(force)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb da)(*strict*)
     apply(case_tac xb)
      apply(rename_tac d e q e' qt A s qi n e2 x y xb da)(*strict*)
      apply(clarsimp)
     apply(rename_tac d e q e' qt A s qi n e2 x y xb da a list)(*strict*)
     apply(clarsimp)
    apply(rename_tac d e q e' qt A s qi n e2 x y xb da i ea nat)(*strict*)
    apply(clarsimp)
    apply(rename_tac d e q e' qt A s qi n e2 x y xb da ea nat)(*strict*)
    apply(simp add: derivation_map_def)
   apply(rename_tac d e q e' qt A s qi xa n e2 c2 x y)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e q e' qt A s qi xa n e2 c2 x y)(*strict*)
   apply(subgoal_tac "edge_pop e2 = edge_push e2")
    apply(rename_tac d e q e' qt A s qi xa n e2 c2 x y)(*strict*)
    prefer 2
    apply(rule SDPDA_FB_executing_edge_strict)
      apply(rename_tac d e q e' qt A s qi xa n e2 c2 x y)(*strict*)
      apply(force)
     apply(rename_tac d e q e' qt A s qi xa n e2 c2 x y)(*strict*)
     apply(simp add: epdaS_step_relation_def)
    apply(rename_tac d e q e' qt A s qi xa n e2 c2 x y)(*strict*)
    apply(simp add: FB_executing_edge_def)
   apply(rename_tac d e q e' qt A s qi xa n e2 c2 x y)(*strict*)
   apply(force)
  apply(rename_tac d e q e' qt A s qi xa n e2 c2 x)(*strict*)
  apply(case_tac "empty_push_edge e2")
   apply(rename_tac d e q e' qt A s qi xa n e2 c2 x)(*strict*)
   apply(subgoal_tac "False")
    apply(rename_tac d e q e' qt A s qi xa n e2 c2 x)(*strict*)
    apply(force)
   apply(rename_tac d e q e' qt A s qi xa n e2 c2 x)(*strict*)
   apply(thin_tac "\<And>y d e q e' qt A s qi x. y < Suc n \<Longrightarrow> epdaS.derivation G d \<Longrightarrow> epdaS.belongs G d \<Longrightarrow> d 0 = Some (pair None \<lparr>epdaS_conf_state = qi, epdaS_conf_scheduler = x, epdaS_conf_stack = A # s\<rparr>) \<Longrightarrow> d y = Some (pair e \<lparr>epdaS_conf_state = q, epdaS_conf_scheduler = [], epdaS_conf_stack = A # s\<rparr>) \<Longrightarrow> \<forall>k \<le> y. \<forall>e c. d k = Some (pair e c) \<longrightarrow> (\<exists>w. epdaS_conf_stack c = w @ A # s) \<Longrightarrow> d (Suc y) = Some (pair e' \<lparr>epdaS_conf_state = qt, epdaS_conf_scheduler = [], epdaS_conf_stack = s\<rparr>) \<Longrightarrow> x \<in> cfgRM_produce_and_eliminate_from GP (cons_l3 qi A qt)")
   apply(rename_tac d e q e' qt A s qi xa n e2 c2 x)(*strict*)
   apply(erule_tac
      x="Suc 0"
      in allE)
   apply(clarsimp)
   apply(rename_tac d e q e' qt A s qi xa n e2 c2 x w)(*strict*)
   apply(simp add: epdaS_step_relation_def empty_push_edge_def)
  apply(rename_tac d e q e' qt A s qi xa n e2 c2 x)(*strict*)
  apply(subgoal_tac "\<exists>y. edge_push e2 = [y,x]")
   apply(rename_tac d e q e' qt A s qi xa n e2 c2 x)(*strict*)
   prefer 2
   apply(simp add: valid_simple_dpda_def)
   apply(clarsimp)
   apply(erule_tac
      x="e2"
      in ballE)
    apply(rename_tac d e q e' qt A s qi xa n e2 c2 x)(*strict*)
    prefer 2
    apply(simp add: epdaS_step_relation_def)
   apply(rename_tac d e q e' qt A s qi xa n e2 c2 x)(*strict*)
   apply(simp add: FB_executing_edge_def empty_push_edge_def)
  apply(rename_tac d e q e' qt A s qi xa n e2 c2 x)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e q e' qt A s qi xa n e2 c2 x y)(*strict*)
  apply(simp add: FB_executing_edge_def empty_push_edge_def)
  apply(rename_tac d e q e' qt A s qi xa n e2 c2 x y)(*strict*)
  apply(subgoal_tac "x=A")
   apply(rename_tac d e q e' qt A s qi xa n e2 c2 x y)(*strict*)
   prefer 2
   apply(simp add: epdaS_step_relation_def)
  apply(rename_tac d e q e' qt A s qi xa n e2 c2 x y)(*strict*)
  apply(rename_tac B)
  apply(rename_tac d e q e' qt A s qi xa n e2 c2 x B)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e q e' qt A s qi xa n e2 c2 B)(*strict*)
  apply(subgoal_tac "\<exists>qi'. c2=\<lparr>epdaS_conf_state = qi', epdaS_conf_scheduler = xa, epdaS_conf_stack = B # A # s\<rparr>")
   apply(rename_tac d e q e' qt A s qi xa n e2 c2 B)(*strict*)
   prefer 2
   apply(simp add: epdaS_step_relation_def)
   apply(case_tac c2)
   apply(rename_tac d e q e' qt A s qi xa n e2 c2 B epdaS_conf_statea epdaS_conf_schedulera epdaS_conf_stacka)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e q e' qt A s n e2 B epdaS_conf_scheduler)(*strict*)
   apply(simp add: option_to_list_def)
  apply(rename_tac d e q e' qt A s qi xa n e2 c2 B)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e q e' qt A s qi xa n e2 B qi')(*strict*)
  apply(subgoal_tac "\<exists>k \<le> SSn. (\<forall>i<k. \<not> SSP i) \<and> SSP k" for SSn SSP)
   apply(rename_tac d e q e' qt A s qi xa n e2 B qi')(*strict*)
   prefer 2
   apply(rule_tac
      n="n"
      and P="\<lambda>k. epdaS_conf_stack(the(get_configuration(d (Suc k))))=A # s"
      in ex_least_nat_le_prime)
   apply(simp add: get_configuration_def)
  apply(rename_tac d e q e' qt A s qi xa n e2 B qi')(*strict*)
  apply(clarsimp)
  apply(rename_tac d e q e' qt A s qi xa n e2 B qi' k)(*strict*)
  apply(subgoal_tac "\<exists>e c. d (Suc k) = Some (pair (Some e) c)")
   apply(rename_tac d e q e' qt A s qi xa n e2 B qi' k)(*strict*)
   prefer 2
   apply(rule_tac
      m="Suc n"
      in epdaS.pre_some_position_is_some_position_prime)
      apply(rename_tac d e q e' qt A s qi xa n e2 B qi' k)(*strict*)
      apply(force)
     apply(rename_tac d e q e' qt A s qi xa n e2 B qi' k)(*strict*)
     apply(force)
    apply(rename_tac d e q e' qt A s qi xa n e2 B qi' k)(*strict*)
    apply(force)
   apply(rename_tac d e q e' qt A s qi xa n e2 B qi' k)(*strict*)
   apply(force)
  apply(rename_tac d e q e' qt A s qi xa n e2 B qi' k)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e q e' qt A s qi xa n e2 B qi' k ea c)(*strict*)
  apply(subgoal_tac "epdaS_conf_stack c = A # s")
   apply(rename_tac d e q e' qt A s qi xa n e2 B qi' k ea c)(*strict*)
   prefer 2
   apply(simp add: get_configuration_def)
  apply(rename_tac d e q e' qt A s qi xa n e2 B qi' k ea c)(*strict*)
  apply(thin_tac "epdaS_conf_stack (the (get_configuration (Some (pair (Some ea) c)))) = A # s")
  apply(rename_tac d e q e' qt A s qi xa n e2 B qi' k ea c)(*strict*)
  apply(case_tac k)
   apply(rename_tac d e q e' qt A s qi xa n e2 B qi' k ea c)(*strict*)
   apply(clarsimp)
  apply(rename_tac d e q e' qt A s qi xa n e2 B qi' k ea c nat)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e q e' qt A s qi xa n e2 B qi' ea c nat)(*strict*)
  apply(rename_tac k)
  apply(rename_tac d e q e' qt A s qi xa n e2 B qi' ea c k)(*strict*)
  apply(case_tac c)
  apply(rename_tac d e q e' qt A s qi xa n e2 B qi' ea c k epdaS_conf_state epdaS_conf_scheduler epdaS_conf_stacka)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e q e' qt A s qi xa n e2 B qi' ea k epdaS_conf_state epdaS_conf_scheduler)(*strict*)
  apply(rename_tac q xb)
  apply(rename_tac d e qa e' qt A s qi xa n e2 B qi' ea k q xb)(*strict*)
  apply(subgoal_tac "\<exists>w. epdaS_string_state \<lparr>epdaS_conf_state = qi', epdaS_conf_scheduler = xa, epdaS_conf_stack = B # A # s\<rparr> = w @ epdaS_string_state \<lparr>epdaS_conf_state = q, epdaS_conf_scheduler = xb, epdaS_conf_stack = A # s\<rparr>")
   apply(rename_tac d e qa e' qt A s qi xa n e2 B qi' ea k q xb)(*strict*)
   prefer 2
   apply(rule_tac
      j="Suc k"
      and P="G"
      in epdaS.derivation_monotonically_dec)
        apply(rename_tac d e qa e' qt A s qi xa n e2 B qi' ea k q xb)(*strict*)
        apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def)
       apply(rename_tac d e qa e' qt A s qi xa n e2 B qi' ea k q xb)(*strict*)
       apply(force)
      apply(rename_tac d e qa e' qt A s qi xa n e2 B qi' ea k q xb)(*strict*)
      apply(force)
     apply(rename_tac d e qa e' qt A s qi xa n e2 B qi' ea k q xb)(*strict*)
     apply(force)
    apply(rename_tac d e qa e' qt A s qi xa n e2 B qi' ea k q xb)(*strict*)
    apply(force)
   apply(rename_tac d e qa e' qt A s qi xa n e2 B qi' ea k q xb)(*strict*)
   apply(force)
  apply(rename_tac d e qa e' qt A s qi xa n e2 B qi' ea k q xb)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e qa e' qt A s qi xa n e2 B qi' ea k q xb w)(*strict*)
  apply(simp add: epdaS_string_state_def)
  apply(clarsimp)
  apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q xb w)(*strict*)
  apply(subgoal_tac "\<exists>e1 e2 c1 c2. d (Suc k) = Some (pair e1 c1) \<and> d (Suc (Suc k)) = Some (pair (Some e2) c2) \<and> epdaS_step_relation G c1 e2 c2")
   apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q xb w)(*strict*)
   prefer 2
   apply(rule_tac
      m="Suc (Suc k)"
      in epdaS.step_detail_before_some_position)
     apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q xb w)(*strict*)
     apply(force)
    apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q xb w)(*strict*)
    apply(force)
   apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q xb w)(*strict*)
   apply(force)
  apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q xb w)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q xb w e1 c1)(*strict*)
  apply(subgoal_tac "epdaS_conf_stack c1 \<noteq> A # s")
   apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q xb w e1 c1)(*strict*)
   prefer 2
   apply(erule_tac
      x="k"
      and P="\<lambda>x. x < Suc k \<longrightarrow> epdaS_conf_stack (the (get_configuration (d (Suc x)))) \<noteq> A # s"
      in allE)
   apply(simp add: get_configuration_def)
  apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q xb w e1 c1)(*strict*)
  apply(rename_tac w2 w1 e1 c1)
  apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
  apply(subgoal_tac "w1 \<in> cfgRM_produce_and_eliminate_from GP (cons_l3 qi' B q)")
   apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
   apply(subgoal_tac "w2 \<in> cfgRM_produce_and_eliminate_from GP (cons_l3 q A qt)")
    apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
    apply(rule cfgRM_produce_and_eliminate_from_concatenate)
       apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
       apply(force)
      apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
      apply(force)
     apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
     apply(force)
    apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
    apply(thin_tac "\<And>y d e q e' qt A s qi x. y < Suc n \<Longrightarrow> epdaS.derivation G d \<Longrightarrow> epdaS.belongs G d \<Longrightarrow> d 0 = Some (pair None \<lparr>epdaS_conf_state = qi, epdaS_conf_scheduler = x, epdaS_conf_stack = A # s\<rparr>) \<Longrightarrow> d y = Some (pair e \<lparr>epdaS_conf_state = q, epdaS_conf_scheduler = [], epdaS_conf_stack = A # s\<rparr>) \<Longrightarrow> \<forall>k \<le> y. \<forall>e c. d k = Some (pair e c) \<longrightarrow> (\<exists>w. epdaS_conf_stack c = w @ A # s) \<Longrightarrow> d (Suc y) = Some (pair e' \<lparr>epdaS_conf_state = qt, epdaS_conf_scheduler = [], epdaS_conf_stack = s\<rparr>) \<Longrightarrow> x \<in> cfgRM_produce_and_eliminate_from GP (cons_l3 qi A qt)")
    apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
    apply(rule_tac
      A="F_SDPDA_TO_CFG_STD__edges_l3 G"
      in set_mp)
     apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
     apply(force)
    apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
    apply(simp (no_asm) add: F_SDPDA_TO_CFG_STD__edges_l3_def)
    apply(rule disjI2)
    apply(rule disjI2)
    apply(rule_tac
      x="e2"
      in bexI)
     apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
     prefer 2
     apply(simp add: epdaS_step_relation_def)
    apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
    apply(case_tac "edge_push e2")
     apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
     apply(clarsimp)
    apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 a list)(*strict*)
    apply(simp add: epdaS_step_relation_def)
    apply(simp (no_asm) add: F_SDPDA_TO_CFG_STD__edges_l3_push_def)
    apply(simp add: epdaS_step_relation_def)
    apply(rule conjI)
     apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 a list)(*strict*)
     apply(subgoal_tac "valid_epda_step_label G ea")
      apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 a list)(*strict*)
      apply(simp add: valid_epda_step_label_def)
     apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 a list)(*strict*)
     apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
    apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 a list)(*strict*)
    apply(subgoal_tac "\<lparr>epdaS_conf_state = qt, epdaS_conf_scheduler = [], epdaS_conf_stack = s\<rparr> \<in> epdaS_configurations G")
     apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 a list)(*strict*)
     apply(simp add: epdaS_configurations_def)
    apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 a list)(*strict*)
    apply(rule epdaS.belongs_configurations)
     apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 a list)(*strict*)
     apply(force)
    apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 a list)(*strict*)
    apply(force)
   apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
   apply(thin_tac "w1 \<in> cfgRM_produce_and_eliminate_from GP (cons_l3 qi' B q)")
   apply(simp add: cfgRM_produce_and_eliminate_from_def)
   apply(case_tac "n-Suc k")
    apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
    apply(clarsimp)
    apply(rename_tac d qa e' qt A s qi e2 B qi' ea k w1 e1 c1)(*strict*)
    apply(erule_tac
      x="0"
      in meta_allE)
    apply(erule_tac
      x="derivation_drop d (Suc (Suc k))"
      in meta_allE)
    apply(clarsimp)
    apply(erule_tac
      x="None"
      in meta_allE)
    apply(erule_tac
      x="qa"
      in meta_allE)
    apply(erule_tac
      x="e'"
      in meta_allE)
    apply(erule_tac
      x="qt"
      in meta_allE)
    apply(erule_tac
      x="A"
      in meta_allE)
    apply(erule_tac
      x="s"
      in meta_allE)
    apply(erule_tac
      x="qa"
      in meta_allE)
    apply(erule_tac
      x="[]"
      in meta_allE)
    apply(erule meta_impE)
     apply(rename_tac d qa e' qt A s qi e2 B qi' ea k w1 e1 c1)(*strict*)
     apply(rule epdaS.derivation_drop_preserves_derivation_prime)
      apply(rename_tac d qa e' qt A s qi e2 B qi' ea k w1 e1 c1)(*strict*)
      apply(force)
     apply(rename_tac d qa e' qt A s qi e2 B qi' ea k w1 e1 c1)(*strict*)
     apply(force)
    apply(rename_tac d qa e' qt A s qi e2 B qi' ea k w1 e1 c1)(*strict*)
    apply(erule meta_impE)
     apply(rename_tac d qa e' qt A s qi e2 B qi' ea k w1 e1 c1)(*strict*)
     apply(rule epdaS.derivation_drop_preserves_belongs)
       apply(rename_tac d qa e' qt A s qi e2 B qi' ea k w1 e1 c1)(*strict*)
       apply(force)
      apply(rename_tac d qa e' qt A s qi e2 B qi' ea k w1 e1 c1)(*strict*)
      apply(force)
     apply(rename_tac d qa e' qt A s qi e2 B qi' ea k w1 e1 c1)(*strict*)
     apply(force)
    apply(rename_tac d qa e' qt A s qi e2 B qi' ea k w1 e1 c1)(*strict*)
    apply(clarsimp)
    apply(erule meta_impE)
     apply(rename_tac d qa e' qt A s qi e2 B qi' ea k w1 e1 c1)(*strict*)
     apply(simp add: derivation_drop_def)
    apply(rename_tac d qa e' qt A s qi e2 B qi' ea k w1 e1 c1)(*strict*)
    apply(erule meta_impE)
     apply(rename_tac d qa e' qt A s qi e2 B qi' ea k w1 e1 c1)(*strict*)
     apply(simp add: derivation_drop_def)
    apply(rename_tac d qa e' qt A s qi e2 B qi' ea k w1 e1 c1)(*strict*)
    apply(force)
   apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
   apply(erule_tac
      x="(Suc n) - (Suc (Suc k))"
      in meta_allE)
   apply(erule_tac
      x="derivation_drop d (Suc (Suc k))"
      in meta_allE)
   apply(erule_tac
      x="e"
      in meta_allE)
   apply(erule_tac
      x="qa"
      in meta_allE)
   apply(erule_tac
      x="e'"
      in meta_allE)
   apply(erule_tac
      x="qt"
      in meta_allE)
   apply(erule_tac
      x="A"
      in meta_allE)
   apply(erule_tac
      x="s"
      in meta_allE)
   apply(erule_tac
      x="q"
      in meta_allE)
   apply(erule_tac
      x="w2"
      in meta_allE)
   apply(erule meta_impE)
    apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
    apply(force)
   apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
    apply(rule epdaS.derivation_drop_preserves_derivation_prime)
     apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
     apply(force)
    apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
    apply(force)
   apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
    apply(rule epdaS.derivation_drop_preserves_belongs)
      apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
      apply(force)
     apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
     apply(force)
    apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
    apply(force)
   apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
    apply(simp add: derivation_drop_def)
   apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
   apply(subgoal_tac "n=Suc nat+Suc k")
    apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
    prefer 2
    apply(force)
   apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e qa e' qt A s qi e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d e qa e' qt A s qi e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
    apply(simp add: derivation_drop_def)
   apply(rename_tac d e qa e' qt A s qi e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d e qa e' qt A s qi e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
    prefer 2
    apply(erule meta_impE)
     apply(rename_tac d e qa e' qt A s qi e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
     apply(simp add: derivation_drop_def)
    apply(rename_tac d e qa e' qt A s qi e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
    apply(force)
   apply(rename_tac d e qa e' qt A s qi e2 B qi' ea k q w2 w1 e1 c1 nat)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e qa e' qt A s qi e2 B qi' ea k q w2 w1 e1 c1 nat ka eb c)(*strict*)
   apply(erule_tac
      x="Suc (Suc k) + ka"
      and P="\<lambda>x. x \<le> Suc (Suc (Suc (nat + k))) \<longrightarrow> (\<forall>e c. d x = Some (pair e c) \<longrightarrow> (\<exists>w. epdaS_conf_stack c = w @ A # s))"
      in allE)
   apply(rename_tac d e qa e' qt A s qi e2 B qi' ea k q w2 w1 e1 c1 nat ka eb c)(*strict*)
   apply(erule impE)
    apply(rename_tac d e qa e' qt A s qi e2 B qi' ea k q w2 w1 e1 c1 nat ka eb c)(*strict*)
    apply(force)
   apply(rename_tac d e qa e' qt A s qi e2 B qi' ea k q w2 w1 e1 c1 nat ka eb c)(*strict*)
   apply(simp add: derivation_drop_def)
   apply(case_tac ka)
    apply(rename_tac d e qa e' qt A s qi e2 B qi' ea k q w2 w1 e1 c1 nat ka eb c)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e qa e' qt A s qi e2 B qi' ea k q w2 w1 e1 c1 nat ka eb c nata)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e qa e' qt A s qi e2 B qi' ea k q w2 w1 e1 c1 nat eb c nata)(*strict*)
   apply(erule_tac
      x="eb"
      in allE)
   apply(erule_tac
      x="c"
      in allE)
   apply(clarsimp)
   apply(subgoal_tac "nata+k=k+nata")
    apply(rename_tac d e qa e' qt A s qi e2 B qi' ea k q w2 w1 e1 c1 nat eb c nata)(*strict*)
    apply(force)
   apply(rename_tac d e qa e' qt A s qi e2 B qi' ea k q w2 w1 e1 c1 nat eb c nata)(*strict*)
   apply(force)
  apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
  apply(thin_tac "\<forall>k \<le> Suc n. \<forall>e c. d k = Some (pair e c) \<longrightarrow> (\<exists>w. epdaS_conf_stack c = w @ A # s)")
  apply(thin_tac "d (Suc n) = Some (pair e \<lparr>epdaS_conf_state = qa, epdaS_conf_scheduler = [], epdaS_conf_stack = A # s\<rparr>)")
  apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
  apply(thin_tac "d (Suc (Suc n)) = Some (pair e' \<lparr>epdaS_conf_state = qt, epdaS_conf_scheduler = [], epdaS_conf_stack = s\<rparr>)")
  apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
  apply(thin_tac "epdaS_step_relation G \<lparr>epdaS_conf_state = qi, epdaS_conf_scheduler = w1 @ w2, epdaS_conf_stack = A # s\<rparr> e2 \<lparr>epdaS_conf_state = qi', epdaS_conf_scheduler = w1 @ w2, epdaS_conf_stack = B # A # s\<rparr>")
  apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
  apply(thin_tac "edge_pop e2 = [A]")
  apply(thin_tac "edge_event e2 = None")
  apply(thin_tac "edge_push e2 = [B, A]")
  apply(thin_tac "d 0 = Some (pair None \<lparr>epdaS_conf_state = qi, epdaS_conf_scheduler = w1 @ w2, epdaS_conf_stack = A # s\<rparr>)")
  apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
  apply(erule_tac
      x="k"
      in meta_allE)
  apply(subgoal_tac "\<forall>i<Suc k. \<exists>w. epdaS_conf_stack (the (get_configuration (d (Suc i)))) = w @ B # A # s")
   apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
   prefer 2
   apply(clarsimp)
   apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 c1 i)(*strict*)
   apply(rule_tac
      k="k"
      in F_SDPDA_TO_CFG_STD__minimal_stack_does_not_occur)
        apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 c1 i)(*strict*)
        apply(force)
       apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 c1 i)(*strict*)
       apply(force)
      apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 c1 i)(*strict*)
      apply(force)
     apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 c1 i)(*strict*)
     apply(force)
    apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 c1 i)(*strict*)
    apply(force)
   apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 c1 i)(*strict*)
   apply(simp add: get_configuration_def)
  apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
  apply(subgoal_tac "\<exists>q. c1 = \<lparr>epdaS_conf_state = q, epdaS_conf_scheduler = w2, epdaS_conf_stack = B # A # s\<rparr>")
   apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
   prefer 2
   apply(case_tac c1)
   apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1 epdaS_conf_state epdaS_conf_scheduler epdaS_conf_stacka)(*strict*)
   apply(clarsimp)
   apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 epdaS_conf_state epdaS_conf_scheduler epdaS_conf_stacka)(*strict*)
   apply(rename_tac q inp s')
   apply(rename_tac d A s n e2 B qi' ea k qa w2 w1 e1 q inp s')(*strict*)
   apply(erule_tac
      x="k"
      and P="\<lambda>x. x < Suc k \<longrightarrow> epdaS_conf_stack (the (get_configuration (d (Suc x)))) \<noteq> A # s"
      in allE)
   apply(clarsimp)
   apply(simp add: get_configuration_def)
   apply(erule_tac
      x="k"
      in allE)
   apply(clarsimp)
   apply(rename_tac d A s n e2 B qi' ea k qa w2 w1 e1 q inp w)(*strict*)
   apply(simp add: epdaS_step_relation_def)
   apply(clarsimp)
   apply(rename_tac d A s n e2 B qi' ea k w2 w1 e1 w wa)(*strict*)
   apply(simp add: valid_simple_dpda_def)
   apply(clarsimp)
   apply(erule_tac
      x="ea"
      in ballE)
    apply(rename_tac d A s n e2 B qi' ea k w2 w1 e1 w wa)(*strict*)
    prefer 2
    apply(force)
   apply(rename_tac d A s n e2 B qi' ea k w2 w1 e1 w wa)(*strict*)
   apply(case_tac "edge_event ea")
    apply(rename_tac d A s n e2 B qi' ea k w2 w1 e1 w wa)(*strict*)
    prefer 2
    apply(rename_tac d A s n e2 B qi' ea k w2 w1 e1 w wa a)(*strict*)
    apply(clarsimp)
   apply(rename_tac d A s n e2 B qi' ea k w2 w1 e1 w wa)(*strict*)
   apply(clarsimp)
   apply(erule disjE)
    apply(rename_tac d A s n e2 B qi' ea k w2 w1 e1 w wa)(*strict*)
    prefer 2
    apply(clarsimp)
   apply(rename_tac d A s n e2 B qi' ea k w2 w1 e1 w wa)(*strict*)
   apply(clarsimp)
   apply(rename_tac d A s n e2 B qi' ea k w2 w1 e1 w)(*strict*)
   apply(subgoal_tac "\<exists>x. edge_pop ea=[x]")
    apply(rename_tac d A s n e2 B qi' ea k w2 w1 e1 w)(*strict*)
    apply(clarsimp)
    apply(rename_tac d A s n e2 qi' ea k w2 w1 e1 x)(*strict*)
    apply(simp add: option_to_list_def)
   apply(rename_tac d A s n e2 B qi' ea k w2 w1 e1 w)(*strict*)
   apply(rule_tac
      G="G"
      in valid_pda_edge_pop_single)
    apply(rename_tac d A s n e2 B qi' ea k w2 w1 e1 w)(*strict*)
    apply(simp add: valid_dpda_def)
   apply(rename_tac d A s n e2 B qi' ea k w2 w1 e1 w)(*strict*)
   apply(force)
  apply(rename_tac d e qa e' qt A s qi n e2 B qi' ea k q w2 w1 e1 c1)(*strict*)
  apply(clarsimp)
  apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
  apply(erule_tac
      x="derivation_map (derivation_drop (derivation_take d (Suc(Suc k))) (Suc 0)) (\<lambda>c. c\<lparr>epdaS_conf_scheduler := take (length (epdaS_conf_scheduler c) - length (epdaS_conf_scheduler \<lparr>epdaS_conf_state = q, epdaS_conf_scheduler = w2, epdaS_conf_stack = A # s\<rparr>)) (epdaS_conf_scheduler c) @ []\<rparr>)"
      in meta_allE)
  apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
  apply(erule_tac
      x="if k=0 then None else e1"
      in meta_allE)
  apply(erule_tac
      x="qa"
      in meta_allE)
  apply(erule_tac
      x="Some ea"
      in meta_allE)
  apply(erule_tac
      x="q"
      in meta_allE)
  apply(erule_tac
      x="B"
      in meta_allE)
  apply(erule_tac
      x="A # s"
      in meta_allE)
  apply(erule_tac
      x="qi'"
      in meta_allE)
  apply(erule_tac
      x="w1"
      in meta_allE)
  apply(subgoal_tac "epdaS.derivation G (derivation_map (derivation_drop (derivation_take d (Suc (Suc k))) (Suc 0)) (\<lambda>c. c\<lparr>epdaS_conf_scheduler := take (length (epdaS_conf_scheduler c) - length (epdaS_conf_scheduler \<lparr>epdaS_conf_state = q, epdaS_conf_scheduler = w2, epdaS_conf_stack = A # s\<rparr>)) (epdaS_conf_scheduler c) @ []\<rparr>))")
   apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
   prefer 2
   apply(rule_tac
      n="Suc k"
      and c="\<lparr>epdaS_conf_state = qi', epdaS_conf_scheduler = w1 @ w2, epdaS_conf_stack = B # A # s\<rparr>"
      in epda_maximal_context_preserves_derivation_prime)
         apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
         apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def)
        apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
        apply(simp add: derivation_take_def derivation_drop_def)
       apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
       apply(rule epdaS.derivation_drop_preserves_belongs)
         apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
         apply(rule epdaS.derivation_take_preserves_derivation)
         apply(force)
        apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
        apply(rule epdaS.derivation_take_preserves_belongs)
        apply(force)
       apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
       apply(simp add: derivation_take_def derivation_drop_def)
      apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
      apply(rule_tac
      m="0"
      in epdaS.derivation_drop_preserves_derivation_prime)
       apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
       apply(rule epdaS.derivation_take_preserves_derivation)
       apply(force)
      apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
      apply(simp add: derivation_take_def derivation_drop_def)
     apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
     apply(rule_tac
      t="Suc k"
      and s="Suc (Suc k) - Suc 0"
      in ssubst)
      apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
      apply(force)
     apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
     apply(rule epdaS.derivation_drop_makes_maximum_of_domain)
       apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
       apply(rule epdaS.derivation_take_preserves_derivation)
       apply(force)
      apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
      apply(clarsimp)
      apply(rule maximum_of_domain_derivation_take)
      apply(force)
     apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
     apply(force)
    apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
    apply(simp (no_asm) add: derivation_take_def derivation_drop_def)
   apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
   apply(clarsimp)
   apply(force)
  apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
  apply(erule meta_impE)
   apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
   apply(force)
  apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
  apply(erule meta_impE)
   apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
   apply(rule_tac
      ca="\<lparr>epdaS_conf_state = qi', epdaS_conf_scheduler = w1, epdaS_conf_stack = B # A # s\<rparr>"
      in epdaS.derivation_belongs)
      apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
      apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def)
     apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
     apply(simp add: derivation_take_def derivation_drop_def derivation_map_def)
    apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
    prefer 2
    apply(force)
   apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
   apply(subgoal_tac "\<lparr>epdaS_conf_state = qi', epdaS_conf_scheduler = w1@w2, epdaS_conf_stack = B # A # s\<rparr> \<in> epdaS_configurations G")
    apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
    apply(simp add: epdaS_configurations_def)
   apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
   apply(rule epdaS.belongs_configurations)
    apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
    apply(force)
   apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
   apply(force)
  apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
  apply(erule meta_impE)
   apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
   apply(simp add: derivation_take_def derivation_drop_def derivation_map_def)
  apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
  apply(erule meta_impE)
   apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
   apply(simp add: derivation_take_def derivation_drop_def derivation_map_def)
   apply(force)
  apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
  apply(erule meta_impE)
   apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
   prefer 2
   apply(erule meta_impE)
    apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
    apply(simp add: derivation_take_def derivation_drop_def derivation_map_def)
   apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
   apply(force)
  apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa)(*strict*)
  apply(clarsimp)
  apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa ka e c)(*strict*)
  apply(erule_tac
    x="ka"
    and P="\<lambda>ka. ka < Suc k \<longrightarrow> (\<exists>w. epdaS_conf_stack (the (get_configuration (d (Suc ka)))) = w @ B # A # s)"
    in allE)
  apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa ka e c)(*strict*)
  apply(clarsimp)
  apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa ka e c w)(*strict*)
  apply(subgoal_tac "\<exists>e c. d (Suc ka) = Some (pair e c)")
  apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa ka e c w)(*strict*)
  prefer 2
  apply(rule_tac
    m="Suc k"
    in epdaS.pre_some_position_is_some_position)
   apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa ka e c w)(*strict*)
   apply(force)
  apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa ka e c w)(*strict*)
  apply(force)
  apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa ka e c w)(*strict*)
  apply(force)
  apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa ka e c w)(*strict*)
  apply(clarsimp)
  apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa ka e c w eb ca)(*strict*)
  apply(simp add: get_configuration_def derivation_take_def derivation_drop_def derivation_map_def)
  apply(case_tac ka)
  apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa ka e c w eb ca)(*strict*)
  apply(clarsimp)
  apply(rename_tac d A s n e2 B qi' ea k q w2 w1 e1 qa ka e c w eb ca nat)(*strict*)
  apply(clarsimp)
  done

lemma F_SDPDA_TO_CFG_STD__42_imp_43_hlp: "
  valid_simple_dpda G
  \<Longrightarrow> GP = F_SDPDA_TO_CFG_STD G
  \<Longrightarrow> qf \<in> epda_marking G
  \<Longrightarrow> epdaS.derivation G d
  \<Longrightarrow> epdaS.belongs G d
  \<Longrightarrow> d 0 = Some (pair None \<lparr>epdaS_conf_state = qi, epdaS_conf_scheduler = x, epdaS_conf_stack = A # s\<rparr>)
  \<Longrightarrow> \<forall>k \<le> j. \<forall>e c. d k = Some (pair e c) \<longrightarrow> (\<exists>w. epdaS_conf_stack c = w @ A # s)
  \<Longrightarrow> d j = Some (pair e \<lparr>epdaS_conf_state = qf, epdaS_conf_scheduler = [], epdaS_conf_stack = s' @ A # s\<rparr>)
  \<Longrightarrow> x \<in> cfgRM_produce_and_eliminate_from GP (cons_l2   qi A)"
  apply(induct j arbitrary: d qi x A s e qf s' rule: less_induct)
  apply(rename_tac x d qi xa A s e qf s')(*strict*)
  apply(clarsimp)
  apply(case_tac x)
   apply(rename_tac x d qi xa A s e qf s')(*strict*)
   apply(clarsimp)
   apply(rename_tac d A s qf)(*strict*)
   apply(simp add: cfgRM_produce_and_eliminate_from_def)
   apply(thin_tac "\<And>y d qi x A s e qf s'. False \<Longrightarrow> qf \<in> epda_marking G \<Longrightarrow> epdaS.derivation G d \<Longrightarrow> epdaS.belongs G d \<Longrightarrow> d 0 = Some (pair None \<lparr>epdaS_conf_state = qi, epdaS_conf_scheduler = x, epdaS_conf_stack = A # s\<rparr>) \<Longrightarrow> \<forall>k \<le> y. \<forall>e c. d k = Some (pair e c) \<longrightarrow> (\<exists>w. epdaS_conf_stack c = w @ A # s) \<Longrightarrow> d y = Some (pair e \<lparr>epdaS_conf_state = qf, epdaS_conf_scheduler = [], epdaS_conf_stack = s' @ A # s\<rparr>) \<Longrightarrow> \<exists>d. cfgRM.derivation (F_SDPDA_TO_CFG_STD G) d \<and> cfgSTD.belongs (F_SDPDA_TO_CFG_STD G) d \<and> d 0 = Some (pair None \<lparr>cfg_conf = [teA (cons_l2   qi A)]\<rparr>) \<and> (\<exists>i e. d i = Some (pair e \<lparr>cfg_conf = liftB x\<rparr>))")
   apply(rename_tac d A s qf)(*strict*)
   apply(rule_tac
      x="der2 \<lparr>cfg_conf = [teA (cons_l2   qf A)]\<rparr> \<lparr>prod_lhs=cons_l2 qf A, prod_rhs=[]\<rparr> \<lparr>cfg_conf = []\<rparr>"
      in exI)
   apply(rule context_conjI)
    apply(rename_tac d A s qf)(*strict*)
    apply(rule cfgRM.der2_is_derivation)
    apply(simp add: cfgRM_step_relation_def)
    apply(simp add: F_SDPDA_TO_CFG_STD_def)
    apply(rule disjI2)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_def)
    apply(rule disjI2)
    apply(rule disjI1)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_final_def)
    apply(subgoal_tac "\<lparr>epdaS_conf_state = qf, epdaS_conf_scheduler = [], epdaS_conf_stack = A # s\<rparr> \<in> epdaS_configurations G")
     apply(rename_tac d A s qf)(*strict*)
     apply(simp add: epdaS_configurations_def)
    apply(rename_tac d A s qf)(*strict*)
    apply(rule epdaS.belongs_configurations)
     apply(rename_tac d A s qf)(*strict*)
     apply(force)
    apply(rename_tac d A s qf)(*strict*)
    apply(force)
   apply(rename_tac d A s qf)(*strict*)
   apply(rule conjI)
    apply(rename_tac d A s qf)(*strict*)
    apply(rule cfgRM.der2_belongs)
      apply(rename_tac d A s qf)(*strict*)
      apply(simp add: cfg_configurations_def)
      apply(simp add: F_SDPDA_TO_CFG_STD_def)
      apply(subgoal_tac "\<lparr>epdaS_conf_state = qf, epdaS_conf_scheduler = [], epdaS_conf_stack = A # s\<rparr> \<in> epdaS_configurations G")
       apply(rename_tac d A s qf)(*strict*)
       apply(simp add: epdaS_configurations_def)
      apply(rename_tac d A s qf)(*strict*)
      apply(rule epdaS.belongs_configurations)
       apply(rename_tac d A s qf)(*strict*)
       apply(force)
      apply(rename_tac d A s qf)(*strict*)
      apply(force)
     apply(rename_tac d A s qf)(*strict*)
     apply(simp add: cfg_step_labels_def F_SDPDA_TO_CFG_STD_def)
     apply(rule disjI2)
     apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_def)
     apply(rule disjI2)
     apply(rule disjI1)
     apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_final_def)
     apply(subgoal_tac "\<lparr>epdaS_conf_state = qf, epdaS_conf_scheduler = [], epdaS_conf_stack = A # s\<rparr> \<in> epdaS_configurations G")
      apply(rename_tac d A s qf)(*strict*)
      apply(simp add: epdaS_configurations_def)
     apply(rename_tac d A s qf)(*strict*)
     apply(rule epdaS.belongs_configurations)
      apply(rename_tac d A s qf)(*strict*)
      apply(force)
     apply(rename_tac d A s qf)(*strict*)
     apply(force)
    apply(rename_tac d A s qf)(*strict*)
    apply(simp add: cfg_configurations_def)
   apply(rename_tac d A s qf)(*strict*)
   apply(simp add: der2_def)
   apply(rule_tac
      x="Suc 0"
      in exI)
   apply(clarsimp)
  apply(rename_tac x d qi xa A s e qf s' nat)(*strict*)
  apply(clarsimp)
  apply(rename_tac d qi xa A s e qf s' nat)(*strict*)
  apply(rename_tac x)
  apply(rename_tac d qi xa A s e qf s' x)(*strict*)
  apply(subgoal_tac "\<exists>e1 e2 c1 c2. d 0 = Some (pair e1 c1) \<and> d (Suc 0) = Some (pair (Some e2) c2) \<and> epdaS_step_relation G c1 e2 c2")
   apply(rename_tac d qi xa A s e qf s' x)(*strict*)
   prefer 2
   apply(rule_tac
      m="Suc x"
      in epdaS.step_detail_before_some_position)
     apply(rename_tac d qi xa A s e qf s' x)(*strict*)
     apply(force)
    apply(rename_tac d qi xa A s e qf s' x)(*strict*)
    apply(force)
   apply(rename_tac d qi xa A s e qf s' x)(*strict*)
   apply(force)
  apply(rename_tac d qi xa A s e qf s' x)(*strict*)
  apply(clarsimp)
  apply(rename_tac d qi xa A s e qf s' x e2 c2)(*strict*)
  apply(subgoal_tac "\<exists>x. edge_pop e2=[x]")
   apply(rename_tac d qi xa A s e qf s' x e2 c2)(*strict*)
   prefer 2
   apply(rule_tac
      G="G"
      in valid_pda_edge_pop_single)
    apply(rename_tac d qi xa A s e qf s' x e2 c2)(*strict*)
    apply(simp add: valid_simple_dpda_def valid_dpda_def)
   apply(rename_tac d qi xa A s e qf s' x e2 c2)(*strict*)
   apply(simp add: epdaS_step_relation_def)
  apply(rename_tac d qi xa A s e qf s' x e2 c2)(*strict*)
  apply(subgoal_tac "valid_epda_step_label G e2")
   apply(rename_tac d qi xa A s e qf s' x e2 c2)(*strict*)
   prefer 2
   apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
   apply(simp add: epdaS_step_relation_def)
  apply(rename_tac d qi xa A s e qf s' x e2 c2)(*strict*)
  apply(clarsimp)
  apply(rename_tac d qi xa A s e qf s' x e2 c2 xb)(*strict*)
  apply(case_tac "edge_event e2")
   apply(rename_tac d qi xa A s e qf s' x e2 c2 xb)(*strict*)
   apply(case_tac "edge_push e2")
    (*pop edge*)
    apply(rename_tac d qi xa A s e qf s' x e2 c2 xb)(*strict*)
    apply(erule_tac
      x="Suc 0"
      in allE)
    apply(clarsimp)
    apply(rename_tac d qi xa A s e qf s' x e2 c2 xb w)(*strict*)
    apply(simp add: epdaS_step_relation_def)
   apply(rename_tac d qi xa A s e qf s' x e2 c2 xb a list)(*strict*)
   prefer 2
    (*read edge*)
   apply(rename_tac d qi xa A s e qf s' x e2 c2 xb a)(*strict*)
   apply(subgoal_tac "edge_pop e2=edge_push e2")
    apply(rename_tac d qi xa A s e qf s' x e2 c2 xb a)(*strict*)
    prefer 2
    apply(simp add: valid_simple_dpda_def)
    apply(clarsimp)
    apply(erule_tac
      x="e2"
      in ballE)
     apply(rename_tac d qi xa A s e qf s' x e2 c2 xb a)(*strict*)
     apply(clarsimp)
    apply(rename_tac d qi xa A s e qf s' x e2 c2 xb a)(*strict*)
    apply(simp add: epdaS_step_relation_def)
   apply(rename_tac d qi xa A s e qf s' x e2 c2 xb a)(*strict*)
   apply(clarsimp)
   apply(simp add: epdaS_step_relation_def option_to_list_def)
   apply(clarsimp)
   apply(rename_tac d s e qf s' x e2 c2 xb a)(*strict*)
   apply(erule_tac
      x="x"
      in meta_allE)
   apply(clarsimp)
   apply(erule_tac
      x="derivation_drop (derivation_take d (Suc x)) (Suc 0)"
      in meta_allE)
   apply(erule_tac
      x="epdaS_conf_state c2"
      in meta_allE)
   apply(erule_tac
      x="epdaS_conf_scheduler c2"
      in meta_allE)
   apply(erule_tac
      x="xb"
      in meta_allE)
   apply(erule_tac
      x="s"
      in meta_allE)
   apply(erule_tac
      x="if x=0 then None else e"
      in meta_allE)
   apply(erule_tac
      x="qf"
      in meta_allE)
   apply(erule_tac
      x="s'"
      in meta_allE)
   apply(clarsimp)
   apply(erule meta_impE)
    apply(rename_tac d s e qf s' x e2 c2 xb a)(*strict*)
    apply(rule_tac
      m="x"
      in epdaS.derivation_drop_preserves_derivation)
     apply(rename_tac d s e qf s' x e2 c2 xb a)(*strict*)
     apply(rule epdaS.derivation_take_preserves_derivation)
     apply(force)
    apply(rename_tac d s e qf s' x e2 c2 xb a)(*strict*)
    apply(rule_tac
      t="Suc 0+x"
      and s="Suc x"
      in ssubst)
     apply(rename_tac d s e qf s' x e2 c2 xb a)(*strict*)
     apply(force)
    apply(rename_tac d s e qf s' x e2 c2 xb a)(*strict*)
    apply(rule maximum_of_domain_derivation_take)
    apply(force)
   apply(rename_tac d s e qf s' x e2 c2 xb a)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d s e qf s' x e2 c2 xb a)(*strict*)
    apply(rule_tac epdaS.derivation_drop_preserves_belongs)
      apply(rename_tac d s e qf s' x e2 c2 xb a)(*strict*)
      apply(rule epdaS.derivation_take_preserves_derivation)
      apply(force)
     apply(rename_tac d s e qf s' x e2 c2 xb a)(*strict*)
     apply(rule_tac epdaS.derivation_take_preserves_belongs)
     apply(force)
    apply(rename_tac d s e qf s' x e2 c2 xb a)(*strict*)
    apply(simp add: derivation_take_def)
   apply(rename_tac d s e qf s' x e2 c2 xb a)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d s e qf s' x e2 c2 xb a)(*strict*)
    apply(simp add: derivation_drop_def derivation_take_def)
   apply(rename_tac d s e qf s' x e2 c2 xb a)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d s e qf s' x e2 c2 xb a)(*strict*)
    apply(clarsimp)
    apply(rename_tac d s e qf s' x e2 c2 xb a k ea c)(*strict*)
    apply(simp add: derivation_drop_def derivation_take_def)
    apply(case_tac k)
     apply(rename_tac d s e qf s' x e2 c2 xb a k ea c)(*strict*)
     apply(clarsimp)
    apply(rename_tac d s e qf s' x e2 c2 xb a k ea c nat)(*strict*)
    apply(clarsimp)
    apply(rename_tac d s e qf s' x e2 c2 xb a ea c nat)(*strict*)
    apply(erule_tac
      x="Suc (Suc nat)"
      in allE)
    apply(clarsimp)
   apply(rename_tac d s e qf s' x e2 c2 xb a)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d s e qf s' x e2 c2 xb a)(*strict*)
    apply(simp add: derivation_drop_def derivation_take_def)
    apply(clarsimp)
   apply(rename_tac d s e qf s' x e2 c2 xb a)(*strict*)
   apply(case_tac e2)
   apply(rename_tac d s e qf s' x e2 c2 xb a edge_srca edge_eventa edge_popa edge_pusha edge_trga)(*strict*)
   apply(clarsimp)
   apply(rename_tac d s e qf s' x c2 xb a edge_src)(*strict*)
   apply(rename_tac src)
   apply(rename_tac d s e qf s' x c2 xb a src)(*strict*)
   apply(rule cfgRM_produce_and_eliminate_from_Cons)
       apply(rename_tac d s e qf s' x c2 xb a src)(*strict*)
       apply(force)
      apply(rename_tac d s e qf s' x c2 xb a src)(*strict*)
      apply(force)
     apply(rename_tac d s e qf s' x c2 xb a src)(*strict*)
     apply(force)
    apply(rename_tac d s e qf s' x c2 xb a src)(*strict*)
    apply(force)
   apply(rename_tac d s e qf s' x c2 xb a src)(*strict*)
   apply(force)
    (*push edge*)
  apply(rename_tac d qi xa A s e qf s' x e2 c2 xb a list)(*strict*)
  apply(subgoal_tac "\<exists>A. edge_push e2=[A,xb]")
   apply(rename_tac d qi xa A s e qf s' x e2 c2 xb a list)(*strict*)
   prefer 2
   apply(simp add: valid_simple_dpda_def)
   apply(clarsimp)
   apply(erule_tac
      x="e2"
      in ballE)
    apply(rename_tac d qi xa A s e qf s' x e2 c2 xb a list)(*strict*)
    prefer 2
    apply(simp add: epdaS_step_relation_def)
   apply(rename_tac d qi xa A s e qf s' x e2 c2 xb a list)(*strict*)
   apply(clarsimp)
  apply(rename_tac d qi xa A s e qf s' x e2 c2 xb a list)(*strict*)
  apply(clarsimp)
  apply(rename_tac d qi xa A s e qf s' x e2 c2 xb a)(*strict*)
  apply(simp add: epdaS_step_relation_def)
  apply(clarsimp)
  apply(rename_tac d s e qf s' x e2 c2 xb a)(*strict*)
  apply(rename_tac A B)
  apply(rename_tac d s e qf s' x e2 c2 A B)(*strict*)
  apply(case_tac e2)
  apply(rename_tac d s e qf s' x e2 c2 A B edge_srca edge_eventa edge_popa edge_pusha edge_trga)(*strict*)
  apply(clarsimp)
  apply(rename_tac d s e qf s' x c2 A B edge_src)(*strict*)
  apply(rename_tac src)
  apply(rename_tac d s e qf s' x c2 A B src)(*strict*)
  apply(simp add: option_to_list_def)
  apply(case_tac c2)
  apply(rename_tac d s e qf s' x c2 A B src epdaS_conf_statea epdaS_conf_schedulera epdaS_conf_stacka)(*strict*)
  apply(clarsimp)
  apply(rename_tac d s e qf s' x A B src epdaS_conf_state epdaS_conf_scheduler)(*strict*)
  apply(rename_tac q w)
  apply(rename_tac d s e qf s' x A B src q w)(*strict*)
  apply(case_tac "\<forall>i \<le> x. \<forall>e c. d (Suc i) = Some (pair e c) \<longrightarrow> (\<exists>w. epdaS_conf_stack c = w @ B # A # s)")
   apply(rename_tac d s e qf s' x A B src q w)(*strict*)
   apply(erule_tac
      x="x"
      in meta_allE)
   apply(erule_tac
      x="derivation_drop (derivation_take d (Suc x)) (Suc 0)"
      in meta_allE)
   apply(erule_tac
      x="q"
      in meta_allE)
   apply(erule_tac
      x="w"
      in meta_allE)
   apply(erule_tac
      x="B"
      in meta_allE)
   apply(erule_tac
      x="A # s"
      in meta_allE)
   apply(erule_tac
      x="if x=0 then None else e"
      in meta_allE)
   apply(erule_tac
      x="qf"
      in meta_allE)
   apply(subgoal_tac "\<exists>w. epdaS_conf_stack \<lparr>epdaS_conf_state = qf, epdaS_conf_scheduler = [], epdaS_conf_stack = s' @ A # s\<rparr> = w @ B # A # s")
    apply(rename_tac d s e qf s' x A B src q w)(*strict*)
    prefer 2
    apply(erule_tac
      x="x"
      and P="\<lambda>X. X \<le> x \<longrightarrow> (\<forall>e c. d (Suc X) = Some (pair e c) \<longrightarrow> (\<exists>w. epdaS_conf_stack c = w @ B # A # s))"
      in allE)
    apply(rename_tac d s e qf s' x A B src q w)(*strict*)
    apply(clarsimp)
   apply(rename_tac d s e qf s' x A B src q w)(*strict*)
   apply(clarsimp)
   apply(rename_tac d s e qf x A B src q w wa)(*strict*)
   apply(erule_tac
      x="wa"
      in meta_allE)
   apply(erule meta_impE)
    apply(rename_tac d s e qf x A B src q w wa)(*strict*)
    apply(rule_tac
      m="x"
      in epdaS.derivation_drop_preserves_derivation)
     apply(rename_tac d s e qf x A B src q w wa)(*strict*)
     apply(rule epdaS.derivation_take_preserves_derivation)
     apply(force)
    apply(rename_tac d s e qf x A B src q w wa)(*strict*)
    apply(rule_tac
      t="Suc 0+x"
      and s="Suc x"
      in ssubst)
     apply(rename_tac d s e qf x A B src q w wa)(*strict*)
     apply(force)
    apply(rename_tac d s e qf x A B src q w wa)(*strict*)
    apply(rule maximum_of_domain_derivation_take)
    apply(force)
   apply(rename_tac d s e qf x A B src q w wa)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d s e qf x A B src q w wa)(*strict*)
    apply(rule_tac epdaS.derivation_drop_preserves_belongs)
      apply(rename_tac d s e qf x A B src q w wa)(*strict*)
      apply(rule epdaS.derivation_take_preserves_derivation)
      apply(force)
     apply(rename_tac d s e qf x A B src q w wa)(*strict*)
     apply(rule_tac epdaS.derivation_take_preserves_belongs)
     apply(force)
    apply(rename_tac d s e qf x A B src q w wa)(*strict*)
    apply(simp add: derivation_take_def)
   apply(rename_tac d s e qf x A B src q w wa)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d s e qf x A B src q w wa)(*strict*)
    apply(simp add: derivation_drop_def derivation_take_def)
   apply(rename_tac d s e qf x A B src q w wa)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d s e qf x A B src q w wa)(*strict*)
    apply(clarsimp)
    apply(rename_tac d s e qf x A B src q w wa k ea c)(*strict*)
    apply(simp add: derivation_drop_def derivation_take_def)
    apply(case_tac k)
     apply(rename_tac d s e qf x A B src q w wa k ea c)(*strict*)
     apply(clarsimp)
    apply(rename_tac d s e qf x A B src q w wa k ea c nat)(*strict*)
    apply(clarsimp)
   apply(rename_tac d s e qf x A B src q w wa)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d s e qf x A B src q w wa)(*strict*)
    apply(simp add: derivation_drop_def derivation_take_def)
    apply(clarsimp)
   apply(rename_tac d s e qf x A B src q w wa)(*strict*)
   apply(rule cfgRM_produce_and_eliminate_from_Cons2)
      apply(rename_tac d s e qf x A B src q w wa)(*strict*)
      apply(force)
     apply(rename_tac d s e qf x A B src q w wa)(*strict*)
     apply(force)
    apply(rename_tac d s e qf x A B src q w wa)(*strict*)
    apply(force)
   apply(rename_tac d s e qf x A B src q w wa)(*strict*)
   apply(force)
  apply(rename_tac d s e qf s' x A B src q w)(*strict*)
  apply(clarsimp)
  apply(rename_tac d s e qf s' x A B src q w i ea c)(*strict*)
  apply(subgoal_tac "\<exists>k \<le> SSn. (\<forall>i<k. \<not> SSP i) \<and> SSP k" for SSn SSP)
   apply(rename_tac d s e qf s' x A B src q w i ea c)(*strict*)
   prefer 2
   apply(rule_tac
      n="i"
      and P="\<lambda>k. \<not>(\<exists>w. epdaS_conf_stack(the(get_configuration(d (Suc k))))=w@B # A # s)"
      in ex_least_nat_le_prime)
   apply(simp add: get_configuration_def)
  apply(rename_tac d s e qf s' x A B src q w i ea c)(*strict*)
  apply(clarsimp)
  apply(rename_tac d s e qf s' x A B src q w i ea c k)(*strict*)
  apply(case_tac k)
   apply(rename_tac d s e qf s' x A B src q w i ea c k)(*strict*)
   apply(clarsimp)
   apply(rename_tac d s e qf s' x A B src q w i ea c)(*strict*)
   apply(simp add: get_configuration_def)
  apply(rename_tac d s e qf s' x A B src q w i ea c k nat)(*strict*)
  apply(clarsimp)
  apply(rename_tac d s e qf s' x A B src q w i ea c nat)(*strict*)
  apply(subgoal_tac "Suc nat \<le> x")
   apply(rename_tac d s e qf s' x A B src q w i ea c nat)(*strict*)
   prefer 2
   apply(force)
  apply(rename_tac d s e qf s' x A B src q w i ea c nat)(*strict*)
  apply(thin_tac "i \<le> x")
  apply(thin_tac "d (Suc i) = Some (pair ea c)")
  apply(thin_tac "Suc nat \<le> i")
  apply(thin_tac "\<forall>w. epdaS_conf_stack c \<noteq> w @ B # A # s")
  apply(subgoal_tac "\<exists>e1 e2 c1 c2. d (Suc nat) = Some (pair e1 c1) \<and> d (Suc (Suc nat)) = Some (pair (Some e2) c2) \<and> epdaS_step_relation G c1 e2 c2")
   apply(rename_tac d s e qf s' x A B src q w i ea c nat)(*strict*)
   prefer 2
   apply(rule_tac
      m="Suc x"
      in epdaS.step_detail_before_some_position)
     apply(rename_tac d s e qf s' x A B src q w i ea c nat)(*strict*)
     apply(force)
    apply(rename_tac d s e qf s' x A B src q w i ea c nat)(*strict*)
    apply(force)
   apply(rename_tac d s e qf s' x A B src q w i ea c nat)(*strict*)
   apply(force)
  apply(rename_tac d s e qf s' x A B src q w i ea c nat)(*strict*)
  apply(clarsimp)
  apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2)(*strict*)
  apply(simp add: get_configuration_def)
  apply(simp add: epdaS_step_relation_def)
  apply(subgoal_tac "\<exists>x. edge_pop e2=[x]")
   apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2)(*strict*)
   prefer 2
   apply(rule_tac
      G="G"
      in valid_pda_edge_pop_single)
    apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2)(*strict*)
    apply(simp add: valid_simple_dpda_def valid_dpda_def)
   apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2)(*strict*)
   apply(force)
  apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2)(*strict*)
  apply(clarsimp)
  apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2 xa wa)(*strict*)
  apply(subgoal_tac "\<exists>w. epdaS_conf_stack (the (case d (Suc nat) of None \<Rightarrow> None | Some (pair e c) \<Rightarrow> Some c)) = w @ B # A # s")
   apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2 xa wa)(*strict*)
   prefer 2
   apply(erule_tac
      x="nat"
      and P="\<lambda>x. x < Suc nat \<longrightarrow> (\<exists>w. epdaS_conf_stack (the (case d (Suc x) of None \<Rightarrow> None | Some (pair e c) \<Rightarrow> Some c)) = w @ B # A # s)"
      in allE)
   apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2 xa wa)(*strict*)
   apply(clarsimp)
  apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2 xa wa)(*strict*)
  apply(case_tac "edge_push e2")
   apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2 xa wa)(*strict*)
   prefer 2
   apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2 xa wa a list)(*strict*)
   apply(simp add: valid_simple_dpda_def)
   apply(clarsimp)
   apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2 xa wa a list wb)(*strict*)
   apply(erule_tac
      x="e2"
      in ballE)
    apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2 xa wa a list wb)(*strict*)
    prefer 2
    apply(force)
   apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2 xa wa a list wb)(*strict*)
   apply(case_tac "edge_event e2")
    apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2 xa wa a list wb)(*strict*)
    apply(clarsimp)
   apply(force)
  apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2 xa wa)(*strict*)
  apply(clarsimp)
  apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2 xa wb)(*strict*)
  apply(case_tac wb)
   apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2 xa wb)(*strict*)
   prefer 2
   apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2 xa wb a list)(*strict*)
   apply(clarsimp)
  apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2 xa wb)(*strict*)
  apply(clarsimp)
  apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2)(*strict*)
  apply(case_tac c2)
  apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 c2 epdaS_conf_statea epdaS_conf_schedulera epdaS_conf_stacka)(*strict*)
  apply(clarsimp)
  apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 epdaS_conf_schedulera)(*strict*)
  apply(rename_tac w')
  apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 w')(*strict*)
  apply(subgoal_tac "\<exists>wX. epdaS_string_state \<lparr>epdaS_conf_state = q, epdaS_conf_scheduler = w, epdaS_conf_stack = B # A # s\<rparr> = wX @ epdaS_string_state \<lparr>epdaS_conf_state = edge_trg e2, epdaS_conf_scheduler = w', epdaS_conf_stack = A # s\<rparr>")
   apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 w')(*strict*)
   prefer 2
   apply(rule_tac
      j="Suc nat"
      and P="G"
      in epdaS.derivation_monotonically_dec)
        apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 w')(*strict*)
        apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def)
       apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 w')(*strict*)
       apply(force)
      apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 w')(*strict*)
      apply(force)
     apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 w')(*strict*)
     apply(force)
    apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 w')(*strict*)
    apply(force)
   apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 w')(*strict*)
   apply(force)
  apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 w')(*strict*)
  apply(clarsimp)
  apply(rename_tac d s e qf s' x A B src q w nat e1 e2 c1 w' wX)(*strict*)
  apply(simp add: epdaS_string_state_def)
  apply(clarsimp)
  apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w' wX)(*strict*)
  apply(rename_tac w2 w1)
  apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
  apply(subgoal_tac "w1 \<in> cfgRM_produce_and_eliminate_from (F_SDPDA_TO_CFG_STD G) (cons_l3 q B (edge_trg e2))")
   apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
   apply(subgoal_tac "w2 \<in> cfgRM_produce_and_eliminate_from (F_SDPDA_TO_CFG_STD G) (cons_l2   (edge_trg e2) A)")
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
    apply(thin_tac "\<And>y d qi xa A s e qf s'. y < Suc x \<Longrightarrow> qf \<in> epda_marking G \<Longrightarrow> epdaS.derivation G d \<Longrightarrow> epdaS.belongs G d \<Longrightarrow> d 0 = Some (pair None \<lparr>epdaS_conf_state = qi, epdaS_conf_scheduler = xa, epdaS_conf_stack = A # s\<rparr>) \<Longrightarrow> \<forall>k \<le> y. \<forall>e c. d k = Some (pair e c) \<longrightarrow> (\<exists>w. epdaS_conf_stack c = w @ A # s) \<Longrightarrow> d y = Some (pair e \<lparr>epdaS_conf_state = qf, epdaS_conf_scheduler = [], epdaS_conf_stack = s' @ A # s\<rparr>) \<Longrightarrow> xa \<in> cfgRM_produce_and_eliminate_from (F_SDPDA_TO_CFG_STD G) (cons_l2   qi A)")
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
    apply(rule cfgRM_produce_and_eliminate_from_concatenate)
       apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
       apply(rule F_SDPDA_TO_CFG_STD__makes_CFG)
       apply(force)
      apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
      apply(force)
     apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
     apply(force)
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
    apply(simp add: F_SDPDA_TO_CFG_STD_def)
    apply(rule disjI2)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_def)
    apply(rule disjI2)
    apply(rule disjI2)
    apply(rule_tac
      x="\<lparr>edge_src = src, edge_event = None, edge_pop = [A], edge_push = [B, A], edge_trg = q\<rparr>"
      in bexI)
     apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
     apply(clarsimp)
     apply(simp only: F_SDPDA_TO_CFG_STD__edges_l2_push_def)
     apply(rule UnI2)
     apply(clarsimp)
     apply(subgoal_tac "valid_epda_step_label G e2")
      apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
      apply(simp add: valid_epda_step_label_def)
     apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
     apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
    apply(force)
   apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
   apply(thin_tac "w1 \<in> cfgRM_produce_and_eliminate_from (F_SDPDA_TO_CFG_STD G) (cons_l3 q B (edge_trg e2))")
   apply(erule_tac
      x="x-Suc nat"
      in meta_allE)
   apply(erule_tac
      x="derivation_drop d (Suc (Suc nat))"
      in meta_allE)
   apply(erule_tac
      x="edge_trg e2"
      in meta_allE)
   apply(erule_tac
      x="w2"
      in meta_allE)
   apply(erule_tac
      x="A"
      in meta_allE)
   apply(erule_tac
      x="s"
      in meta_allE)
   apply(erule_tac
      x="if x=Suc nat then None else e"
      in meta_allE)
   apply(erule_tac
      x="qf"
      in meta_allE)
   apply(erule_tac
      x="s'"
      in meta_allE)
   apply(clarsimp)
   apply(erule meta_impE)
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
    apply(force)
   apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
    apply(rule_tac
      m="0"
      in epdaS.derivation_drop_preserves_derivation_prime)
     apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
     apply(force)
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
    apply(force)
   apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
    apply(rule epdaS.derivation_drop_preserves_belongs)
      apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
      apply(force)
     apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
     apply(force)
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
    apply(force)
   apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
    apply(simp add: derivation_drop_def)
   apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
    apply(clarsimp)
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 k ea c)(*strict*)
    apply(simp add: derivation_drop_def)
    apply(case_tac k)
     apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 k ea c)(*strict*)
     apply(clarsimp)
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 k ea c nata)(*strict*)
    apply(clarsimp)
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 ea c nata)(*strict*)
    apply(erule_tac
      x="(Suc (Suc (Suc (nata + nat))))"
      and P="\<lambda>y. y \<le> Suc x \<longrightarrow> (\<forall>e c. d y = Some (pair e c) \<longrightarrow> (\<exists>w. epdaS_conf_stack c = w @ A # s))"
      in allE)
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 ea c nata)(*strict*)
    apply(clarsimp)
   apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
    apply(simp add: derivation_drop_def)
    apply(clarsimp)
   apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
   apply(force)
  apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
  apply(thin_tac "\<And>y d qi xa A s e qf s'. y < Suc x \<Longrightarrow> qf \<in> epda_marking G \<Longrightarrow> epdaS.derivation G d \<Longrightarrow> epdaS.belongs G d \<Longrightarrow> d 0 = Some (pair None \<lparr>epdaS_conf_state = qi, epdaS_conf_scheduler = xa, epdaS_conf_stack = A # s\<rparr>) \<Longrightarrow> \<forall>k \<le> y. \<forall>e c. d k = Some (pair e c) \<longrightarrow> (\<exists>w. epdaS_conf_stack c = w @ A # s) \<Longrightarrow> d y = Some (pair e \<lparr>epdaS_conf_state = qf, epdaS_conf_scheduler = [], epdaS_conf_stack = s' @ A # s\<rparr>) \<Longrightarrow> xa \<in> cfgRM_produce_and_eliminate_from (F_SDPDA_TO_CFG_STD G) (cons_l2   qi A)")
  apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
  apply(subgoal_tac "edge_event e2=None")
   apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
   prefer 2
   apply(simp add: valid_simple_dpda_def)
   apply(clarsimp)
   apply(erule_tac
      x="e2"
      in ballE)
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
    prefer 2
    apply(force)
   apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
   apply(case_tac "edge_event e2")
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
    apply(force)
   apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 a)(*strict*)
   apply(force)
  apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
  apply(subgoal_tac "epdaS.derivation G (derivation_map (derivation_drop (derivation_take d (Suc (Suc nat))) (Suc 0)) (\<lambda>c. c\<lparr>epdaS_conf_scheduler := take (length (epdaS_conf_scheduler c) - length (epdaS_conf_scheduler \<lparr>epdaS_conf_state = edge_trg e2, epdaS_conf_scheduler = w2, epdaS_conf_stack = A # s\<rparr>)) (epdaS_conf_scheduler c) @ []\<rparr>))")
   apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
   prefer 2
   apply(rule_tac
      n="Suc nat"
      in epda_maximal_context_preserves_derivation_prime)
         apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
         apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def)
        apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
        apply(simp add: derivation_drop_def derivation_take_def)
       apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
       apply(rule epdaS.derivation_drop_preserves_belongs)
         apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
         apply(rule epdaS.derivation_take_preserves_derivation)
         apply(force)
        apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
        apply(rule epdaS.derivation_take_preserves_belongs)
        apply(force)
       apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
       apply(simp add: derivation_take_def)
      apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
      apply(rule_tac
      m="Suc nat"
      in epdaS.derivation_drop_preserves_derivation)
       apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
       apply(rule epdaS.derivation_take_preserves_derivation)
       apply(force)
      apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
      apply(rule_tac
      t="Suc 0 + Suc nat"
      and s="Suc (Suc nat)"
      in ssubst)
       apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
       apply(force)
      apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
      apply(rule maximum_of_domain_derivation_take)
      apply(force)
     apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
     apply(rule_tac
      P="\<lambda>X. maximum_of_domain (derivation_drop (derivation_take d (Suc (Suc nat))) (Suc 0)) X"
      and s="Suc (Suc nat) - Suc 0"
      in ssubst)
      apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
      apply(force)
     apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
     apply(rule epdaS.derivation_drop_makes_maximum_of_domain)
       apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
       apply(rule epdaS.derivation_take_preserves_derivation)
       apply(force)
      apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
      apply(rule maximum_of_domain_derivation_take)
      apply(force)
     apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
     apply(force)
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
    apply(simp add: derivation_take_def derivation_drop_def)
   apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
   apply(force)
  apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
  apply(rule_tac
      j="nat"
      and q="if nat=0 then q else epdaS_conf_state c1"
      and e="if nat=0 then None else e1"
      and d="derivation_map (derivation_drop (derivation_take d (Suc (Suc nat))) (Suc 0)) (\<lambda>c. c\<lparr>epdaS_conf_scheduler := take (length (epdaS_conf_scheduler c) - length (epdaS_conf_scheduler \<lparr>epdaS_conf_state = edge_trg e2, epdaS_conf_scheduler = w2, epdaS_conf_stack = A # s\<rparr>)) (epdaS_conf_scheduler c) @ []\<rparr>)"
      in F_SDPDA_TO_CFG_STD__40_imp_41_hlp)
           apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
           apply(force)
          apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
          apply(rule F_SDPDA_TO_CFG_STD__makes_CFG)
          apply(force)
         apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
         apply(simp add: F_SDPDA_TO_CFG_STD_def)
        apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
        apply(clarsimp)
        apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 p)(*strict*)
        apply(simp add: F_SDPDA_TO_CFG_STD_def F_SDPDA_TO_CFG_STD__edges_l2_def)
        apply(erule disjE)
         apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 p)(*strict*)
         apply(clarsimp)
         apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 p xa)(*strict*)
         apply(case_tac "edge_event xa")
          apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 p xa)(*strict*)
          apply(clarsimp)
         apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 p xa a)(*strict*)
         apply(clarsimp)
         apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_read_def)
        apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 p)(*strict*)
        apply(erule disjE)
         apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 p)(*strict*)
         apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_final_def)
         apply(clarsimp)
        apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 p)(*strict*)
        apply(clarsimp)
        apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 p xa)(*strict*)
        apply(case_tac "edge_push xa")
         apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 p xa)(*strict*)
         prefer 2
         apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 p xa a list)(*strict*)
         apply(clarsimp)
         apply(case_tac "edge_event xa")
          apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 p xa a list)(*strict*)
          prefer 2
          apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 p xa a list aa)(*strict*)
          apply(clarsimp)
         apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 p xa a list)(*strict*)
         apply(clarsimp)
         apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_push_def)
         apply(erule disjE)
          apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 p xa a list)(*strict*)
          apply(clarsimp)
         apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 p xa a list)(*strict*)
         apply(clarsimp)
        apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 p xa)(*strict*)
        apply(clarsimp)
       apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
       apply(force)
      apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
      apply(rule epdaS.derivation_belongs)
         apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
         apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def)
        apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
        apply(simp add: derivation_drop_def derivation_take_def derivation_map_def)
       apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
       prefer 2
       apply(force)
      apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
      apply(subgoal_tac "\<lparr>epdaS_conf_state = q, epdaS_conf_scheduler = w1 @ w2, epdaS_conf_stack = B # A # s\<rparr> \<in> epdaS_configurations G")
       apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
       apply(simp add: epdaS_configurations_def)
      apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
      apply(rule epdaS.belongs_configurations)
       apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
       apply(force)
      apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
      apply(force)
     apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
     apply(simp add: derivation_map_def derivation_drop_def derivation_take_def)
    apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
    apply(simp add: derivation_map_def derivation_drop_def derivation_take_def option_to_list_def)
    apply(clarsimp)
    apply(rename_tac d s e qf s' x A B src q e2 c1 w1)(*strict*)
    apply(case_tac c1)
    apply(rename_tac d s e qf s' x A B src q e2 c1 w1 epdaS_conf_statea epdaS_conf_schedulera epdaS_conf_stacka)(*strict*)
    apply(clarsimp)
   apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
   prefer 2
   apply(simp add: derivation_map_def derivation_drop_def derivation_take_def option_to_list_def)
  apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1)(*strict*)
  apply(clarsimp)
  apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 k ea c)(*strict*)
  apply(simp add: derivation_map_def derivation_drop_def derivation_take_def option_to_list_def)
  apply(case_tac k)
   apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 k ea c)(*strict*)
   apply(clarsimp)
  apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w2 w1 k ea c nata)(*strict*)
  apply(clarsimp)
  apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w1 ea c nata)(*strict*)
  apply(case_tac "d(Suc (Suc nata))")
   apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w1 ea c nata)(*strict*)
   apply(clarsimp)
  apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w1 ea c nata a)(*strict*)
  apply(clarsimp)
  apply(case_tac a)
  apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w1 ea c nata a option b)(*strict*)
  apply(clarsimp)
  apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w1 ea nata b)(*strict*)
  apply(erule_tac
      x="Suc nata"
      and P="\<lambda>x. x < Suc nat \<longrightarrow> (\<exists>w. epdaS_conf_stack (the (case_option None (case_derivation_configuration (\<lambda>e. Some)) (d (Suc x)))) = w @ B # A # s)"
      in allE)
  apply(rename_tac d s e qf s' x A B src q nat e1 e2 c1 w1 ea nata b)(*strict*)
  apply(clarsimp)
  done

lemma F_SDPDA_TO_CFG_STD__42_imp_43: "
  valid_simple_dpda G
  \<Longrightarrow> GP = F_SDPDA_TO_CFG_STD G
  \<Longrightarrow> epdaS_produce_and_eliminate_from G qi A \<subseteq> cfgRM_produce_and_eliminate_from GP (cons_l2   qi A)"
  apply(simp add: epdaS_produce_and_eliminate_from_def)
  apply(clarsimp)
  apply(rename_tac x d qf s j e s')(*strict*)
  apply(rule F_SDPDA_TO_CFG_STD__42_imp_43_hlp)
         apply(rename_tac x d qf s j e s')(*strict*)
         apply(force)
        apply(rename_tac x d qf s j e s')(*strict*)
        apply(force)
       apply(rename_tac x d qf s j e s')(*strict*)
       apply(force)
      apply(rename_tac x d qf s j e s')(*strict*)
      apply(force)
     apply(rename_tac x d qf s j e s')(*strict*)
     apply(force)
    apply(rename_tac x d qf s j e s')(*strict*)
    apply(force)
   apply(rename_tac x d qf s j e s')(*strict*)
   prefer 2
   apply(force)
  apply(rename_tac x d qf s j e s')(*strict*)
  apply(force)
  done

lemma F_SDPDA_TO_CFG_STD__41_imp_40_hlp: "
  valid_simple_dpda G
  \<Longrightarrow> valid_cfg GP
  \<Longrightarrow> F_SDPDA_TO_CFG_STD__edges_l3 G \<subseteq> cfg_productions GP
  \<Longrightarrow> cfg_productions GP = F_SDPDA_TO_CFG_STD__edges_l3 G \<union> F_SDPDA_TO_CFG_STD__edges_l2 G
  \<Longrightarrow> cfgRM.derivation GP d
  \<Longrightarrow> cfgSTD.belongs GP d
  \<Longrightarrow> d 0 = Some (pair None \<lparr>cfg_conf = [teA (cons_l3   qi A qt)]\<rparr>)
  \<Longrightarrow> d i = Some (pair e \<lparr>cfg_conf = liftB x\<rparr>)
  \<Longrightarrow> x \<in> epdaS_produce_from_before_pop G qi A qt"
  apply(induct i arbitrary: d e x qi A qt rule: less_induct)
  apply(rename_tac x d e xa qi A qt)(*strict*)
  apply(clarsimp)
  apply(case_tac x)
   apply(rename_tac x d e xa qi A qt)(*strict*)
   apply(clarsimp)
   apply(rename_tac d xa qi A qt)(*strict*)
   apply(case_tac xa)
    apply(rename_tac d xa qi A qt)(*strict*)
    apply(force)
   apply(rename_tac d xa qi A qt a list)(*strict*)
   apply(clarsimp)
  apply(rename_tac x d e xa qi A qt nat)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e xa qi A qt nat)(*strict*)
  apply(rename_tac x)
  apply(rename_tac d e xa qi A qt x)(*strict*)
  apply(subgoal_tac "\<exists>e1 e2 c1 c2. d 0 = Some (pair e1 c1) \<and> d (Suc 0) = Some (pair (Some e2) c2) \<and> cfgRM_step_relation GP c1 e2 c2")
   apply(rename_tac d e xa qi A qt x)(*strict*)
   prefer 2
   apply(rule_tac
      m="Suc x"
      in cfgRM.step_detail_before_some_position)
     apply(rename_tac d e xa qi A qt x)(*strict*)
     apply(force)
    apply(rename_tac d e xa qi A qt x)(*strict*)
    apply(force)
   apply(rename_tac d e xa qi A qt x)(*strict*)
   apply(force)
  apply(rename_tac d e xa qi A qt x)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e xa qi A qt x e2 c2)(*strict*)
  apply(simp add: cfgRM_step_relation_def)
  apply(clarsimp)
  apply(rename_tac d e xa qi A qt x e2 c2 l r)(*strict*)
  apply(case_tac l)
   apply(rename_tac d e xa qi A qt x e2 c2 l r)(*strict*)
   prefer 2
   apply(rename_tac d e xa qi A qt x e2 c2 l r a list)(*strict*)
   apply(force)
  apply(rename_tac d e xa qi A qt x e2 c2 l r)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e xa qi A qt x e2 c2)(*strict*)
  apply(erule disjE)
   apply(rename_tac d e xa qi A qt x e2 c2)(*strict*)
   prefer 2
   apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_def)
   apply(erule disjE)
    apply(rename_tac d e xa qi A qt x e2 c2)(*strict*)
    apply(clarsimp)
    apply(rename_tac d e xa qi A qt x e2 c2 xb)(*strict*)
    apply(case_tac "edge_event xb")
     apply(rename_tac d e xa qi A qt x e2 c2 xb)(*strict*)
     apply(clarsimp)
    apply(rename_tac d e xa qi A qt x e2 c2 xb a)(*strict*)
    apply(clarsimp)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_read_def)
   apply(rename_tac d e xa qi A qt x e2 c2)(*strict*)
   apply(erule disjE)
    apply(rename_tac d e xa qi A qt x e2 c2)(*strict*)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_final_def)
    apply(clarsimp)
   apply(rename_tac d e xa qi A qt x e2 c2)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa qi A qt x e2 c2 xb)(*strict*)
   apply(case_tac "edge_push xb")
    apply(rename_tac d e xa qi A qt x e2 c2 xb)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa qi A qt x e2 c2 xb a list)(*strict*)
   apply(clarsimp)
   apply(case_tac "edge_event xb")
    apply(rename_tac d e xa qi A qt x e2 c2 xb a list)(*strict*)
    prefer 2
    apply(rename_tac d e xa qi A qt x e2 c2 xb a list aa)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa qi A qt x e2 c2 xb a list)(*strict*)
   apply(clarsimp)
   apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_push_def)
   apply(erule disjE)
    apply(rename_tac d e xa qi A qt x e2 c2 xb a list)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa qi A qt x e2 c2 xb a list)(*strict*)
   apply(clarsimp)
  apply(rename_tac d e xa qi A qt x e2 c2)(*strict*)
  apply(subgoal_tac "(\<exists>x \<in> epda_delta G. e2 \<in> (case edge_event x of None \<Rightarrow> {} | Some A \<Rightarrow> F_SDPDA_TO_CFG_STD__edges_l3_read x (epda_states G))) \<or> (\<exists>x \<in> epda_delta G. e2 \<in> (case edge_push x of [] \<Rightarrow> F_SDPDA_TO_CFG_STD__edges_l3_pop x | a # y \<Rightarrow> {})) \<or> (\<exists>x \<in> epda_delta G. e2 \<in> (case edge_push x of [] \<Rightarrow> {} | a # y \<Rightarrow> (case edge_event x of None \<Rightarrow> F_SDPDA_TO_CFG_STD__edges_l3_push x (epda_states G) | Some A \<Rightarrow> {})))")
   apply(rename_tac d e xa qi A qt x e2 c2)(*strict*)
   prefer 2
   apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_def)
  apply(rename_tac d e xa qi A qt x e2 c2)(*strict*)
  apply(thin_tac "e2 \<in> F_SDPDA_TO_CFG_STD__edges_l3 G")
  apply(case_tac c2)
  apply(rename_tac d e xa qi A qt x e2 c2 cfg_confa)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e xa qi A qt x e2)(*strict*)
  apply(erule disjE)
   apply(rename_tac d e xa qi A qt x e2)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa qi A qt x e2 xb)(*strict*)
   apply(case_tac "edge_event xb")
    apply(rename_tac d e xa qi A qt x e2 xb)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa qi A qt x e2 xb a)(*strict*)
   apply(clarsimp)
   apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_read_def)
   apply(clarsimp)
   apply(rename_tac d e xa x xb a qta)(*strict*)
   apply(simp add: valid_simple_dpda_def)
   apply(clarsimp)
   apply(erule_tac
      x="xb"
      in ballE)
    apply(rename_tac d e xa x xb a qta)(*strict*)
    prefer 2
    apply(force)
   apply(rename_tac d e xa x xb a qta)(*strict*)
   apply(clarsimp)
   apply(subgoal_tac "\<exists>x. edge_pop xb = [x]")
    apply(rename_tac d e xa x xb a qta)(*strict*)
    prefer 2
    apply(rule valid_pda_edge_pop_single)
     apply(rename_tac d e xa x xb a qta)(*strict*)
     apply(simp add: valid_simple_dpda_def valid_dpda_def)
     apply(force)
    apply(rename_tac d e xa x xb a qta)(*strict*)
    apply(force)
   apply(rename_tac d e xa x xb a qta)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa x xb a qta xc)(*strict*)
   apply(subgoal_tac "\<forall>k \<le> x. (\<forall>e c. (derivation_drop d (Suc 0)) k = Some (pair e c) \<longrightarrow> (\<exists>w. cfg_conf c=liftB [a]@w))")
    apply(rename_tac d e xa x xb a qta xc)(*strict*)
    apply(subgoal_tac "\<exists>w. liftB xa = teB a # w")
     apply(rename_tac d e xa x xb a qta xc)(*strict*)
     prefer 2
     apply(subgoal_tac "(\<forall>e c. (derivation_drop d (Suc 0)) x = Some (pair e c) \<longrightarrow> (\<exists>w. cfg_conf c=liftB [a]@w))")
      apply(rename_tac d e xa x xb a qta xc)(*strict*)
      apply(clarsimp)
      apply(simp add: derivation_drop_def)
      apply(case_tac x)
       apply(rename_tac d e xa x xb a qta xc)(*strict*)
       apply(clarsimp)
       apply(rename_tac d xa xb a qta xc)(*strict*)
       apply(case_tac xa)
        apply(rename_tac d xa xb a qta xc)(*strict*)
        apply(clarsimp)
       apply(rename_tac d xa xb a qta xc aa list)(*strict*)
       apply(clarsimp)
      apply(rename_tac d e xa x xb a qta xc nat)(*strict*)
      apply(clarsimp)
      apply(rename_tac d e xa xb a qta xc nat w)(*strict*)
      apply(force)
     apply(rename_tac d e xa x xb a qta xc)(*strict*)
     apply(erule_tac
      x="x"
      in allE)
     apply(force)
    apply(rename_tac d e xa x xb a qta xc)(*strict*)
    apply(clarsimp)
    apply(rename_tac d e xa x xb a qta xc w)(*strict*)
    apply(case_tac xa)
     apply(rename_tac d e xa x xb a qta xc w)(*strict*)
     apply(clarsimp)
    apply(rename_tac d e xa x xb a qta xc w aa list)(*strict*)
    apply(clarsimp)
    apply(rename_tac d e x xb a qta xc list)(*strict*)
    apply(rename_tac w)
    apply(rename_tac d e x xb a qta xc w)(*strict*)
    apply(erule_tac
      x="x"
      in meta_allE)
    apply(clarsimp)
    apply(erule_tac
      x="derivation_map (derivation_drop (derivation_take d (Suc x)) (Suc 0)) (\<lambda>c. \<lparr>cfg_conf=drop(length [a])(cfg_conf c)\<rparr>)"
      in meta_allE)
    apply(erule_tac
      x="e"
      in meta_allE)
    apply(erule_tac
      x="w"
      in meta_allE)
    apply(erule_tac
      x="edge_trg xb"
      in meta_allE)
    apply(erule_tac
      x="xc"
      in meta_allE)
    apply(erule_tac
      x="qta"
      in meta_allE)
    apply(subgoal_tac "cfgRM.derivation GP (derivation_map (derivation_drop (derivation_take d (Suc x)) (Suc 0)) (\<lambda>c. \<lparr>cfg_conf = drop (length [a]) (cfg_conf c)\<rparr>))")
     apply(rename_tac d e x xb a qta xc w)(*strict*)
     prefer 2
     apply(rule_tac
      m="x"
      in CFGRM_drop_head_terminals_preserves_derivation)
        apply(rename_tac d e x xb a qta xc w)(*strict*)
        apply(force)
       apply(rename_tac d e x xb a qta xc w)(*strict*)
       apply(rule cfgRM.derivation_drop_preserves_derivation_prime)
        apply(rename_tac d e x xb a qta xc w)(*strict*)
        apply(rule cfgRM.derivation_take_preserves_derivation)
        apply(force)
       apply(rename_tac d e x xb a qta xc w)(*strict*)
       apply(simp add: derivation_take_def)
       apply(force)
      apply(rename_tac d e x xb a qta xc w)(*strict*)
      apply(rule_tac
      t="x"
      and s="Suc x-Suc 0"
      in ssubst)
       apply(rename_tac d e x xb a qta xc w)(*strict*)
       apply(force)
      apply(rename_tac d e x xb a qta xc w)(*strict*)
      apply(rule_tac
      M="GP"
      in cfgRM.derivation_drop_makes_maximum_of_domain)
        apply(rename_tac d e x xb a qta xc w)(*strict*)
        apply(clarsimp)
        apply(rule cfgRM.derivation_take_preserves_derivation)
        apply(force)
       apply(rename_tac d e x xb a qta xc w)(*strict*)
       apply(clarsimp)
       apply(rule maximum_of_domain_derivation_take)
       apply(force)
      apply(rename_tac d e x xb a qta xc w)(*strict*)
      apply(force)
     apply(rename_tac d e x xb a qta xc w)(*strict*)
     apply(simp add: derivation_drop_def derivation_take_def)
    apply(rename_tac d e x xb a qta xc w)(*strict*)
    apply(erule meta_impE)
     apply(rename_tac d e x xb a qta xc w)(*strict*)
     apply(force)
    apply(rename_tac d e x xb a qta xc w)(*strict*)
    apply(erule meta_impE)
     apply(rename_tac d e x xb a qta xc w)(*strict*)
     apply(rule cfgRM.derivation_belongs)
        apply(rename_tac d e x xb a qta xc w)(*strict*)
        apply(force)
       apply(rename_tac d e x xb a qta xc w)(*strict*)
       apply(simp add: derivation_map_def derivation_drop_def derivation_take_def)
      apply(rename_tac d e x xb a qta xc w)(*strict*)
      apply(subgoal_tac "\<lparr>cfg_conf = [teB a, teA (cons_l3   (edge_trg xb) xc qta)]\<rparr> \<in> cfg_configurations GP")
       apply(rename_tac d e x xb a qta xc w)(*strict*)
       apply(simp add: cfg_configurations_def)
      apply(rename_tac d e x xb a qta xc w)(*strict*)
      apply(rule cfgRM.belongs_configurations)
       apply(rename_tac d e x xb a qta xc w)(*strict*)
       apply(force)
      apply(rename_tac d e x xb a qta xc w)(*strict*)
      apply(force)
     apply(rename_tac d e x xb a qta xc w)(*strict*)
     apply(force)
    apply(rename_tac d e x xb a qta xc w)(*strict*)
    apply(erule meta_impE)
     apply(rename_tac d e x xb a qta xc w)(*strict*)
     apply(simp add: derivation_map_def derivation_drop_def derivation_take_def)
    apply(rename_tac d e x xb a qta xc w)(*strict*)
    apply(erule meta_impE)
     apply(rename_tac d e x xb a qta xc w)(*strict*)
     apply(simp add: derivation_map_def derivation_drop_def derivation_take_def)
     apply(clarsimp)
     apply(rename_tac d xb a qta xc w)(*strict*)
     apply(case_tac w)
      apply(rename_tac d xb a qta xc w)(*strict*)
      apply(clarsimp)
     apply(rename_tac d xb a qta xc w aa list)(*strict*)
     apply(clarsimp)
    apply(rename_tac d e x xb a qta xc w)(*strict*)
    apply(case_tac xb)
    apply(rename_tac d e x xb a qta xc w edge_srca edge_eventa edge_popa edge_pusha edge_trga)(*strict*)
    apply(clarsimp)
    apply(rename_tac d e x a qta xc w edge_src edge_trg)(*strict*)
    apply(rename_tac src trg)
    apply(rename_tac d e x a qta xc w src trg)(*strict*)
    apply(rule epdaS_produce_from_before_popCons)
      apply(rename_tac d e x a qta xc w src trg)(*strict*)
      apply(simp add: valid_dpda_def valid_pda_def)
     apply(rename_tac d e x a qta xc w src trg)(*strict*)
     apply(force)
    apply(rename_tac d e x a qta xc w src trg)(*strict*)
    apply(force)
   apply(rename_tac d e xa x xb a qta xc)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa x xb a qta xc k ea c)(*strict*)
   apply(subgoal_tac "\<exists>e w. (derivation_take d (Suc x)) (Suc k) = Some (pair e \<lparr>cfg_conf = teB a # w\<rparr>)")
    apply(rename_tac d e xa x xb a qta xc k ea c)(*strict*)
    prefer 2
    apply(rule_tac
      m="Suc 0"
      and n="x"
      and G="GP"
      in terminal_at_beginning_are_never_modified)
        apply(rename_tac d e xa x xb a qta xc k ea c)(*strict*)
        apply(rule cfgRM_derivations_are_cfg_derivations)
        apply(rule cfgRM.derivation_take_preserves_derivation)
        apply(force)
       apply(rename_tac d e xa x xb a qta xc k ea c)(*strict*)
       apply(rule_tac
      t="Suc 0+x"
      and s="Suc x"
      in ssubst)
        apply(rename_tac d e xa x xb a qta xc k ea c)(*strict*)
        apply(force)
       apply(rename_tac d e xa x xb a qta xc k ea c)(*strict*)
       apply(rule maximum_of_domain_derivation_take)
       apply(force)
      apply(rename_tac d e xa x xb a qta xc k ea c)(*strict*)
      apply(simp add: derivation_take_def)
     apply(rename_tac d e xa x xb a qta xc k ea c)(*strict*)
     apply(force)
    apply(rename_tac d e xa x xb a qta xc k ea c)(*strict*)
    apply(force)
   apply(rename_tac d e xa x xb a qta xc k ea c)(*strict*)
   apply(simp add: derivation_take_def derivation_drop_def)
   apply(clarsimp)
   apply(rename_tac d e xa x xb a qta xc k ea c eb w)(*strict*)
   apply(case_tac k)
    apply(rename_tac d e xa x xb a qta xc k ea c eb w)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa x xb a qta xc k ea c eb w nat)(*strict*)
   apply(clarsimp)
    (*push*)
  apply(rename_tac d e xa qi A qt x e2)(*strict*)
  apply(erule disjE)
   apply(rename_tac d e xa qi A qt x e2)(*strict*)
   prefer 2
   apply(clarsimp)
   apply(rename_tac d e xa qi A qt x e2 xb)(*strict*)
   apply(case_tac "edge_push xb")
    apply(rename_tac d e xa qi A qt x e2 xb)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa qi A qt x e2 xb a list)(*strict*)
   apply(clarsimp)
   apply(case_tac "edge_event xb")
    apply(rename_tac d e xa qi A qt x e2 xb a list)(*strict*)
    apply(clarsimp)
    prefer 2
    apply(rename_tac d e xa qi A qt x e2 xb a list aa)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa qi A qt x e2 xb a list)(*strict*)
   apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_push_def)
   apply(clarsimp)
   apply(rename_tac d e xa x xb a list qs qta)(*strict*)
   apply(simp add: valid_simple_dpda_def)
   apply(clarsimp)
   apply(erule_tac
      x="xb"
      in ballE)
    apply(rename_tac d e xa x xb a list qs qta)(*strict*)
    prefer 2
    apply(force)
   apply(rename_tac d e xa x xb a list qs qta)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa x xb a qs qta)(*strict*)
   apply(subgoal_tac "\<exists>x. edge_pop xb = [x]")
    apply(rename_tac d e xa x xb a qs qta)(*strict*)
    prefer 2
    apply(rule valid_pda_edge_pop_single)
     apply(rename_tac d e xa x xb a qs qta)(*strict*)
     apply(simp add: valid_simple_dpda_def valid_dpda_def)
     apply(force)
    apply(rename_tac d e xa x xb a qs qta)(*strict*)
    apply(force)
   apply(rename_tac d e xa x xb a qs qta)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa x xb a qs qta xc)(*strict*)
   apply(case_tac xb)
   apply(rename_tac d e xa x xb a qs qta xc edge_srca edge_eventa edge_popa edge_pusha edge_trga)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa x a qs qta xc edge_src edge_trg)(*strict*)
   apply(rename_tac B qs qt A src trg)
   apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
   apply(subgoal_tac "\<exists>d1 d2 w1' w2' n1 n2. cfgRM.derivation_from_to GP d1 {pair None \<lparr>cfg_conf = [teA (cons_l3   trg B qs)]\<rparr>} {y. \<exists>xa. y = pair xa \<lparr>cfg_conf = w1'\<rparr>} \<and> cfgRM.derivation_from_to GP d2 {pair None \<lparr>cfg_conf = [teA (cons_l3   qs A qt)]\<rparr>} {y. \<exists>xa. y = pair xa \<lparr>cfg_conf = w2'\<rparr>} \<and> w1'@w2'=liftB xa \<and> maximum_of_domain d1 n1 \<and> maximum_of_domain d2 n2 \<and> n1+n2=x")
    apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
    prefer 2
    apply(rule_tac
      d="derivation_drop (derivation_take d (Suc x)) (Suc 0)"
      in CFGRM_derivationCanBeDecomposed2)
     apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
     apply(simp add: cfgRM.derivation_from_to_def cfgRM.derivation_from_def cfgRM.derivation_to_def)
     apply(rule context_conjI)
      apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
      apply(rule_tac
      m="x"
      in cfgRM.derivation_drop_preserves_derivation)
       apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
       apply(rule cfgRM.derivation_take_preserves_derivation)
       apply(force)
      apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
      apply(rule_tac
      t="Suc 0+x"
      and s="Suc x"
      in ssubst)
       apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
       apply(force)
      apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
      apply(rule maximum_of_domain_derivation_take)
      apply(force)
     apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
     apply(rule conjI)
      apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
      apply(simp add: derivation_drop_def derivation_take_def)
     apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
     apply(rule conjI)
      apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
      apply(force)
     apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
     apply(rule_tac
      x="x"
      in exI)
     apply(simp add: derivation_drop_def derivation_take_def)
     apply(clarsimp)
    apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
    apply(rule_tac
      t="x"
      and s="Suc x - Suc 0"
      in ssubst)
     apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
     apply(force)
    apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
    apply(rule cfgRM.derivation_drop_makes_maximum_of_domain)
      apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
      apply(rule_tac
      t="Suc (Suc x - Suc 0)"
      and s="Suc x"
      in ssubst)
       apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
       apply(force)
      apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
      apply(rule cfgRM.derivation_take_preserves_derivation)
      apply(force)
     apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
     apply(rule_tac
      t="Suc (Suc x - Suc 0)"
      and s="Suc x"
      in ssubst)
      apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
      apply(force)
     apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
     apply(rule maximum_of_domain_derivation_take)
     apply(force)
    apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
    apply(force)
   apply(rename_tac d e xa x B qs qt A src trg)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa B qs qt A src trg d1 d2 w1' w2' n1 n2)(*strict*)
   apply(subgoal_tac "\<exists>x1 x2. liftB x1 = w1' \<and> liftB x2 = w2'")
    apply(rename_tac d e xa B qs qt A src trg d1 d2 w1' w2' n1 n2)(*strict*)
    prefer 2
    apply(rule_tac
      x="take (length w1') xa"
      in exI)
    apply(rule_tac
      x="drop (length w1') xa"
      in exI)
    apply(rule context_conjI)
     apply(rename_tac d e xa B qs qt A src trg d1 d2 w1' w2' n1 n2)(*strict*)
     apply (metis take_liftB take_append_prime)
    apply(rename_tac d e xa B qs qt A src trg d1 d2 w1' w2' n1 n2)(*strict*)
    apply(rule_tac
      w="w1'"
      in append_linj)
    apply(rule_tac
      t="w1'@w2'"
      and s="liftB xa"
      in ssubst)
     apply(rename_tac d e xa B qs qt A src trg d1 d2 w1' w2' n1 n2)(*strict*)
     apply(force)
    apply(rename_tac d e xa B qs qt A src trg d1 d2 w1' w2' n1 n2)(*strict*)
    apply(rule_tac
      P="\<lambda>X. X @ liftB (drop (length w1') xa) = liftB xa"
      and t="w1'"
      and s="liftB (take (length w1') xa)"
      in ssubst)
     apply(rename_tac d e xa B qs qt A src trg d1 d2 w1' w2' n1 n2)(*strict*)
     apply(force)
    apply(rename_tac d e xa B qs qt A src trg d1 d2 w1' w2' n1 n2)(*strict*)
    apply(rule_tac
      t="liftB (take (length w1') xa) @ liftB (drop (length w1') xa)"
      and s="liftB (take (length w1') xa @ (drop (length w1') xa))"
      in ssubst)
     apply(rename_tac d e xa B qs qt A src trg d1 d2 w1' w2' n1 n2)(*strict*)
     apply (metis liftB_commutes_over_concat)
    apply(rename_tac d e xa B qs qt A src trg d1 d2 w1' w2' n1 n2)(*strict*)
    apply(rule_tac
      t="take (length w1') xa @ drop (length w1') xa"
      and s="xa"
      in ssubst)
     apply(rename_tac d e xa B qs qt A src trg d1 d2 w1' w2' n1 n2)(*strict*)
     apply (metis append_take_drop_id_hlp)
    apply(rename_tac d e xa B qs qt A src trg d1 d2 w1' w2' n1 n2)(*strict*)
    apply(force)
   apply(rename_tac d e xa B qs qt A src trg d1 d2 w1' w2' n1 n2)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa B qs qt A src trg d1 d2 n1 n2 x1 x2)(*strict*)
   apply(subgoal_tac "xa=x1@x2")
    apply(rename_tac d e xa B qs qt A src trg d1 d2 n1 n2 x1 x2)(*strict*)
    prefer 2
    apply (metis liftB_commutes_over_concat liftB_inj)
   apply(rename_tac d e xa B qs qt A src trg d1 d2 n1 n2 x1 x2)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2)(*strict*)
   apply(thin_tac "liftB x1 @ liftB x2 = liftB (x1 @ x2)")
   apply(simp add: cfgRM.derivation_from_to_def cfgRM.derivation_from_def cfgRM.derivation_to_def)
   apply(clarsimp)
   apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 n na xa xaa)(*strict*)
   apply(case_tac "d1 0")
    apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 n na xa xaa)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 n na xa xaa a)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 n na xa xaa)(*strict*)
   apply(case_tac "d2 0")
    apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 n na xa xaa)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 n na xa xaa a)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 n na xa xaa)(*strict*)
   apply(subgoal_tac "n=n1")
    apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 n na xa xaa)(*strict*)
    prefer 2
    apply(rule_tac
      d="d1"
      in cfgRM.maximum_of_domainUnique)
      apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 n na xa xaa)(*strict*)
      apply(force)
     apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 n na xa xaa)(*strict*)
     apply(force)
    apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 n na xa xaa)(*strict*)
    apply(simp add: maximum_of_domain_def)
   apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 n na xa xaa)(*strict*)
   apply(subgoal_tac "na=n2")
    apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 n na xa xaa)(*strict*)
    prefer 2
    apply(rule_tac
      d="d2"
      in cfgRM.maximum_of_domainUnique)
      apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 n na xa xaa)(*strict*)
      apply(force)
     apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 n na xa xaa)(*strict*)
     apply(force)
    apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 n na xa xaa)(*strict*)
    apply(simp add: maximum_of_domain_def)
   apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 n na xa xaa)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
   apply(subgoal_tac "x1 \<in> epdaS_produce_from_before_pop G SSqi SSA SSqt" for SSqi SSA SSqt)
    apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
    prefer 2
    apply(erule_tac
      x="n1"
      in meta_allE)
    apply(clarsimp)
    apply(erule_tac
      x="d1"
      in meta_allE)
    apply(clarsimp)
    apply(erule_tac
      x="xa"
      in meta_allE)
    apply(clarsimp)
    apply(erule_tac
      x="x1"
      in meta_allE)
    apply(clarsimp)
    apply(erule_tac
      x="trg"
      in meta_allE)
    apply(clarsimp)
    apply(erule_tac
      x="B"
      in meta_allE)
    apply(clarsimp)
    apply(erule_tac
      x="qs"
      in meta_allE)
    apply(clarsimp)
    apply(erule meta_impE)
     apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
     apply(rule cfgRM.derivation_belongs)
        apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
        apply(force)
       apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
       apply(force)
      apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
      apply(subgoal_tac "\<lparr>cfg_conf = [teA (cons_l3   trg B qs), teA (cons_l3   qs A qt)]\<rparr> \<in> cfg_configurations GP")
       apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
       apply(simp add: cfg_configurations_def)
      apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
      apply(rule_tac
      d="d"
      in cfgRM.belongs_configurations)
       apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
       apply(force)
      apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
      apply(force)
     apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
     apply(force)
    apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
    apply(force)
   apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
   apply(subgoal_tac "x2 \<in> epdaS_produce_from_before_pop G SSqi SSA SSqt" for SSqi SSA SSqt)
    apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
    prefer 2
    apply(erule_tac
      x="n2"
      in meta_allE)
    apply(clarsimp)
    apply(erule_tac
      x="d2"
      in meta_allE)
    apply(clarsimp)
    apply(erule_tac
      x="xaa"
      in meta_allE)
    apply(clarsimp)
    apply(erule_tac
      x="x2"
      in meta_allE)
    apply(clarsimp)
    apply(erule_tac
      x="qs"
      in meta_allE)
    apply(clarsimp)
    apply(erule_tac
      x="A"
      in meta_allE)
    apply(clarsimp)
    apply(erule_tac
      x="qt"
      in meta_allE)
    apply(clarsimp)
    apply(erule meta_impE)
     apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
     apply(rule cfgRM.derivation_belongs)
        apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
        apply(force)
       apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
       apply(force)
      apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
      apply(subgoal_tac "\<lparr>cfg_conf = [teA (cons_l3   trg B qs), teA (cons_l3   qs A qt)]\<rparr> \<in> cfg_configurations GP")
       apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
       apply(simp add: cfg_configurations_def)
      apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
      apply(rule_tac
      d="d"
      in cfgRM.belongs_configurations)
       apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
       apply(force)
      apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
      apply(force)
     apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
     apply(force)
    apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
    apply(force)
   apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
   apply(thin_tac "\<And>y d e x qi A qt. y < Suc (n1 + n2) \<Longrightarrow> cfgRM.derivation GP d \<Longrightarrow> cfgSTD.belongs GP d \<Longrightarrow> d 0 = Some (pair None \<lparr>cfg_conf = [teA (cons_l3   qi A qt)]\<rparr>) \<Longrightarrow> d y = Some (pair e \<lparr>cfg_conf = liftB x\<rparr>) \<Longrightarrow> x \<in> epdaS_produce_from_before_pop G qi A qt")
   apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
   apply(rule epdaS_produce_from_before_pop_append)
      apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
      apply(simp add: valid_simple_dpda_def valid_dpda_def)
     apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
     apply(force)
    apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
    apply(force)
   apply(rename_tac d e B qs qt A src trg d1 d2 n1 n2 x1 x2 xa xaa)(*strict*)
   apply(force)
    (*pop*)
  apply(rename_tac d e xa qi A qt x e2)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e xa qi A qt x e2 xb)(*strict*)
  apply(case_tac "edge_push xb")
   apply(rename_tac d e xa qi A qt x e2 xb)(*strict*)
   prefer 2
   apply(rename_tac d e xa qi A qt x e2 xb a list)(*strict*)
   apply(clarsimp)
  apply(rename_tac d e xa qi A qt x e2 xb)(*strict*)
  apply(clarsimp)
  apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_pop_def)
  apply(clarsimp)
  apply(rename_tac d e xa x xb)(*strict*)
  apply(simp add: valid_simple_dpda_def)
  apply(clarsimp)
  apply(subgoal_tac "\<exists>x. edge_pop xb = [x]")
   apply(rename_tac d e xa x xb)(*strict*)
   prefer 2
   apply(rule valid_pda_edge_pop_single)
    apply(rename_tac d e xa x xb)(*strict*)
    apply(simp add: valid_simple_dpda_def valid_dpda_def)
    apply(force)
   apply(rename_tac d e xa x xb)(*strict*)
   apply(force)
  apply(rename_tac d e xa x xb)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e xa x xb xc)(*strict*)
  apply(erule_tac
      x="xb"
      in ballE)
   apply(rename_tac d e xa x xb xc)(*strict*)
   prefer 2
   apply(force)
  apply(rename_tac d e xa x xb xc)(*strict*)
  apply(case_tac "edge_event xb")
   apply(rename_tac d e xa x xb xc)(*strict*)
   prefer 2
   apply(rename_tac d e xa x xb xc a)(*strict*)
   apply(clarsimp)
  apply(rename_tac d e xa x xb xc)(*strict*)
  apply(clarsimp)
  apply(case_tac x)
   apply(rename_tac d e xa x xb xc)(*strict*)
   prefer 2
   apply(rename_tac d e xa x xb xc nat)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa xb xc nat)(*strict*)
   apply(subgoal_tac "d (Suc (Suc 0)) = None")
    apply(rename_tac d e xa xb xc nat)(*strict*)
    apply(subgoal_tac "\<exists>e c. d (Suc (Suc 0)) = Some (pair e c)")
     apply(rename_tac d e xa xb xc nat)(*strict*)
     prefer 2
     apply(rule_tac
      m="Suc (Suc nat)"
      in cfgRM.pre_some_position_is_some_position)
       apply(rename_tac d e xa xb xc nat)(*strict*)
       apply(force)
      apply(rename_tac d e xa xb xc nat)(*strict*)
      apply(force)
     apply(rename_tac d e xa xb xc nat)(*strict*)
     apply(force)
    apply(rename_tac d e xa xb xc nat)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa xb xc nat)(*strict*)
   apply(rule_tac
      G="GP"
      in cfgRM_no_step_without_nonterms)
      apply(rename_tac d e xa xb xc nat)(*strict*)
      apply(force)
     apply(rename_tac d e xa xb xc nat)(*strict*)
     apply(force)
    apply(rename_tac d e xa xb xc nat)(*strict*)
    apply(force)
   apply(rename_tac d e xa xb xc nat)(*strict*)
   apply(force)
  apply(rename_tac d e xa x xb xc)(*strict*)
  apply(clarsimp)
  apply(rename_tac d xa xb xc)(*strict*)
  apply(case_tac xa)
   apply(rename_tac d xa xb xc)(*strict*)
   prefer 2
   apply(rename_tac d xa xb xc a list)(*strict*)
   apply(clarsimp)
  apply(rename_tac d xa xb xc)(*strict*)
  apply(clarsimp)
  apply(rename_tac d xb xc)(*strict*)
  apply(thin_tac "\<And>y d e x qi A qt. y = 0 \<Longrightarrow> cfgRM.derivation GP d \<Longrightarrow> cfgSTD.belongs GP d \<Longrightarrow> d 0 = Some (pair None \<lparr>cfg_conf = liftB x\<rparr>) \<Longrightarrow> None = e \<and> [teA (cons_l3   qi A qt)] = liftB x \<Longrightarrow> x \<in> epdaS_produce_from_before_pop G qi A qt")
  apply(rename_tac d xb xc)(*strict*)
  apply(simp add: epdaS_produce_from_before_pop_def)
  apply(rule_tac
      x="der2 \<lparr>epdaS_conf_state = edge_src xb, epdaS_conf_scheduler = [], epdaS_conf_stack = [xc]\<rparr> xb \<lparr>epdaS_conf_state = edge_trg xb, epdaS_conf_scheduler = [], epdaS_conf_stack = []\<rparr>"
      in exI)
  apply(rule context_conjI)
   apply(rename_tac d xb xc)(*strict*)
   apply(rule epdaS.der2_is_derivation)
   apply(simp add: epdaS_step_relation_def)
   apply(simp add: option_to_list_def)
  apply(rename_tac d xb xc)(*strict*)
  apply(rule conjI)
   apply(rename_tac d xb xc)(*strict*)
   apply(rule epdaS.derivation_belongs)
      apply(rename_tac d xb xc)(*strict*)
      apply(simp add: valid_dpda_def valid_pda_def)
     apply(rename_tac d xb xc)(*strict*)
     apply(simp add: der2_def)
    apply(rename_tac d xb xc)(*strict*)
    apply(simp add: epdaS_configurations_def)
    apply(subgoal_tac "valid_epda_step_label G xb")
     apply(rename_tac d xb xc)(*strict*)
     apply(simp add: valid_epda_step_label_def)
     apply(simp add: may_terminated_by_def append_language_def kleene_star_def)
     apply(clarsimp)
     apply(rename_tac d xb xc a)(*strict*)
     apply(erule disjE)
      apply(rename_tac d xb xc a)(*strict*)
      apply(clarsimp)
      apply(rename_tac d xb)(*strict*)
      apply(simp add: valid_dpda_def valid_pda_def valid_epda_def)
     apply(rename_tac d xb xc a)(*strict*)
     apply(clarsimp)
     apply(rename_tac d xb xc)(*strict*)
     apply (metis Diff_iff head_in_set nset_mp)
    apply(rename_tac d xb xc)(*strict*)
    apply(simp add: valid_dpda_def valid_pda_def valid_epda_def)
   apply(rename_tac d xb xc)(*strict*)
   apply(force)
  apply(rename_tac d xb xc)(*strict*)
  apply(rule_tac
      x="edge_src xb"
      in exI)
  apply(rule_tac
      x="[]"
      in exI)
  apply(rule conjI)
   apply(rename_tac d xb xc)(*strict*)
   apply(simp add: der2_def)
  apply(rename_tac d xb xc)(*strict*)
  apply(rule_tac
      x="0"
      in exI)
  apply(rule conjI)
   apply(rename_tac d xb xc)(*strict*)
   apply(simp add: der2_def)
  apply(rename_tac d xb xc)(*strict*)
  apply(rule conjI)
   apply(rename_tac d xb xc)(*strict*)
   apply(simp add: der2_def)
  apply(rename_tac d xb xc)(*strict*)
  apply(clarsimp)
  apply(rename_tac d xb xc e c)(*strict*)
  apply(simp add: der2_def)
  apply(clarsimp)
  done

lemma F_SDPDA_TO_CFG_STD__43_imp_42_hlp: "
  valid_simple_dpda G
  \<Longrightarrow> cfgRM.derivation (F_SDPDA_TO_CFG_STD G) d
  \<Longrightarrow> cfgSTD.belongs (F_SDPDA_TO_CFG_STD G) d
  \<Longrightarrow> d 0 = Some (pair None \<lparr>cfg_conf = [teA (cons_l2   qi A)]\<rparr>)
  \<Longrightarrow> d i = Some (pair e \<lparr>cfg_conf = liftB x\<rparr>)
  \<Longrightarrow> x \<in> epdaS_produce_and_eliminate_from G qi A"
  apply(induct i arbitrary: d e x qi A rule: less_induct)
  apply(rename_tac x d e xa qi A)(*strict*)
  apply(clarsimp)
  apply(case_tac x)
   apply(rename_tac x d e xa qi A)(*strict*)
   apply(clarsimp)
   apply(rename_tac d xa qi A)(*strict*)
   apply(case_tac xa)
    apply(rename_tac d xa qi A)(*strict*)
    apply(clarsimp)
   apply(rename_tac d xa qi A a list)(*strict*)
   apply(clarsimp)
  apply(rename_tac x d e xa qi A nat)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e xa qi A nat)(*strict*)
  apply(subgoal_tac "\<exists>e1 e2 c1 c2. d 0 = Some (pair e1 c1) \<and> d (Suc 0) = Some (pair (Some e2) c2) \<and> cfgRM_step_relation (F_SDPDA_TO_CFG_STD G) c1 e2 c2")
   apply(rename_tac d e xa qi A nat)(*strict*)
   prefer 2
   apply(rule_tac
      m="Suc nat"
      in cfgRM.step_detail_before_some_position)
     apply(rename_tac d e xa qi A nat)(*strict*)
     apply(force)
    apply(rename_tac d e xa qi A nat)(*strict*)
    apply(force)
   apply(rename_tac d e xa qi A nat)(*strict*)
   apply(force)
  apply(rename_tac d e xa qi A nat)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e xa qi A nat e2 c2)(*strict*)
  apply(subgoal_tac "e2 \<in> F_SDPDA_TO_CFG_STD__edges_l3 G \<or> e2 \<in> F_SDPDA_TO_CFG_STD__edges_l2 G")
   apply(rename_tac d e xa qi A nat e2 c2)(*strict*)
   prefer 2
   apply(subgoal_tac "e2 \<in> cfg_productions (F_SDPDA_TO_CFG_STD G)")
    apply(rename_tac d e xa qi A nat e2 c2)(*strict*)
    prefer 2
    apply(simp add: cfgRM_step_relation_def)
   apply(rename_tac d e xa qi A nat e2 c2)(*strict*)
   apply(clarsimp)
   apply(simp add: F_SDPDA_TO_CFG_STD_def)
  apply(rename_tac d e xa qi A nat e2 c2)(*strict*)
  apply(erule disjE)
   apply(rename_tac d e xa qi A nat e2 c2)(*strict*)
   apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_def)
   apply(erule disjE)
    apply(rename_tac d e xa qi A nat e2 c2)(*strict*)
    apply(clarsimp)
    apply(rename_tac d e xa qi A nat e2 c2 x)(*strict*)
    apply(case_tac "edge_event x")
     apply(rename_tac d e xa qi A nat e2 c2 x)(*strict*)
     apply(clarsimp)
    apply(rename_tac d e xa qi A nat e2 c2 x a)(*strict*)
    apply(clarsimp)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_read_def)
    apply(clarsimp)
    apply(rename_tac d e xa qi A nat c2 x a qt)(*strict*)
    apply(simp add: cfgRM_step_relation_def)
    apply(clarsimp)
    apply(rename_tac d e xa qi A nat c2 x a qt l r)(*strict*)
    apply(case_tac l)
     apply(rename_tac d e xa qi A nat c2 x a qt l r)(*strict*)
     apply(clarsimp)
    apply(rename_tac d e xa qi A nat c2 x a qt l r aa list)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa qi A nat e2 c2)(*strict*)
   apply(erule disjE)
    apply(rename_tac d e xa qi A nat e2 c2)(*strict*)
    apply(clarsimp)
    apply(rename_tac d e xa qi A nat e2 c2 x)(*strict*)
    apply(case_tac "edge_push x")
     apply(rename_tac d e xa qi A nat e2 c2 x)(*strict*)
     apply(clarsimp)
     prefer 2
     apply(rename_tac d e xa qi A nat e2 c2 x a list)(*strict*)
     apply(clarsimp)
    apply(rename_tac d e xa qi A nat e2 c2 x)(*strict*)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_pop_def)
    apply(clarsimp)
    apply(rename_tac d e xa qi A nat c2 x)(*strict*)
    apply(simp add: cfgRM_step_relation_def)
    apply(clarsimp)
    apply(rename_tac d e xa qi A nat c2 x l r)(*strict*)
    apply(case_tac l)
     apply(rename_tac d e xa qi A nat c2 x l r)(*strict*)
     apply(clarsimp)
    apply(rename_tac d e xa qi A nat c2 x l r a list)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa qi A nat e2 c2)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa qi A nat e2 c2 x)(*strict*)
   apply(case_tac "edge_push x")
    apply(rename_tac d e xa qi A nat e2 c2 x)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa qi A nat e2 c2 x a list)(*strict*)
   apply(clarsimp)
   apply(case_tac "edge_event x")
    apply(rename_tac d e xa qi A nat e2 c2 x a list)(*strict*)
    apply(clarsimp)
    prefer 2
    apply(rename_tac d e xa qi A nat e2 c2 x a list aa)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa qi A nat e2 c2 x a list)(*strict*)
   apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_push_def)
   apply(clarsimp)
   apply(rename_tac d e xa qi A nat c2 x a list qs qt)(*strict*)
   apply(simp add: cfgRM_step_relation_def)
   apply(clarsimp)
   apply(rename_tac d e xa qi A nat c2 x a list qs qt l r)(*strict*)
   apply(case_tac l)
    apply(rename_tac d e xa qi A nat c2 x a list qs qt l r)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa qi A nat c2 x a list qs qt l r aa lista)(*strict*)
   apply(clarsimp)
  apply(rename_tac d e xa qi A nat e2 c2)(*strict*)
  apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_def)
  apply(erule disjE)
   apply(rename_tac d e xa qi A nat e2 c2)(*strict*)
   prefer 2
   apply(erule disjE)
    apply(rename_tac d e xa qi A nat e2 c2)(*strict*)
    apply(thin_tac "\<And>y d e x qi A. y < Suc nat \<Longrightarrow> cfgRM.derivation (F_SDPDA_TO_CFG_STD G) d \<Longrightarrow> cfgSTD.belongs (F_SDPDA_TO_CFG_STD G) d \<Longrightarrow> d 0 = Some (pair None \<lparr>cfg_conf = [teA (cons_l2   qi A)]\<rparr>) \<Longrightarrow> d y = Some (pair e \<lparr>cfg_conf = liftB x\<rparr>) \<Longrightarrow> x \<in> epdaS_produce_and_eliminate_from G qi A")
    apply(rename_tac d e xa qi A nat e2 c2)(*strict*)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_final_def)
    apply(clarsimp)
    apply(rename_tac d e xa qi A nat c2 i Aa)(*strict*)
    apply(simp add: cfgRM_step_relation_def)
    apply(clarsimp)
    apply(rename_tac d e xa qi A nat c2 i Aa l r)(*strict*)
    apply(case_tac l)
     apply(rename_tac d e xa qi A nat c2 i Aa l r)(*strict*)
     prefer 2
     apply(rename_tac d e xa qi A nat c2 i Aa l r a list)(*strict*)
     apply(clarsimp)
    apply(rename_tac d e xa qi A nat c2 i Aa l r)(*strict*)
    apply(clarsimp)
    apply(rename_tac d e xa nat c2 i Aa)(*strict*)
    apply(case_tac nat)
     apply(rename_tac d e xa nat c2 i Aa)(*strict*)
     apply(clarsimp)
     apply(rename_tac d xa i Aa)(*strict*)
     apply(case_tac xa)
      apply(rename_tac d xa i Aa)(*strict*)
      apply(clarsimp)
      apply(rename_tac d i Aa)(*strict*)
      prefer 2
      apply(rename_tac d xa i Aa a list)(*strict*)
      apply(clarsimp)
     apply(rename_tac d i Aa)(*strict*)
     prefer 2
     apply(rename_tac d e xa nat c2 i Aa nata)(*strict*)
     apply(clarsimp)
     apply(rename_tac d e xa c2 i Aa nata)(*strict*)
     apply(subgoal_tac "\<exists>e c. d (Suc (Suc 0)) = Some (pair e c)")
      apply(rename_tac d e xa c2 i Aa nata)(*strict*)
      prefer 2
      apply(rule_tac
      m="Suc (Suc nata)"
      in cfgRM.pre_some_position_is_some_position)
        apply(rename_tac d e xa c2 i Aa nata)(*strict*)
        apply(force)
       apply(rename_tac d e xa c2 i Aa nata)(*strict*)
       apply(force)
      apply(rename_tac d e xa c2 i Aa nata)(*strict*)
      apply(force)
     apply(rename_tac d e xa c2 i Aa nata)(*strict*)
     apply(clarsimp)
     apply(rename_tac d e xa c2 i Aa nata ea c)(*strict*)
     apply(subgoal_tac "d (Suc (Suc 0)) = None")
      apply(rename_tac d e xa c2 i Aa nata ea c)(*strict*)
      apply(clarsimp)
     apply(rename_tac d e xa c2 i Aa nata ea c)(*strict*)
     apply(rule_tac
      G="F_SDPDA_TO_CFG_STD G"
      in cfgRM_no_step_without_nonterms)
        apply(rename_tac d e xa c2 i Aa nata ea c)(*strict*)
        apply (metis F_SDPDA_TO_CFG_STD__makes_CFG)
       apply(rename_tac d e xa c2 i Aa nata ea c)(*strict*)
       apply(force)
      apply(rename_tac d e xa c2 i Aa nata ea c)(*strict*)
      apply(force)
     apply(rename_tac d e xa c2 i Aa nata ea c)(*strict*)
     apply(clarsimp)
    apply(rename_tac d i Aa)(*strict*)
    apply(simp add: epdaS_produce_and_eliminate_from_def)
    apply(rule_tac
      x="der1 \<lparr>epdaS_conf_state = i, epdaS_conf_scheduler = [], epdaS_conf_stack = Aa # [epda_box G]\<rparr>"
      in exI)
    apply(rule_tac
      x="i"
      in exI)
    apply(clarsimp)
    apply(rule conjI)
     apply(rename_tac d i Aa)(*strict*)
     apply(rule epdaS.der1_is_derivation)
    apply(rename_tac d i Aa)(*strict*)
    apply(rule conjI)
     apply(rename_tac d i Aa)(*strict*)
     apply(rule epdaS.der1_belongs)
     apply(simp add: epdaS_configurations_def)
     apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def valid_epda_def)
     apply(force)
    apply(rename_tac d i Aa)(*strict*)
    apply(rule_tac
      x="[epda_box G]"
      in exI)
    apply(rule conjI)
     apply(rename_tac d i Aa)(*strict*)
     apply(simp add: der1_def)
    apply(rename_tac d i Aa)(*strict*)
    apply(rule_tac
      x="0"
      in exI)
    apply(clarsimp)
    apply(simp add: der1_def)
    (*read edge*)
   apply(rename_tac d e xa qi A nat e2 c2)(*strict*)
   prefer 2
   apply(clarsimp)
   apply(rename_tac d e xa qi A nat e2 c2 x)(*strict*)
   apply(case_tac "edge_event x")
    apply(rename_tac d e xa qi A nat e2 c2 x)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa qi A nat e2 c2 x a)(*strict*)
   apply(clarsimp)
   apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_read_def)
   apply(clarsimp)
   apply(rename_tac d e xa qi A nat c2 x a)(*strict*)
   apply(subgoal_tac "\<exists>y. edge_pop x=[y]")
    apply(rename_tac d e xa qi A nat c2 x a)(*strict*)
    prefer 2
    apply(rule valid_pda_edge_pop_single)
     apply(rename_tac d e xa qi A nat c2 x a)(*strict*)
     apply(simp add: valid_simple_dpda_def valid_dpda_def)
     apply(force)
    apply(rename_tac d e xa qi A nat c2 x a)(*strict*)
    apply(force)
   apply(rename_tac d e xa qi A nat c2 x a)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa qi A nat c2 x a y)(*strict*)
   apply(subgoal_tac "edge_push x=[y]")
    apply(rename_tac d e xa qi A nat c2 x a y)(*strict*)
    prefer 2
    apply(simp add: valid_simple_dpda_def)
    apply(clarsimp)
    apply(erule_tac
      x="x"
      in ballE)
     apply(rename_tac d e xa qi A nat c2 x a y)(*strict*)
     prefer 2
     apply(force)
    apply(rename_tac d e xa qi A nat c2 x a y)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa qi A nat c2 x a y)(*strict*)
   apply(case_tac x)
   apply(rename_tac d e xa qi A nat c2 x a y edge_srca edge_eventa edge_popa edge_pusha edge_trga)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa qi A nat c2 a y edge_src edge_trg)(*strict*)
   apply(rename_tac src trg)
   apply(rename_tac d e xa qi A nat c2 a y src trg)(*strict*)
   apply(simp add: cfgRM_step_relation_def)
   apply(clarsimp)
   apply(rename_tac d e xa qi A nat c2 a y src trg l r)(*strict*)
   apply(case_tac c2)
   apply(rename_tac d e xa qi A nat c2 a y src trg l r cfg_confa)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa qi A nat a y src trg l r)(*strict*)
   apply(case_tac l)
    apply(rename_tac d e xa qi A nat a y src trg l r)(*strict*)
    apply(clarsimp)
    apply(rename_tac d e xa nat a y src trg)(*strict*)
    prefer 2
    apply(rename_tac d e xa qi A nat a y src trg l r aa list)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa nat a y src trg)(*strict*)
   apply(subgoal_tac "\<forall>k \<le> nat. (\<forall>e c. d (Suc k) = Some (pair e c) \<longrightarrow> (\<exists>w. cfg_conf c=teB a # w))")
    apply(rename_tac d e xa nat a y src trg)(*strict*)
    apply(subgoal_tac "\<exists>w. cfg_conf \<lparr>cfg_conf = liftB xa\<rparr>=teB a # w")
     apply(rename_tac d e xa nat a y src trg)(*strict*)
     apply(clarsimp)
     apply(rename_tac d e xa nat a y src trg w)(*strict*)
     apply(case_tac xa)
      apply(rename_tac d e xa nat a y src trg w)(*strict*)
      apply(clarsimp)
     apply(rename_tac d e xa nat a y src trg w aa list)(*strict*)
     apply(clarsimp)
     apply(rename_tac d e nat a y src trg w list)(*strict*)
     apply(rename_tac w)
     apply(rename_tac d e nat a y src trg wa w)(*strict*)
     apply(erule_tac
      x="nat"
      in meta_allE)
     apply(erule_tac
      x="derivation_map (derivation_drop (derivation_take d (Suc nat)) (Suc 0)) (\<lambda>c. \<lparr>cfg_conf=drop(length [teB a])(cfg_conf c)\<rparr>)"
      in meta_allE)
     apply(erule_tac
      x="if nat=0 then None else e"
      in meta_allE)
     apply(erule_tac
      x="w"
      in meta_allE)
     apply(erule_tac
      x="trg"
      in meta_allE)
     apply(erule_tac
      x="y"
      in meta_allE)
     apply(erule meta_impE)
      apply(rename_tac d e nat a y src trg wa w)(*strict*)
      apply(force)
     apply(rename_tac d e nat a y src trg wa w)(*strict*)
     apply(subgoal_tac "cfgRM.derivation (F_SDPDA_TO_CFG_STD G) (derivation_map (derivation_drop (derivation_take d (Suc nat)) (Suc 0)) (\<lambda>c. \<lparr>cfg_conf = drop (length [teB a]) (cfg_conf c)\<rparr>))")
      apply(rename_tac d e nat a y src trg wa w)(*strict*)
      prefer 2
      apply(rule_tac
      t="length [teB a]"
      and s="length [a]"
      in ssubst)
       apply(rename_tac d e nat a y src trg wa w)(*strict*)
       apply(force)
      apply(rename_tac d e nat a y src trg wa w)(*strict*)
      apply(rule_tac
      m="nat"
      in CFGRM_drop_head_terminals_preserves_derivation)
         apply(rename_tac d e nat a y src trg wa w)(*strict*)
         apply (simp add: F_SDPDA_TO_CFG_STD__makes_CFG)
        apply(rename_tac d e nat a y src trg wa w)(*strict*)
        apply(rule_tac
      m="nat"
      in cfgRM.derivation_drop_preserves_derivation)
         apply(rename_tac d e nat a y src trg wa w)(*strict*)
         apply(rule cfgRM.derivation_take_preserves_derivation)
         apply(force)
        apply(rename_tac d e nat a y src trg wa w)(*strict*)
        apply(rule_tac
      t="Suc 0+nat"
      and s="Suc nat"
      in ssubst)
         apply(rename_tac d e nat a y src trg wa w)(*strict*)
         apply(force)
        apply(rename_tac d e nat a y src trg wa w)(*strict*)
        apply(rule maximum_of_domain_derivation_take)
        apply(force)
       apply(rename_tac d e nat a y src trg wa w)(*strict*)
       apply(rule_tac
      P="\<lambda>X. maximum_of_domain (derivation_drop (derivation_take d (Suc nat)) (Suc 0)) X"
      and s="Suc nat-Suc 0"
      in ssubst)
        apply(rename_tac d e nat a y src trg wa w)(*strict*)
        apply(force)
       apply(rename_tac d e nat a y src trg wa w)(*strict*)
       apply(rule cfgRM.derivation_drop_makes_maximum_of_domain)
         apply(rename_tac d e nat a y src trg wa w)(*strict*)
         apply(rule cfgRM.derivation_take_preserves_derivation)
         apply(force)
        apply(rename_tac d e nat a y src trg wa w)(*strict*)
        apply(rule maximum_of_domain_derivation_take)
        apply(force)
       apply(rename_tac d e nat a y src trg wa w)(*strict*)
       apply(force)
      apply(rename_tac d e nat a y src trg wa w)(*strict*)
      apply(clarsimp)
      apply(rename_tac d e nat a y src trg wa w k ea c)(*strict*)
      apply(erule_tac
      x="k"
      in allE)
      apply(clarsimp)
      apply(simp add: derivation_drop_def derivation_take_def)
      apply(case_tac k)
       apply(rename_tac d e nat a y src trg wa w k ea c)(*strict*)
       apply(clarsimp)
      apply(rename_tac d e nat a y src trg wa w k ea c nata)(*strict*)
      apply(clarsimp)
     apply(rename_tac d e nat a y src trg wa w)(*strict*)
     apply(erule meta_impE)
      apply(rename_tac d e nat a y src trg wa w)(*strict*)
      apply(force)
     apply(rename_tac d e nat a y src trg wa w)(*strict*)
     apply(erule_tac meta_impE)
      apply(rename_tac d e nat a y src trg wa w)(*strict*)
      apply(rule cfgRM.derivation_belongs)
         apply(rename_tac d e nat a y src trg wa w)(*strict*)
         apply (simp add: F_SDPDA_TO_CFG_STD__makes_CFG)
        apply(rename_tac d e nat a y src trg wa w)(*strict*)
        apply(simp add: derivation_map_def derivation_drop_def derivation_take_def)
       apply(rename_tac d e nat a y src trg wa w)(*strict*)
       apply(subgoal_tac "\<lparr>cfg_conf = [teB a, teA (cons_l2   trg y)]\<rparr> \<in> cfg_configurations (F_SDPDA_TO_CFG_STD G)")
        apply(rename_tac d e nat a y src trg wa w)(*strict*)
        apply(simp add: cfg_configurations_def)
       apply(rename_tac d e nat a y src trg wa w)(*strict*)
       apply(rule cfgRM.belongs_configurations)
        apply(rename_tac d e nat a y src trg wa w)(*strict*)
        apply(force)
       apply(rename_tac d e nat a y src trg wa w)(*strict*)
       apply(force)
      apply(rename_tac d e nat a y src trg wa w)(*strict*)
      apply(force)
     apply(rename_tac d e nat a y src trg wa w)(*strict*)
     apply(erule meta_impE)
      apply(rename_tac d e nat a y src trg wa w)(*strict*)
      apply(simp add: derivation_map_def derivation_drop_def derivation_take_def)
     apply(rename_tac d e nat a y src trg wa w)(*strict*)
     apply(erule meta_impE)
      apply(rename_tac d e nat a y src trg wa w)(*strict*)
      apply(simp add: derivation_map_def derivation_drop_def derivation_take_def)
      apply(clarsimp)
     apply(rename_tac d e nat a y src trg wa w)(*strict*)
     apply(rule epdaS_produce_and_eliminate_from_Cons)
       apply(rename_tac d e nat a y src trg wa w)(*strict*)
       apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def)
      apply(rename_tac d e nat a y src trg wa w)(*strict*)
      apply(force)
     apply(rename_tac d e nat a y src trg wa w)(*strict*)
     apply(force)
    apply(rename_tac d e xa nat a y src trg)(*strict*)
    apply(erule_tac
      x="nat"
      in allE)
    apply(clarsimp)
    apply(rename_tac d e xa nat a y src trg w)(*strict*)
    apply(force)
   apply(rename_tac d e xa nat a y src trg)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa nat a y src trg k ea c)(*strict*)
   apply(subgoal_tac "\<exists>e w. (derivation_take d (Suc nat)) (Suc k) = Some (pair e \<lparr>cfg_conf = teB SSb # w\<rparr>)" for SSb)
    apply(rename_tac d e xa nat a y src trg k ea c)(*strict*)
    prefer 2
    apply(rule_tac
      m="Suc 0"
      and n="nat"
      and G="F_SDPDA_TO_CFG_STD G"
      in terminal_at_beginning_are_never_modified)
        apply(rename_tac d e xa nat a y src trg k ea c)(*strict*)
        apply(rule cfgRM_derivations_are_cfg_derivations)
        apply(rule cfgRM.derivation_take_preserves_derivation)
        apply(force)
       apply(rename_tac d e xa nat a y src trg k ea c)(*strict*)
       apply(rule_tac
      t="Suc 0+nat"
      and s="Suc nat"
      in ssubst)
        apply(rename_tac d e xa nat a y src trg k ea c)(*strict*)
        apply(force)
       apply(rename_tac d e xa nat a y src trg k ea c)(*strict*)
       apply(rule maximum_of_domain_derivation_take)
       apply(force)
      apply(rename_tac d e xa nat a y src trg k ea c)(*strict*)
      apply(simp add: derivation_take_def)
     apply(rename_tac d e xa nat a y src trg k ea c)(*strict*)
     apply(force)
    apply(rename_tac d e xa nat a y src trg k ea c)(*strict*)
    apply(force)
   apply(rename_tac d e xa nat a y src trg k ea c)(*strict*)
   apply(simp add: derivation_take_def)
   apply(clarsimp)
    (*push edge*)
  apply(rename_tac d e xa qi A nat e2 c2)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e xa qi A nat e2 c2 x)(*strict*)
  apply(case_tac "edge_push x")
   apply(rename_tac d e xa qi A nat e2 c2 x)(*strict*)
   apply(clarsimp)
  apply(rename_tac d e xa qi A nat e2 c2 x a list)(*strict*)
  apply(clarsimp)
  apply(case_tac "edge_event x")
   apply(rename_tac d e xa qi A nat e2 c2 x a list)(*strict*)
   prefer 2
   apply(rename_tac d e xa qi A nat e2 c2 x a list aa)(*strict*)
   apply(clarsimp)
  apply(rename_tac d e xa qi A nat e2 c2 x a list)(*strict*)
  apply(clarsimp)
  apply(subgoal_tac "\<exists>y. edge_pop x=[y]")
   apply(rename_tac d e xa qi A nat e2 c2 x a list)(*strict*)
   prefer 2
   apply(rule valid_pda_edge_pop_single)
    apply(rename_tac d e xa qi A nat e2 c2 x a list)(*strict*)
    apply(simp add: valid_simple_dpda_def valid_dpda_def)
    apply(force)
   apply(rename_tac d e xa qi A nat e2 c2 x a list)(*strict*)
   apply(force)
  apply(rename_tac d e xa qi A nat e2 c2 x a list)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e xa qi A nat e2 c2 x a list y)(*strict*)
  apply(subgoal_tac "\<exists>z. edge_push x=[z,y]")
   apply(rename_tac d e xa qi A nat e2 c2 x a list y)(*strict*)
   prefer 2
   apply(simp add: valid_simple_dpda_def)
   apply(clarsimp)
   apply(erule_tac
      x="x"
      in ballE)
    apply(rename_tac d e xa qi A nat e2 c2 x a list y)(*strict*)
    prefer 2
    apply(force)
   apply(rename_tac d e xa qi A nat e2 c2 x a list y)(*strict*)
   apply(clarsimp)
  apply(rename_tac d e xa qi A nat e2 c2 x a list y)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e xa qi A nat e2 c2 x a y)(*strict*)
  apply(case_tac x)
  apply(rename_tac d e xa qi A nat e2 c2 x a y edge_src edge_eventa edge_popa edge_pusha edge_trg)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e xa qi A nat e2 c2 a y edge_src edge_trg)(*strict*)
  apply(rename_tac src trg)
  apply(rename_tac d e xa qi A nat e2 c2 a y src trg)(*strict*)
  apply(simp add: cfgRM_step_relation_def)
  apply(clarsimp)
  apply(rename_tac d e xa qi A nat e2 c2 a y src trg l r)(*strict*)
  apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_push_def)
  apply(erule disjE)
    (*push 1*)
   apply(rename_tac d e xa qi A nat e2 c2 a y src trg l r)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa qi A nat c2 a y src trg l r)(*strict*)
   apply(case_tac l)
    apply(rename_tac d e xa qi A nat c2 a y src trg l r)(*strict*)
    apply(clarsimp)
    apply(rename_tac d e xa nat c2 a y src trg)(*strict*)
    apply(case_tac c2)
    apply(rename_tac d e xa nat c2 a y src trg cfg_confa)(*strict*)
    apply(clarsimp)
    apply(rename_tac d e xa nat a y src trg)(*strict*)
    prefer 2
    apply(rename_tac d e xa qi A nat c2 a y src trg l r aa list)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa nat a y src trg)(*strict*)
   apply(subgoal_tac "\<lparr>prod_lhs = cons_l2 src y, prod_rhs = [teA (cons_l2   trg a)]\<rparr> \<in> F_SDPDA_TO_CFG_STD__edges_l3 G \<or> \<lparr>prod_lhs = cons_l2 src y, prod_rhs = [teA (cons_l2   trg a)]\<rparr> \<in> F_SDPDA_TO_CFG_STD__edges_l2 G")
    apply(rename_tac d e xa nat a y src trg)(*strict*)
    prefer 2
    apply(simp add: F_SDPDA_TO_CFG_STD_def)
   apply(rename_tac d e xa nat a y src trg)(*strict*)
   apply(thin_tac "\<lparr>prod_lhs = cons_l2 src y, prod_rhs = [teA (cons_l2   trg a)]\<rparr> \<in> cfg_productions (F_SDPDA_TO_CFG_STD G)")
   apply(erule disjE)
    apply(rename_tac d e xa nat a y src trg)(*strict*)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_def)
    apply(erule disjE)
     apply(rename_tac d e xa nat a y src trg)(*strict*)
     apply(clarsimp)
     apply(rename_tac d e xa nat a y src trg x)(*strict*)
     apply(case_tac "edge_event x")
      apply(rename_tac d e xa nat a y src trg x)(*strict*)
      apply(clarsimp)
     apply(rename_tac d e xa nat a y src trg x aa)(*strict*)
     apply(clarsimp)
     apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_read_def)
    apply(rename_tac d e xa nat a y src trg)(*strict*)
    apply(erule disjE)
     apply(rename_tac d e xa nat a y src trg)(*strict*)
     apply(clarsimp)
     apply(rename_tac d e xa nat a y src trg x)(*strict*)
     apply(case_tac "edge_push x")
      apply(rename_tac d e xa nat a y src trg x)(*strict*)
      apply(clarsimp)
      prefer 2
      apply(rename_tac d e xa nat a y src trg x aa list)(*strict*)
      apply(clarsimp)
     apply(rename_tac d e xa nat a y src trg x)(*strict*)
     apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_pop_def)
    apply(rename_tac d e xa nat a y src trg)(*strict*)
    apply(clarsimp)
    apply(rename_tac d e xa nat a y src trg x)(*strict*)
    apply(case_tac "edge_push x")
     apply(rename_tac d e xa nat a y src trg x)(*strict*)
     apply(clarsimp)
    apply(rename_tac d e xa nat a y src trg x aa list)(*strict*)
    apply(clarsimp)
    apply(case_tac "edge_event x")
     apply(rename_tac d e xa nat a y src trg x aa list)(*strict*)
     apply(clarsimp)
     prefer 2
     apply(rename_tac d e xa nat a y src trg x aa list ab)(*strict*)
     apply(clarsimp)
    apply(rename_tac d e xa nat a y src trg x aa list)(*strict*)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_push_def)
   apply(rename_tac d e xa nat a y src trg)(*strict*)
   apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_def)
   apply(erule disjE)
    apply(rename_tac d e xa nat a y src trg)(*strict*)
    apply(clarsimp)
    apply(rename_tac d e xa nat a y src trg x)(*strict*)
    apply(case_tac "edge_event x")
     apply(rename_tac d e xa nat a y src trg x)(*strict*)
     apply(clarsimp)
    apply(rename_tac d e xa nat a y src trg x aa)(*strict*)
    apply(clarsimp)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_read_def)
   apply(rename_tac d e xa nat a y src trg)(*strict*)
   apply(erule disjE)
    apply(rename_tac d e xa nat a y src trg)(*strict*)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_final_def)
   apply(rename_tac d e xa nat a y src trg)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa nat a y src trg x)(*strict*)
   apply(case_tac "edge_push x")
    apply(rename_tac d e xa nat a y src trg x)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa nat a y src trg x aa list)(*strict*)
   apply(clarsimp)
   apply(case_tac "edge_event x")
    apply(rename_tac d e xa nat a y src trg x aa list)(*strict*)
    apply(clarsimp)
    prefer 2
    apply(rename_tac d e xa nat a y src trg x aa list ab)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa nat a y src trg x aa list)(*strict*)
   apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_push_def)
   apply(clarsimp)
   apply(rename_tac d e xa nat x aa list)(*strict*)
   apply(subgoal_tac "\<exists>y. edge_pop x=[y]")
    apply(rename_tac d e xa nat x aa list)(*strict*)
    prefer 2
    apply(rule valid_pda_edge_pop_single)
     apply(rename_tac d e xa nat x aa list)(*strict*)
     apply(simp add: valid_simple_dpda_def valid_dpda_def)
     apply(force)
    apply(rename_tac d e xa nat x aa list)(*strict*)
    apply(force)
   apply(rename_tac d e xa nat x aa list)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa nat x aa list y)(*strict*)
   apply(subgoal_tac "\<exists>z. edge_push x=[z,y]")
    apply(rename_tac d e xa nat x aa list y)(*strict*)
    prefer 2
    apply(simp add: valid_simple_dpda_def)
    apply(clarsimp)
    apply(erule_tac
      x="x"
      in ballE)
     apply(rename_tac d e xa nat x aa list y)(*strict*)
     prefer 2
     apply(force)
    apply(rename_tac d e xa nat x aa list y)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa nat x aa list y)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa nat x aa y)(*strict*)
   apply(case_tac x)
   apply(rename_tac d e xa nat x aa y edge_srca edge_eventa edge_popa edge_pusha edge_trga)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa nat aa y edge_src edge_trg)(*strict*)
   apply(rename_tac src trg)
   apply(rename_tac d e xa nat aa y src trg)(*strict*)
   apply(erule_tac
      x="nat"
      in meta_allE)
   apply(erule_tac
      x="derivation_drop (derivation_take d (Suc nat)) (Suc 0)"
      in meta_allE)
   apply(erule_tac
      x="if nat=0 then None else e"
      in meta_allE)
   apply(erule_tac
      x="xa"
      in meta_allE)
   apply(erule_tac
      x="trg"
      in meta_allE)
   apply(erule_tac
      x="aa"
      in meta_allE)
   apply(erule meta_impE)
    apply(rename_tac d e xa nat aa y src trg)(*strict*)
    apply(force)
   apply(rename_tac d e xa nat aa y src trg)(*strict*)
   apply(subgoal_tac "cfgRM.derivation (F_SDPDA_TO_CFG_STD G) (derivation_drop (derivation_take d (Suc nat)) (Suc 0))")
    apply(rename_tac d e xa nat aa y src trg)(*strict*)
    prefer 2
    apply(rule_tac
      m="nat"
      in cfgRM.derivation_drop_preserves_derivation)
     apply(rename_tac d e xa nat aa y src trg)(*strict*)
     apply(rule cfgRM.derivation_take_preserves_derivation)
     apply(force)
    apply(rename_tac d e xa nat aa y src trg)(*strict*)
    apply(clarsimp)
    apply(rule_tac maximum_of_domain_derivation_take)
    apply(force)
   apply(rename_tac d e xa nat aa y src trg)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d e xa nat aa y src trg)(*strict*)
    apply(force)
   apply(rename_tac d e xa nat aa y src trg)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d e xa nat aa y src trg)(*strict*)
    apply(rule cfgRM.derivation_belongs)
       apply(rename_tac d e xa nat aa y src trg)(*strict*)
       apply (metis F_SDPDA_TO_CFG_STD__makes_CFG)
      apply(rename_tac d e xa nat aa y src trg)(*strict*)
      apply(simp add: derivation_drop_def derivation_take_def)
     apply(rename_tac d e xa nat aa y src trg)(*strict*)
     apply(rule cfgRM.belongs_configurations)
      apply(rename_tac d e xa nat aa y src trg)(*strict*)
      apply(force)
     apply(rename_tac d e xa nat aa y src trg)(*strict*)
     apply(force)
    apply(rename_tac d e xa nat aa y src trg)(*strict*)
    apply(force)
   apply(rename_tac d e xa nat aa y src trg)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d e xa nat aa y src trg)(*strict*)
    apply(simp add: derivation_drop_def derivation_take_def)
   apply(rename_tac d e xa nat aa y src trg)(*strict*)
   apply(erule meta_impE)
    apply(rename_tac d e xa nat aa y src trg)(*strict*)
    apply(simp add: derivation_drop_def derivation_take_def)
    apply(clarsimp)
   apply(rename_tac d e xa nat aa y src trg)(*strict*)
   apply(rule epdaS_produce_and_eliminate_from_Cons2)
     apply(rename_tac d e xa nat aa y src trg)(*strict*)
     apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def)
    apply(rename_tac d e xa nat aa y src trg)(*strict*)
    apply(force)
   apply(rename_tac d e xa nat aa y src trg)(*strict*)
   apply(force)
    (*push 2*)
  apply(rename_tac d e xa qi A nat e2 c2 a y src trg l r)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e xa qi A nat c2 a y src trg l r qs)(*strict*)
  apply(case_tac l)
   apply(rename_tac d e xa qi A nat c2 a y src trg l r qs)(*strict*)
   prefer 2
   apply(rename_tac d e xa qi A nat c2 a y src trg l r qs aa list)(*strict*)
   apply(clarsimp)
  apply(rename_tac d e xa qi A nat c2 a y src trg l r qs)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e xa nat c2 a y src trg qs)(*strict*)
  apply(case_tac c2)
  apply(rename_tac d e xa nat c2 a y src trg qs cfg_confa)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e xa nat a y src trg qs)(*strict*)
  apply(subgoal_tac "\<lparr>prod_lhs = cons_l2 src y, prod_rhs = [teA (cons_l3   trg a qs), teA (cons_l2   qs y)]\<rparr> \<in> F_SDPDA_TO_CFG_STD__edges_l3 G \<or> \<lparr>prod_lhs = cons_l2 src y, prod_rhs = [teA (cons_l3   trg a qs), teA (cons_l2   qs y)]\<rparr> \<in> F_SDPDA_TO_CFG_STD__edges_l2 G")
   apply(rename_tac d e xa nat a y src trg qs)(*strict*)
   prefer 2
   apply(simp add: F_SDPDA_TO_CFG_STD_def)
  apply(rename_tac d e xa nat a y src trg qs)(*strict*)
  apply(thin_tac "\<lparr>prod_lhs = cons_l2 src y, prod_rhs = [teA (cons_l3   trg a qs), teA (cons_l2   qs y)]\<rparr> \<in> cfg_productions (F_SDPDA_TO_CFG_STD G)")
  apply(rename_tac d e xa nat a y src trg qs)(*strict*)
  apply(erule disjE)
   apply(rename_tac d e xa nat a y src trg qs)(*strict*)
   apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_def)
   apply(erule disjE)
    apply(rename_tac d e xa nat a y src trg qs)(*strict*)
    apply(clarsimp)
    apply(rename_tac d e xa nat a y src trg qs x)(*strict*)
    apply(case_tac "edge_event x")
     apply(rename_tac d e xa nat a y src trg qs x)(*strict*)
     apply(clarsimp)
    apply(rename_tac d e xa nat a y src trg qs x aa)(*strict*)
    apply(clarsimp)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_read_def)
   apply(rename_tac d e xa nat a y src trg qs)(*strict*)
   apply(erule disjE)
    apply(rename_tac d e xa nat a y src trg qs)(*strict*)
    apply(clarsimp)
    apply(rename_tac d e xa nat a y src trg qs x)(*strict*)
    apply(case_tac "edge_push x")
     apply(rename_tac d e xa nat a y src trg qs x)(*strict*)
     apply(clarsimp)
     prefer 2
     apply(rename_tac d e xa nat a y src trg qs x aa list)(*strict*)
     apply(clarsimp)
    apply(rename_tac d e xa nat a y src trg qs x)(*strict*)
    apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_pop_def)
   apply(rename_tac d e xa nat a y src trg qs)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa nat a y src trg qs x)(*strict*)
   apply(case_tac "edge_push x")
    apply(rename_tac d e xa nat a y src trg qs x)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa nat a y src trg qs x aa list)(*strict*)
   apply(clarsimp)
   apply(case_tac "edge_event x")
    apply(rename_tac d e xa nat a y src trg qs x aa list)(*strict*)
    apply(clarsimp)
    prefer 2
    apply(rename_tac d e xa nat a y src trg qs x aa list ab)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa nat a y src trg qs x aa list)(*strict*)
   apply(simp add: F_SDPDA_TO_CFG_STD__edges_l3_push_def)
  apply(rename_tac d e xa nat a y src trg qs)(*strict*)
  apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_def)
  apply(erule disjE)
   apply(rename_tac d e xa nat a y src trg qs)(*strict*)
   apply(clarsimp)
   apply(rename_tac d e xa nat a y src trg qs x)(*strict*)
   apply(case_tac "edge_event x")
    apply(rename_tac d e xa nat a y src trg qs x)(*strict*)
    apply(clarsimp)
   apply(rename_tac d e xa nat a y src trg qs x aa)(*strict*)
   apply(clarsimp)
   apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_read_def)
  apply(rename_tac d e xa nat a y src trg qs)(*strict*)
  apply(erule disjE)
   apply(rename_tac d e xa nat a y src trg qs)(*strict*)
   apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_final_def)
  apply(rename_tac d e xa nat a y src trg qs)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e xa nat a y src trg qs x)(*strict*)
  apply(case_tac "edge_push x")
   apply(rename_tac d e xa nat a y src trg qs x)(*strict*)
   apply(clarsimp)
  apply(rename_tac d e xa nat a y src trg qs x aa list)(*strict*)
  apply(clarsimp)
  apply(case_tac "edge_event x")
   apply(rename_tac d e xa nat a y src trg qs x aa list)(*strict*)
   apply(clarsimp)
   prefer 2
   apply(rename_tac d e xa nat a y src trg qs x aa list ab)(*strict*)
   apply(clarsimp)
  apply(rename_tac d e xa nat a y src trg qs x aa list)(*strict*)
  apply(simp add: F_SDPDA_TO_CFG_STD__edges_l2_push_def)
  apply(clarsimp)
  apply(rename_tac d e xa nat qs x aa list)(*strict*)
  apply(subgoal_tac "\<exists>y. edge_pop x=[y]")
   apply(rename_tac d e xa nat qs x aa list)(*strict*)
   prefer 2
   apply(rule valid_pda_edge_pop_single)
    apply(rename_tac d e xa nat qs x aa list)(*strict*)
    apply(simp add: valid_simple_dpda_def valid_dpda_def)
    apply(force)
   apply(rename_tac d e xa nat qs x aa list)(*strict*)
   apply(force)
  apply(rename_tac d e xa nat qs x aa list)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e xa nat qs x aa list y)(*strict*)
  apply(subgoal_tac "\<exists>z. edge_push x=[z,y]")
   apply(rename_tac d e xa nat qs x aa list y)(*strict*)
   prefer 2
   apply(simp add: valid_simple_dpda_def)
   apply(clarsimp)
   apply(erule_tac
      x="x"
      in ballE)
    apply(rename_tac d e xa nat qs x aa list y)(*strict*)
    prefer 2
    apply(force)
   apply(rename_tac d e xa nat qs x aa list y)(*strict*)
   apply(clarsimp)
  apply(rename_tac d e xa nat qs x aa list y)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e xa nat qs x aa y)(*strict*)
  apply(case_tac x)
  apply(rename_tac d e xa nat qs x aa y edge_srca edge_eventa edge_popa edge_pusha edge_trga)(*strict*)
  apply(clarsimp)
  apply(rename_tac d e xa nat qs aa y edge_src edge_trg)(*strict*)
  apply(rename_tac src trg)
  apply(rename_tac d e xa nat qs aa y src trg)(*strict*)
  apply(subgoal_tac "\<exists>d. cfgRM.derivation (F_SDPDA_TO_CFG_STD G) d \<and> cfgSTD.belongs (F_SDPDA_TO_CFG_STD G) d \<and> d 0 = Some (pair None \<lparr>cfg_conf = [teA (cons_l2   src y)]\<rparr>) \<and> d (Suc nat) = Some (pair e \<lparr>cfg_conf = liftB xa\<rparr>) \<and> d (Suc 0) = Some (pair (Some \<lparr>prod_lhs = cons_l2 src y, prod_rhs = [teA (cons_l3   trg aa qs), teA (cons_l2   qs y)]\<rparr>) \<lparr>cfg_conf = [teA (cons_l3   trg aa qs), teA (cons_l2   qs y)]\<rparr>) \<and> maximum_of_domain d (Suc nat) ")
   apply(rename_tac d e xa nat qs aa y src trg)(*strict*)
   prefer 2
   apply(rule_tac
      x="derivation_take d (Suc nat)"
      in exI)
   apply(rule conjI)
    apply(rename_tac d e xa nat qs aa y src trg)(*strict*)
    apply(rule cfgRM.derivation_take_preserves_derivation)
    apply(force)
   apply(rename_tac d e xa nat qs aa y src trg)(*strict*)
   apply(rule conjI)
    apply(rename_tac d e xa nat qs aa y src trg)(*strict*)
    apply(rule cfgRM.derivation_take_preserves_belongs)
    apply(force)
   apply(rename_tac d e xa nat qs aa y src trg)(*strict*)
   apply(rule conjI)
    apply(rename_tac d e xa nat qs aa y src trg)(*strict*)
    apply(simp add: derivation_take_def)
   apply(rename_tac d e xa nat qs aa y src trg)(*strict*)
   apply(rule conjI)
    apply(rename_tac d e xa nat qs aa y src trg)(*strict*)
    apply(simp add: derivation_take_def)
   apply(rename_tac d e xa nat qs aa y src trg)(*strict*)
   apply(rule conjI)
    apply(rename_tac d e xa nat qs aa y src trg)(*strict*)
    apply(simp add: derivation_take_def)
   apply(rename_tac d e xa nat qs aa y src trg)(*strict*)
   apply(rule maximum_of_domain_derivation_take)
   apply(force)
  apply(rename_tac d e xa nat qs aa y src trg)(*strict*)
  apply(thin_tac "cfgRM.derivation (F_SDPDA_TO_CFG_STD G) d")
  apply(thin_tac " cfgSTD.belongs (F_SDPDA_TO_CFG_STD G) d")
  apply(thin_tac " d 0 = Some (pair None \<lparr>cfg_conf = [teA (cons_l2   src y)]\<rparr>)")
  apply(thin_tac " d (Suc nat) = Some (pair e \<lparr>cfg_conf = liftB xa\<rparr>)")
  apply(thin_tac " d (Suc 0) = Some (pair (Some \<lparr>prod_lhs = cons_l2 src y, prod_rhs = [teA (cons_l3   trg aa qs), teA (cons_l2   qs y)]\<rparr>) \<lparr>cfg_conf = [teA (cons_l3   trg aa qs), teA (cons_l2   qs y)]\<rparr>)")
  apply(rename_tac d e xa nat qs aa y src trg)(*strict*)
  apply(clarsimp)
  apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
  apply(subgoal_tac "\<exists>d1 d2 w1' w2' n1 n2. cfgRM.derivation_from_to (F_SDPDA_TO_CFG_STD G) d1 {pair None \<lparr>cfg_conf = SSw1\<rparr>} {y. \<exists>xa. y = pair xa \<lparr>cfg_conf = w1'\<rparr>} \<and> cfgRM.derivation_from_to (F_SDPDA_TO_CFG_STD G) d2 {pair None \<lparr>cfg_conf = SSw2\<rparr>} {y. \<exists>xa. y = pair xa \<lparr>cfg_conf = w2'\<rparr>} \<and> w1'@w2'=liftB xa \<and> maximum_of_domain d1 n1 \<and> maximum_of_domain d2 n2 \<and> n1+n2=nat" for SSw1 SSw2)
   apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
   prefer 2
   apply(rule_tac
      d="derivation_drop d (Suc 0)"
      and ?w1.0="[teA (cons_l3   trg aa qs)]"
      and ?w2.0="[teA (cons_l2   qs y)]"
      in CFGRM_derivationCanBeDecomposed2)
    apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
    prefer 2
    apply(rule_tac
      t="nat"
      and s="Suc nat - Suc 0"
      in ssubst)
     apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
     apply(force)
    apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
    apply(rule cfgRM.derivation_drop_makes_maximum_of_domain)
      apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
      apply(force)
     apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
     apply(force)
    apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
    apply(force)
   apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
   apply(simp add: cfgRM.derivation_from_to_def cfgRM.derivation_from_def cfgRM.derivation_to_def)
   apply(rule conjI)
    apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
    apply(rule cfgRM.derivation_drop_preserves_derivation)
     apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
     apply(force)
    apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
    apply(force)
   apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
   apply(rule conjI)
    apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
    apply(simp add: derivation_drop_def)
   apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
   apply(rule conjI)
    apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
    apply(rule cfgRM.derivation_drop_preserves_derivation)
     apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
     apply(force)
    apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
    apply(force)
   apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
   apply(rule_tac
      x="nat"
      in exI)
   apply(rule conjI)
    apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
    apply(simp add: derivation_drop_def)
    apply(simp add: maximum_of_domain_def)
   apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
   apply(simp add: derivation_drop_def)
   apply(clarsimp)
  apply(rename_tac e xa nat qs aa y src trg d)(*strict*)
  apply(clarsimp)
  apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2)(*strict*)
  apply(simp add: cfgRM.derivation_from_to_def cfgRM.derivation_from_def cfgRM.derivation_to_def)
  apply(clarsimp)
  apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 n na xaa xab)(*strict*)
  apply(case_tac "d1 0")
   apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 n na xaa xab)(*strict*)
   apply(clarsimp)
  apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 n na xaa xab a)(*strict*)
  apply(clarsimp)
  apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 n na xaa xab)(*strict*)
  apply(case_tac "d2 0")
   apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 n na xaa xab)(*strict*)
   apply(clarsimp)
  apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 n na xaa xab a)(*strict*)
  apply(clarsimp)
  apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 n na xaa xab)(*strict*)
  apply(subgoal_tac "na=n2")
   apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 n na xaa xab)(*strict*)
   prefer 2
   apply(rule_tac
      d="d2"
      in cfgRM.maximum_of_domainUnique)
     apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 n na xaa xab)(*strict*)
     apply(force)
    apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 n na xaa xab)(*strict*)
    apply(force)
   apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 n na xaa xab)(*strict*)
   apply(simp add: maximum_of_domain_def)
  apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 n na xaa xab)(*strict*)
  apply(subgoal_tac "n=n1")
   apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 n na xaa xab)(*strict*)
   prefer 2
   apply(rule_tac
      d="d1"
      in cfgRM.maximum_of_domainUnique)
     apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 n na xaa xab)(*strict*)
     apply(force)
    apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 n na xaa xab)(*strict*)
    apply(force)
   apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 n na xaa xab)(*strict*)
   apply(simp add: maximum_of_domain_def)
  apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 n na xaa xab)(*strict*)
  apply(clarsimp)
  apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 xaa xab)(*strict*)
  apply(subgoal_tac "\<exists>l'. liftB l'=w1'")
   apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 xaa xab)(*strict*)
   prefer 2
   apply(rule_tac
      x="take (length w1') xa"
      in exI)
   apply (metis take_liftB take_append_prime)
  apply(rename_tac e xa qs aa y src trg d d1 d2 w1' w2' n1 n2 xaa xab)(*strict*)
  apply(clarsimp)
  apply(rename_tac e xa qs aa y src trg d d1 d2 w2' n1 n2 xaa xab l')(*strict*)
  apply(subgoal_tac "\<exists>r'. liftB r'=w2'")
  apply(rename_tac e xa qs aa y src trg d d1 d2 w2' n1 n2 xaa xab l')(*strict*)
  prefer 2
  apply(subgoal_tac "drop (length l') (liftB l' @ w2') = drop (length l') (liftB xa)")
  apply(rename_tac e xa qs aa y src trg d d1 d2 w2' n1 n2 xaa xab l')(*strict*)
  apply(rule_tac
    t="drop (length l') (liftB l' @ w2')"
    and s="w2'"
    in ssubst)
   apply(rename_tac e xa qs aa y src trg d d1 d2 w2' n1 n2 xaa xab l')(*strict*)
   apply(rule_tac
    t="length l'"
    and s="length (liftB l')"
    in ssubst)
    apply(rename_tac e xa qs aa y src trg d d1 d2 w2' n1 n2 xaa xab l')(*strict*)
    apply (simp add: liftB_reflects_length)
   apply(rename_tac e xa qs aa y src trg d d1 d2 w2' n1 n2 xaa xab l')
   apply(rule lists_rest.drop_append)
   apply(blast)
  apply(rename_tac e xa qs aa y src trg d d1 d2 w2' n1 n2 xaa xab l')(*strict*)
  apply(rule_tac
    x="drop (length l') xa"
    in exI)
  apply(rule_tac
    t="liftB (drop (length l') xa)"
    and s="drop (length l') (liftB xa)"
    in ssubst)
   apply(rename_tac e xa qs aa y src trg d d1 d2 w2' n1 n2 xaa xab l')(*strict*)
   apply(rule liftB_distributes_over_drop)
  apply(rename_tac e xa qs aa y src trg d d1 d2 w2' n1 n2 xaa xab l')(*strict*)
  apply(rule_tac
    t="w2'"
    and s="drop (length l') (liftB l' @ w2')"
    in ssubst)
   apply(rename_tac e xa qs aa y src trg d d1 d2 w2' n1 n2 xaa xab l')(*strict*)
   apply(rule_tac
    t="length l'"
    and s="length (liftB l')"
    in ssubst)
    apply(rename_tac e xa qs aa y src trg d d1 d2 w2' n1 n2 xaa xab l')(*strict*)
    apply (simp add: liftB_reflects_length)
   apply(rename_tac e xa qs aa y src trg d d1 d2 w2' n1 n2 xaa xab l')(*strict*)
   apply (simp add: liftB_distributes_over_drop liftB_reflects_length drop_append2)
   apply (smt liftB_reflects_length lists_rest.drop_append)
  apply(rename_tac e xa qs aa y src trg d d1 d2 w2' n1 n2 xaa xab l')(*strict*)
  apply(force)
  apply(rename_tac e xa qs aa y src trg d d1 d2 w2' n1 n2 xaa xab l')(*strict*)
  apply(force)
  apply(rename_tac e xa qs aa y src trg d d1 d2 w2' n1 n2 xaa xab l')(*strict*)
  apply(clarsimp)
  apply(rename_tac e xa qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(subgoal_tac "l'@r'=xa")
  apply(rename_tac e xa qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  prefer 2
  apply (metis liftB_commutes_over_concat liftB_inj)
  apply(rename_tac e xa qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(clarsimp)
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(thin_tac "liftB l' @ liftB r' = liftB (l' @ r')")
  apply(erule_tac
    x="n2"
    in meta_allE)
  apply(erule_tac
    x="d2"
    in meta_allE)
  apply(clarsimp)
  apply(erule_tac
    x="xab"
    in meta_allE)
  apply(erule_tac
    x="r'"
    in meta_allE)
  apply(erule_tac
    x="qs"
    in meta_allE)
  apply(erule_tac
    x="y"
    in meta_allE)
  apply(clarsimp)
  apply(erule meta_impE)
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(rule cfgRM.derivation_belongs)
    apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
    apply (metis F_SDPDA_TO_CFG_STD__makes_CFG)
   apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
   apply(force)
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  prefer 2
  apply(force)
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(subgoal_tac "\<lparr>cfg_conf = [teA (cons_l3   trg aa qs), teA (cons_l2   qs y)]\<rparr> \<in> cfg_configurations (F_SDPDA_TO_CFG_STD G)")
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(simp add: cfg_configurations_def)
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(rule cfgRM.belongs_configurations)
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(force)
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(force)
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(subgoal_tac "l' \<in> epdaS_produce_from_before_pop G trg aa qs")
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  prefer 2
  apply(rule_tac
    d="d1"
    and GP="F_SDPDA_TO_CFG_STD G"
    in F_SDPDA_TO_CFG_STD__41_imp_40_hlp)
        apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
        apply(force)
       apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
       apply (metis F_SDPDA_TO_CFG_STD__makes_CFG)
      apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
      apply(simp add: F_SDPDA_TO_CFG_STD_def)
     apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
     apply(simp add: F_SDPDA_TO_CFG_STD_def)
    apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
    prefer 3
    apply(force)
   apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
   prefer 3
   apply(force)
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(force)
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(rule cfgRM.derivation_belongs)
    apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
    apply (metis F_SDPDA_TO_CFG_STD__makes_CFG)
   apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
   apply(force)
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  prefer 2
  apply(force)
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(subgoal_tac "\<lparr>cfg_conf = [teA (cons_l3   trg aa qs), teA (cons_l2   qs y)]\<rparr> \<in> cfg_configurations (F_SDPDA_TO_CFG_STD G)")
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(simp add: cfg_configurations_def)
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(rule cfgRM.belongs_configurations)
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(force)
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(force)
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(rule epdaS_produce_and_eliminate_from_epdaS_produce_from_before_pop_append)
   apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
   apply(force)
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(force)
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(force)
  apply(rename_tac e qs aa y src trg d d1 d2 n1 n2 xaa xab l' r')(*strict*)
  apply(force)
  done

lemma F_SDPDA_TO_CFG_STD__43_imp_42: "
  valid_simple_dpda G
  \<Longrightarrow> GP = F_SDPDA_TO_CFG_STD G
  \<Longrightarrow> cfgRM_produce_and_eliminate_from GP (cons_l2   qi A) \<subseteq> epdaS_produce_and_eliminate_from G qi A"
  apply(simp add: cfgRM_produce_and_eliminate_from_def)
  apply(clarsimp)
  apply(rename_tac x d i e)(*strict*)
  apply(rule F_SDPDA_TO_CFG_STD__43_imp_42_hlp)
      apply(rename_tac x d i e)(*strict*)
      apply(force)+
  done

lemma F_SDPDA_TO_CFG_STD__42_vs_43: "
  valid_simple_dpda G
  \<Longrightarrow> GP = F_SDPDA_TO_CFG_STD G
  \<Longrightarrow> epdaS_produce_and_eliminate_from G qi A = cfgRM_produce_and_eliminate_from GP (cons_l2   qi A)"
  apply(rule order_antisym)
   apply(metis F_SDPDA_TO_CFG_STD__42_imp_43)
  apply(metis F_SDPDA_TO_CFG_STD__43_imp_42)
  done

theorem F_SDPDA_TO_CFG_STD__preserves_lang: "
  valid_simple_dpda G
  \<Longrightarrow> epdaS.marked_language G = cfgRM.marked_language (F_SDPDA_TO_CFG_STD G)"
  apply(rule_tac
      t="epdaS.marked_language G"
      and s="epdaS_produce_and_eliminate_from G (epda_initial G) (epda_box G)"
      in ssubst)
   apply(rule order_antisym)
    apply(simp add: epdaS.marked_language_def epdaS_produce_and_eliminate_from_def)
    apply(clarsimp)
    apply(rename_tac x d)(*strict*)
    apply(rule_tac
      x="d"
      in exI)
    apply(simp add: epdaS_marking_condition_def epdaS_marked_effect_def epdaS_marking_configurations_def)
    apply(clarsimp)
    apply(rename_tac d c i e ca)(*strict*)
    apply(rule_tac
      x="epdaS_conf_state ca"
      in exI)
    apply(clarsimp)
    apply(rule conjI)
     apply(rename_tac d c i e ca)(*strict*)
     apply(rule epdaS.derivation_initial_belongs)
      apply(rename_tac d c i e ca)(*strict*)
      apply(rule valid_pda_to_valid_epda)
      apply(rule valid_dpda_to_valid_pda)
      apply(rule valid_simple_dpda_to_valid_dpda)
      apply(force)
     apply(rename_tac d c i e ca)(*strict*)
     apply(force)
    apply(rename_tac d c i e ca)(*strict*)
    apply(rule_tac
      x="[]"
      in exI)
    apply(subgoal_tac "\<exists>w. epdaS_conf_stack ca = w@[epda_box G]")
     apply(rename_tac d c i e ca)(*strict*)
     prefer 2
     apply(rule valid_epda_preserves_box_at_end)
       apply(rename_tac d c i e ca)(*strict*)
       apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def)
      apply(rename_tac d c i e ca)(*strict*)
      apply(force)
     apply(rename_tac d c i e ca)(*strict*)
     apply(force)
    apply(rename_tac d c i e ca)(*strict*)
    apply(rule conjI)
     apply(rename_tac d c i e ca)(*strict*)
     apply(simp add: epdaS.derivation_initial_def)
     apply(simp add: epdaS_initial_configurations_def)
    apply(rename_tac d c i e ca)(*strict*)
    apply(clarsimp)
    apply(rename_tac d c i e ca w)(*strict*)
    apply(rule_tac
      x="i"
      in exI)
    apply(clarsimp)
    apply(rule conjI)
     apply(rename_tac d c i e ca w)(*strict*)
     apply(rule_tac
      x="butlast(epdaS_conf_stack ca)"
      in exI)
     apply(case_tac ca)
     apply(rename_tac d c i e ca w epdaS_conf_statea epdaS_conf_schedulera epdaS_conf_stacka)(*strict*)
     apply(clarsimp)
    apply(rename_tac d c i e ca w)(*strict*)
    apply(clarsimp)
    apply(rename_tac d c i e ca w k ea cb)(*strict*)
    apply(rule valid_epda_preserves_box_at_end)
      apply(rename_tac d c i e ca w k ea cb)(*strict*)
      apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def)
     apply(rename_tac d c i e ca w k ea cb)(*strict*)
     apply(force)
    apply(rename_tac d c i e ca w k ea cb)(*strict*)
    apply(force)
   apply(simp add: epdaS.marked_language_def epdaS_produce_and_eliminate_from_def)
   apply(clarsimp)
   apply(rename_tac x d qf s j e s')(*strict*)
   apply(subgoal_tac "\<exists>d. epdaS.derivation G d \<and> epdaS.belongs G d \<and> d 0 = Some (pair None \<lparr>epdaS_conf_state = epda_initial G, epdaS_conf_scheduler = x, epdaS_conf_stack = [epda_box G]\<rparr>) \<and> (\<forall>k \<le> j. \<forall>e c. d k = Some (pair e c) \<longrightarrow> (\<exists>w. epdaS_conf_stack c = w @ [epda_box G])) \<and> d j = Some (pair e \<lparr>epdaS_conf_state = qf, epdaS_conf_scheduler = [], epdaS_conf_stack = s' @ [epda_box G]\<rparr>) ")
    apply(rename_tac x d qf s j e s')(*strict*)
    prefer 2
    apply(rule_tac
      x="derivation_map (derivation_take d j) (\<lambda>c. c\<lparr>epdaS_conf_stack := butn (epdaS_conf_stack c) (length s) @ []\<rparr>)"
      in exI)
    apply(rename_tac x d qf s j e s')(*strict*)
    apply(rule context_conjI)
     apply(rename_tac x d qf s j e s')(*strict*)
     apply(rule epdaS_unused_stack_modification_preserves_derivation2)
        apply(rename_tac x d qf s j e s')(*strict*)
        apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def)
       apply(rename_tac x d qf s j e s')(*strict*)
       apply(force)
      apply(rename_tac x d qf s j e s')(*strict*)
      apply(force)
     apply(rename_tac x d qf s j e s')(*strict*)
     apply(force)
    apply(rename_tac x d qf s j e s')(*strict*)
    apply(rule conjI)
     apply(rename_tac x d qf s j e s')(*strict*)
     apply(rule epdaS.derivation_belongs)
        apply(rename_tac x d qf s j e s')(*strict*)
        apply(simp add: valid_simple_dpda_def valid_dpda_def valid_pda_def)
       apply(rename_tac x d qf s j e s')(*strict*)
       apply(simp add: derivation_map_def derivation_take_def)
      apply(rename_tac x d qf s j e s')(*strict*)
      apply(simp add: butn_def)
      apply(subgoal_tac "\<lparr>epdaS_conf_state = epda_initial G, epdaS_conf_scheduler = x, epdaS_conf_stack = epda_box G # s\<rparr> \<in> epdaS_configurations G")
       apply(rename_tac x d qf s j e s')(*strict*)
       apply(simp add: valid_epda_step_label_def epdaS_configurations_def)
      apply(rename_tac x d qf s j e s')(*strict*)
      apply(rule epdaS.belongs_configurations)
       apply(rename_tac x d qf s j e s')(*strict*)
       apply(force)
      apply(rename_tac x d qf s j e s')(*strict*)
      apply(force)
     apply(rename_tac x d qf s j e s')(*strict*)
     apply(force)
    apply(rename_tac x d qf s j e s')(*strict*)
    apply(rule conjI)
     apply(rename_tac x d qf s j e s')(*strict*)
     apply(simp add: derivation_map_def derivation_take_def)
     apply(simp add: butn_def)
    apply(rename_tac x d qf s j e s')(*strict*)
    apply(rule conjI)
     apply(rename_tac x d qf s j e s')(*strict*)
     apply(clarsimp)
     apply(rename_tac x d qf s j e s' k ea c)(*strict*)
     apply(simp add: derivation_map_def derivation_take_def)
     apply(erule_tac
      x="k"
      in allE)
     apply(clarsimp)
     apply(case_tac "d k")
      apply(rename_tac x d qf s j e s' k ea c)(*strict*)
      apply(clarsimp)
     apply(rename_tac x d qf s j e s' k ea c a)(*strict*)
     apply(clarsimp)
     apply(case_tac a)
     apply(rename_tac x d qf s j e s' k ea c a option b)(*strict*)
     apply(clarsimp)
     apply(rename_tac x d qf s j e s' k ea b w)(*strict*)
     apply(simp add: butn_def)
    apply(rename_tac x d qf s j e s')(*strict*)
    apply(simp add: derivation_map_def derivation_take_def)
    apply(simp add: butn_def)
   apply(rename_tac x d qf s j e s')(*strict*)
   apply(thin_tac "epdaS.derivation G d")
   apply(thin_tac " epdaS.belongs G d")
   apply(thin_tac " d 0 = Some (pair None \<lparr>epdaS_conf_state = epda_initial G, epdaS_conf_scheduler = x, epdaS_conf_stack = epda_box G # s\<rparr>)")
   apply(rename_tac x d qf s j e s')(*strict*)
   apply(thin_tac " \<forall>k \<le> j. \<forall>e c. d k = Some (pair e c) \<longrightarrow> (\<exists>w. epdaS_conf_stack c = w @ epda_box G # s)")
   apply(thin_tac " d j = Some (pair e \<lparr>epdaS_conf_state = qf, epdaS_conf_scheduler = [], epdaS_conf_stack = s' @ epda_box G # s\<rparr>)")
   apply(rename_tac x d qf s j e s')(*strict*)
   apply(clarsimp)
   apply(rename_tac x qf j e s' d)(*strict*)
   apply(rule_tac
      x="d"
      in exI)
   apply(rule conjI)
    apply(rename_tac x qf j e s' d)(*strict*)
    apply(simp add: epdaS.derivation_initial_def)
    apply(simp add: epdaS_initial_configurations_def)
    apply(rule epdaS.belongs_configurations)
     apply(rename_tac x qf j e s' d)(*strict*)
     apply(force)
    apply(rename_tac x qf j e s' d)(*strict*)
    apply(force)
   apply(rename_tac x qf j e s' d)(*strict*)
   apply(rule conjI)
    apply(rename_tac x qf j e s' d)(*strict*)
    apply(simp add: epdaS_marked_effect_def)
   apply(rename_tac x qf j e s' d)(*strict*)
   apply(rule conjI)
    apply(rename_tac x qf j e s' d)(*strict*)
    apply(force)
   apply(rename_tac x qf j e s' d)(*strict*)
   apply(simp add: epdaS_marking_condition_def epdaS_marking_configurations_def)
   apply(rule_tac
      x="j"
      in exI)
   apply(clarsimp)
   apply(rule epdaS.belongs_configurations)
    apply(rename_tac x qf j e s' d)(*strict*)
    apply(force)
   apply(rename_tac x qf j e s' d)(*strict*)
   apply(force)
  apply(rule_tac
      t="cfgRM.marked_language (F_SDPDA_TO_CFG_STD G)"
      and s="cfgRM_produce_and_eliminate_from (F_SDPDA_TO_CFG_STD G) (cons_l2   (epda_initial G) (epda_box G))"
      in ssubst)
   apply(rule order_antisym)
    apply(simp add: cfgRM.marked_language_def cfgRM_produce_and_eliminate_from_def)
    apply(clarsimp)
    apply(rename_tac x d)(*strict*)
    apply(rule_tac
      x="d"
      in exI)
    apply(clarsimp)
    apply(rule conjI)
     apply(rename_tac x d)(*strict*)
     apply(rule cfgRM.derivation_initial_belongs)
      apply(rename_tac x d)(*strict*)
      apply (metis F_SDPDA_TO_CFG_STD__makes_CFG)
     apply(rename_tac x d)(*strict*)
     apply(force)
    apply(rename_tac x d)(*strict*)
    apply(rule conjI)
     apply(rename_tac x d)(*strict*)
     apply(simp add: cfgRM.derivation_initial_def)
     apply(case_tac "d 0")
      apply(rename_tac x d)(*strict*)
      apply(clarsimp)
     apply(rename_tac x d a)(*strict*)
     apply(clarsimp)
     apply(case_tac a)
     apply(rename_tac x d a option b)(*strict*)
     apply(clarsimp)
     apply(rename_tac x d b)(*strict*)
     apply(simp add: cfg_initial_configurations_def)
     apply(simp add: F_SDPDA_TO_CFG_STD_def)
    apply(rename_tac x d)(*strict*)
    apply(simp add: cfg_marked_effect_def)
    apply(clarsimp)
    apply(rename_tac x d e c i)(*strict*)
    apply(rule_tac
      x="i"
      in exI)
    apply(clarsimp)
   apply(simp add: cfgRM.marked_language_def cfgRM_produce_and_eliminate_from_def)
   apply(clarsimp)
   apply(rename_tac x d i e)(*strict*)
   apply(rule_tac
      x="d"
      in exI)
   apply(clarsimp)
   apply(rule conjI)
    apply(rename_tac x d i e)(*strict*)
    apply(simp add: cfgRM.derivation_initial_def)
    apply(simp add: cfg_initial_configurations_def)
    apply(rule conjI)
     apply(rename_tac x d i e)(*strict*)
     apply(simp add: F_SDPDA_TO_CFG_STD_def)
    apply(rename_tac x d i e)(*strict*)
    apply(rule cfgRM.belongs_configurations)
     apply(rename_tac x d i e)(*strict*)
     apply(force)
    apply(rename_tac x d i e)(*strict*)
    apply(force)
   apply(rename_tac x d i e)(*strict*)
   apply(rule conjI)
    apply(rename_tac x d i e)(*strict*)
    apply(simp add: cfg_marked_effect_def)
    apply(rule_tac
      x="e"
      in exI)
    apply(rule_tac
      x="\<lparr>cfg_conf = liftB x\<rparr>"
      in exI)
    apply(clarsimp)
    apply(rule conjI)
     apply(rename_tac x d i e)(*strict*)
     apply(force)
    apply(rename_tac x d i e)(*strict*)
    apply (metis setA_liftB)
   apply(rename_tac x d i e)(*strict*)
   apply(simp add: cfg_marking_condition_def)
   apply(rule_tac
      x="i"
      in exI)
   apply(rule_tac
      x="e"
      in exI)
   apply(rule_tac
      x="\<lparr>cfg_conf = liftB x\<rparr>"
      in exI)
   apply(clarsimp)
   apply(simp add: cfg_marking_configuration_def)
   apply(rule conjI)
    apply(rename_tac x d i e)(*strict*)
    apply (metis setA_liftB)
   apply(rename_tac x d i e)(*strict*)
   apply(rule cfgRM.belongs_configurations)
    apply(rename_tac x d i e)(*strict*)
    apply(force)
   apply(rename_tac x d i e)(*strict*)
   apply(force)
  apply(rule F_SDPDA_TO_CFG_STD__42_vs_43)
   apply(force)
  apply(force)
  done

theorem F_SDPDA_TO_CFG_STD__SOUND: "
  F_SDPDA_TO_CFG_STD__SpecInput G
  \<Longrightarrow> F_SDPDA_TO_CFG_STD__SpecOutput G (F_SDPDA_TO_CFG_STD G)"
  apply(simp add: F_SDPDA_TO_CFG_STD__SpecInput_def F_SDPDA_TO_CFG_STD__SpecOutput_def)
  apply(rule conjI)
   apply (metis F_SDPDA_TO_CFG_STD__makes_CFG)
  apply (metis F_SDPDA_TO_CFG_STD__makes_CFG F_SDPDA_TO_CFG_STD__preserves_lang CFG_lang_rm_lang_equal)
  done

end

