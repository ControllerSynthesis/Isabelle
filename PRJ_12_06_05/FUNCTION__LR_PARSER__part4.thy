section {*FUNCTION\_\_LR\_PARSER\_\_part4*}
theory
  FUNCTION__LR_PARSER__part4

imports
  FUNCTION__LR_PARSER__part3

begin

lemma no_shift_shift_conflicts1: "
  AF_LR_PARSER_input G F Do S' G' M P k
  \<Longrightarrow> y \<in> cfgSTD_first G' (k - Suc 0) (\<beta> @ liftB z)
  \<Longrightarrow> ya \<in> cfgSTD_first G' (k - Suc 0) (\<beta>' @ liftB za)
  \<Longrightarrow> \<lparr>prod_lhs = A, prod_rhs = \<alpha> @ teB aa # \<beta>\<rparr> \<in> cfg_productions G
  \<Longrightarrow> \<lparr>prod_lhs = Aa, prod_rhs = \<alpha>' @ teB aa # \<beta>'\<rparr> \<in> cfg_productions G
  \<Longrightarrow> \<lparr>cfg_item_lhs = A, cfg_item_rhs1 = \<alpha>, cfg_item_rhs2 = teB aa # \<beta>, cfg_item_look_ahead = z\<rparr> \<in> valid_item_set G' k (teB Do # \<delta>)
  \<Longrightarrow> \<lparr>cfg_item_lhs = Aa, cfg_item_rhs1 = \<alpha>', cfg_item_rhs2 = teB aa # \<beta>', cfg_item_look_ahead = za\<rparr> \<in> valid_item_set G' k (teB Do # \<delta>')
  \<Longrightarrow> last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>')) = last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>))
  \<Longrightarrow> (aa # y) \<sqsubseteq> (aa # ya)
  \<Longrightarrow> y = ya"
  apply(simp add: prefix_def)
  apply(clarsimp)
  apply(rename_tac c)(*strict*)
  apply(subgoal_tac "valid_cfg G'")
   apply(rename_tac c)(*strict*)
   prefer 2
   apply(rule F_CFG_AUGMENT__makes_CFG)
   apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
   apply(force)
  apply(rename_tac c)(*strict*)
  apply(subgoal_tac "valid_dfa M")
   apply(rename_tac c)(*strict*)
   prefer 2
   apply(rule_tac
      G="G'"
      in Theorem6__27_a)
     apply(rename_tac c)(*strict*)
     apply(force)
    apply(rename_tac c)(*strict*)
    apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(force)
   apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
  apply(rename_tac c)(*strict*)
  apply(subgoal_tac "some_step_from_every_configuration M")
   apply(rename_tac c)(*strict*)
   prefer 2
   apply(rule_tac
      G="G'"
      in F_LR_MACHINE_Complete)
     apply(rename_tac c)(*strict*)
     apply(force)
    apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(force)
   apply(rename_tac c)(*strict*)
   apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
  apply(rename_tac c)(*strict*)
  apply(subgoal_tac "every_state_in_some_accessible_configuration M")
   apply(rename_tac c)(*strict*)
   prefer 2
   apply(rule F_LR_MACHINE_all_Connected)
      apply(rename_tac c)(*strict*)
      prefer 2
      apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
      apply(force)
     apply(rename_tac c)(*strict*)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
   apply(force)
  apply(rename_tac c)(*strict*)
  apply(subgoal_tac "some_step_from_every_configuration M")
   apply(rename_tac c)(*strict*)
   prefer 2
   apply(rule_tac
      G="G'"
      in F_LR_MACHINE_Complete)
     apply(rename_tac c)(*strict*)
     apply(blast)+
    apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(force)
   apply(rename_tac c)(*strict*)
   apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
  apply(rename_tac c)(*strict*)
  apply(subgoal_tac "valid_parser P")
   apply(rename_tac c)(*strict*)
   prefer 2
   apply(rule_tac
      G="G"
      in AF_LR_PARSER_valid_parser)
         apply(rename_tac c)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
        apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
        apply(force)
       apply(rename_tac c)(*strict*)
       apply(force)
      apply(rename_tac c)(*strict*)
      apply(force)
     apply(rename_tac c)(*strict*)
     apply(force)
    apply(rename_tac c)(*strict*)
    apply(force)
   apply(rename_tac c)(*strict*)
   apply(simp add: AF_LR_PARSER_input_def)
  apply(rename_tac c)(*strict*)
  apply(subgoal_tac "set (teB Do # \<delta>') \<subseteq> two_elements_construct_domain (cfg_nonterminals G') (cfg_events G')")
   apply(rename_tac c)(*strict*)
   prefer 2
   apply(rule viable_prefix_in_CFG)
    apply(rename_tac c)(*strict*)
    apply(simp add: AF_LR_PARSER_input_def)
   apply(rename_tac c)(*strict*)
   apply(rule Fact6_12__1)
   apply(force)
  apply(rename_tac c)(*strict*)
  apply(subgoal_tac "set (teB Do # \<delta>) \<subseteq> two_elements_construct_domain (cfg_nonterminals G') (cfg_events G')")
   apply(rename_tac c)(*strict*)
   prefer 2
   apply(rule viable_prefix_in_CFG)
    apply(rename_tac c)(*strict*)
    apply(simp add: AF_LR_PARSER_input_def)
   apply(rename_tac c)(*strict*)
   apply(rule Fact6_12__1)
   apply(force)
  apply(rename_tac c)(*strict*)
  apply(subgoal_tac "\<lparr>cfg_item_lhs = A, cfg_item_rhs1 = \<alpha>, cfg_item_rhs2 = teB aa # \<beta>, cfg_item_look_ahead = z\<rparr> \<in> valid_item_set G' k (teB Do # \<delta>')")
   apply(rename_tac c)(*strict*)
   prefer 2
   apply(subgoal_tac "valid_item_set G' k (teB Do # \<delta>') = (if (teB Do # \<delta>')=[] then (epda_initial M) else last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>')))")
    apply(rename_tac c)(*strict*)
    prefer 2
    apply(rule F_LR_MACHINE_all_SOUND)
          apply(rename_tac c)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(rename_tac c)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
         apply(force)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(force)
      apply(rename_tac c)(*strict*)
      apply(simp add: AF_LR_PARSER_input_def)
     apply(rename_tac c)(*strict*)
     apply(simp add: AF_LR_PARSER_input_def)
     apply(rename_tac c)(*strict*)
     prefer 2
     apply (metis two_elements_construct_domain_setB)
    apply(rename_tac c)(*strict*)
    apply (metis two_elements_construct_domain_setA)
   apply(rename_tac c)(*strict*)
   apply(subgoal_tac "valid_item_set G' k (teB Do # \<delta>) = (if (teB Do # \<delta>)=[] then (epda_initial M) else last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>)))")
    apply(rename_tac c)(*strict*)
    prefer 2
    apply(rule F_LR_MACHINE_all_SOUND)
          apply(rename_tac c)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(simp add: AF_LR_PARSER_input_def)
         apply(force)
        apply(rename_tac c)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(rename_tac c)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(rename_tac c)(*strict*)
      apply(simp add: AF_LR_PARSER_input_def)
     apply(rename_tac c)(*strict*)
     prefer 2
     apply (metis two_elements_construct_domain_setB)
    apply(rename_tac c)(*strict*)
    apply (metis two_elements_construct_domain_setA)
   apply(rename_tac c)(*strict*)
   apply(force)
  apply(rename_tac c)(*strict*)
  apply(thin_tac "last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>')) = last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>))")
  apply(rename_tac c)(*strict*)
  apply(thin_tac "\<lparr>cfg_item_lhs = A, cfg_item_rhs1 = \<alpha>, cfg_item_rhs2 = teB aa # \<beta>, cfg_item_look_ahead = z\<rparr> \<in> valid_item_set G' k (teB Do # \<delta>)")
  apply(rename_tac c)(*strict*)
  apply(thin_tac "set (teB Do # \<delta>) \<subseteq> two_elements_construct_domain (cfg_nonterminals G') (cfg_events G')")
  apply(subgoal_tac "length y \<le> (k-Suc 0)")
   apply(rename_tac c)(*strict*)
   prefer 2
   apply(rule cfgSTD_firstk_shorter_than_k)
   apply(force)
  apply(rename_tac c)(*strict*)
  apply(subgoal_tac "length (y@c) \<le> (k-Suc 0)")
   apply(rename_tac c)(*strict*)
   prefer 2
   apply(rule cfgSTD_firstk_shorter_than_k)
   apply(force)
  apply(rename_tac c)(*strict*)
  apply(case_tac "length y < k - Suc 0")
   apply(rename_tac c)(*strict*)
   prefer 2
   apply(clarsimp)
  apply(rename_tac c)(*strict*)
  apply(subgoal_tac "suffix y z")
   apply(rename_tac c)(*strict*)
   prefer 2
   apply(rule cfgSTD_first_suffix_is_shorter)
     apply(rename_tac c)(*strict*)
     apply(force)
    apply(rename_tac c)(*strict*)
    apply(force)
   apply(rename_tac c)(*strict*)
   apply(force)
  apply(rename_tac c)(*strict*)
  apply(subgoal_tac "length z < k - Suc 0")
   apply(rename_tac c)(*strict*)
   prefer 2
   apply(simp add: suffix_def)
   apply(clarsimp)
  apply(rename_tac c)(*strict*)
  apply(simp add: valid_item_set_def valid_item_set_n_def)
  apply(clarsimp)
  apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
  apply(subgoal_tac "d (Suc 0)= Some (pair (Some \<lparr>prod_lhs=cfg_initial G',prod_rhs=[teB Do,teA (cfg_initial G),teB Do]\<rparr>) \<lparr>cfg_conf=[teB Do,teA (cfg_initial G),teB Do]\<rparr>)")
   apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
   prefer 2
   apply(rule F_CFG_AUGMENT__FirstStep)
          apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
        apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
      apply(force)
     apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
     apply (metis cfgRM_derivations_are_cfg_derivations)
    apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
    apply(force)
   apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
   apply(force)
  apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
  apply(subgoal_tac "da (Suc 0)= Some (pair (Some \<lparr>prod_lhs=cfg_initial G',prod_rhs=[teB Do,teA (cfg_initial G),teB Do]\<rparr>) \<lparr>cfg_conf=[teB Do,teA (cfg_initial G),teB Do]\<rparr>)")
   apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
   prefer 2
   apply(rule F_CFG_AUGMENT__FirstStep)
          apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
        apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
      apply(force)
     apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
     apply (metis cfgRM_derivations_are_cfg_derivations)
    apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
    apply(force)
   apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
   apply(force)
  apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
  apply(subgoal_tac "aa \<noteq> Do")
   apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
   prefer 2
   apply(subgoal_tac "aa \<in> cfg_events G")
    apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
    apply(subgoal_tac "Do \<notin> cfg_events G")
     apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
     apply(force)
    apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
    apply(simp add: AF_LR_PARSER_input_def F_CFG_AUGMENT_def)
    apply(clarsimp)
    apply(subgoal_tac "F_FRESH (cfg_events G) \<notin> cfg_events G")
     apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
     apply(force)
    apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
    apply(rule F_FRESH_is_fresh)
    apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def valid_cfg_def)
   apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
   apply(simp add: AF_LR_PARSER_input_def valid_cfg_def)
   apply(erule conjE)+
   apply(erule_tac
      x="\<lparr>prod_lhs = A, prod_rhs = \<alpha> @ teB aa # \<beta>\<rparr>"
      and A="cfg_productions G"
      in ballE)
    apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
    prefer 2
    apply(force)
   apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
   apply(clarsimp)
   apply (metis elemInsetB set_mp_prime)
  apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
  apply(case_tac n)
   apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa)(*strict*)
   apply(clarsimp)
   apply(rename_tac c na d da \<delta> zb \<delta>'a e1a e2a zaa)(*strict*)
   apply(case_tac "\<delta>")
    apply(rename_tac c na d da \<delta> zb \<delta>'a e1a e2a zaa)(*strict*)
    apply(clarsimp)
    apply(rename_tac c na d da \<delta>'a e1a e2a zaa)(*strict*)
    apply(case_tac "\<delta>'a")
     apply(rename_tac c na d da \<delta>'a e1a e2a zaa)(*strict*)
     apply(clarsimp)
     apply(rename_tac c na d da e1a e2a zaa)(*strict*)
     apply(case_tac "\<delta>'")
      apply(rename_tac c na d da e1a e2a zaa)(*strict*)
      apply(clarsimp)
     apply(rename_tac c na d da e1a e2a zaa a list)(*strict*)
     apply(clarsimp)
     apply(rename_tac c na d da e1a e2a zaa list)(*strict*)
     apply(case_tac list)
      apply(rename_tac c na d da e1a e2a zaa list)(*strict*)
      apply(clarsimp)
     apply(rename_tac c na d da e1a e2a zaa list a lista)(*strict*)
     apply(clarsimp)
    apply(rename_tac c na d da \<delta>'a e1a e2a zaa a list)(*strict*)
    apply(clarsimp)
    apply(rename_tac c na d da e1a e2a zaa list)(*strict*)
    apply(case_tac list)
     apply(rename_tac c na d da e1a e2a zaa list)(*strict*)
     apply(clarsimp)
     apply(rename_tac c na d da e1a e2a zaa)(*strict*)
     apply(case_tac "\<alpha>")
      apply(rename_tac c na d da e1a e2a zaa)(*strict*)
      apply(clarsimp)
     apply(rename_tac c na d da e1a e2a zaa a list)(*strict*)
     apply(clarsimp)
     apply(rename_tac c na d da e1a e2a zaa list)(*strict*)
     apply(case_tac list)
      apply(rename_tac c na d da e1a e2a zaa list)(*strict*)
      apply(clarsimp)
     apply(rename_tac c na d da e1a e2a zaa list a lista)(*strict*)
     apply(clarsimp)
    apply(rename_tac c na d da e1a e2a zaa list a lista)(*strict*)
    apply(clarsimp)
    apply(rename_tac c na d da e1a e2a zaa lista)(*strict*)
    apply(case_tac lista)
     apply(rename_tac c na d da e1a e2a zaa lista)(*strict*)
     apply(clarsimp)
     apply(rename_tac c na d da e1a e2a zaa)(*strict*)
     apply(case_tac "\<alpha>")
      apply(rename_tac c na d da e1a e2a zaa)(*strict*)
      apply(clarsimp)
     apply(rename_tac c na d da e1a e2a zaa a list)(*strict*)
     apply(clarsimp)
    apply(rename_tac c na d da e1a e2a zaa lista a list)(*strict*)
    apply(clarsimp)
   apply(rename_tac c na d da \<delta> zb \<delta>'a e1a e2a zaa a list)(*strict*)
   apply(clarsimp)
  apply(rename_tac c n na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat)(*strict*)
  apply(clarsimp)
  apply(rename_tac c na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat)(*strict*)
  apply(case_tac na)
   apply(rename_tac c na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat)(*strict*)
   apply(clarsimp)
   apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a zaa nat)(*strict*)
   apply(case_tac "\<delta>'a")
    apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a zaa nat)(*strict*)
    apply(clarsimp)
    apply(rename_tac c d da \<delta> e1 e2 zb nat)(*strict*)
    apply(case_tac "\<delta>")
     apply(rename_tac c d da \<delta> e1 e2 zb nat)(*strict*)
     apply(clarsimp)
     apply(rename_tac c d da e1 e2 zb nat)(*strict*)
     apply(case_tac "\<delta>'")
      apply(rename_tac c d da e1 e2 zb nat)(*strict*)
      apply(clarsimp)
     apply(rename_tac c d da e1 e2 zb nat a list)(*strict*)
     apply(clarsimp)
     apply(rename_tac c d da e1 e2 zb nat list)(*strict*)
     apply(case_tac list)
      apply(rename_tac c d da e1 e2 zb nat list)(*strict*)
      apply(clarsimp)
     apply(rename_tac c d da e1 e2 zb nat list a lista)(*strict*)
     apply(clarsimp)
    apply(rename_tac c d da \<delta> e1 e2 zb nat a list)(*strict*)
    apply(clarsimp)
    apply(rename_tac c d da e1 e2 zb nat list)(*strict*)
    apply(case_tac list)
     apply(rename_tac c d da e1 e2 zb nat list)(*strict*)
     apply(clarsimp)
     apply(rename_tac c d da e1 e2 zb nat)(*strict*)
     apply(case_tac "\<alpha>'")
      apply(rename_tac c d da e1 e2 zb nat)(*strict*)
      apply(clarsimp)
     apply(rename_tac c d da e1 e2 zb nat a list)(*strict*)
     apply(clarsimp)
     apply(rename_tac c d da e1 e2 zb nat list)(*strict*)
     apply(case_tac list)
      apply(rename_tac c d da e1 e2 zb nat list)(*strict*)
      apply(clarsimp)
     apply(rename_tac c d da e1 e2 zb nat list a lista)(*strict*)
     apply(clarsimp)
    apply(rename_tac c d da e1 e2 zb nat list a lista)(*strict*)
    apply(clarsimp)
    apply(rename_tac c d da e1 e2 zb nat lista)(*strict*)
    apply(case_tac lista)
     apply(rename_tac c d da e1 e2 zb nat lista)(*strict*)
     apply(clarsimp)
     apply(rename_tac c d da e1 e2 zb nat)(*strict*)
     apply(case_tac "\<alpha>'")
      apply(rename_tac c d da e1 e2 zb nat)(*strict*)
      apply(clarsimp)
     apply(rename_tac c d da e1 e2 zb nat a list)(*strict*)
     apply(clarsimp)
    apply(rename_tac c d da e1 e2 zb nat lista a list)(*strict*)
    apply(clarsimp)
   apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a zaa nat a list)(*strict*)
   apply(clarsimp)
  apply(rename_tac c na d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat nata)(*strict*)
  apply(clarsimp)
  apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat nata)(*strict*)
  apply(subgoal_tac "\<exists>w. set w \<subseteq> two_elements_construct_domain (cfg_nonterminals G) (cfg_events G) \<and> cfg_conf SSc=[teB Do]@w@[teB Do]" for SSc)
   apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat nata)(*strict*)
   prefer 2
   apply(rule_tac
      d="d"
      and i="nat"
      in F_CFG_AUGMENT__reachableConf_of_certain_form)
     apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat nata)(*strict*)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat nata)(*strict*)
    apply(rule cfgSTD.derivation_initialI)
     apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat nata)(*strict*)
     apply(rule cfgRM_derivations_are_cfg_derivations)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat nata)(*strict*)
    apply(simp add: cfg_initial_configurations_def get_configuration_def cfg_configurations_def valid_cfg_def)
    apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
   apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat nata)(*strict*)
   apply(force)
  apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat nata)(*strict*)
  apply(subgoal_tac "\<exists>w. set w \<subseteq> two_elements_construct_domain (cfg_nonterminals G) (cfg_events G) \<and> cfg_conf SSc=[teB Do]@w@[teB Do]" for SSc)
   apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat nata)(*strict*)
   prefer 2
   apply(rule_tac
      d="da"
      and i="nata"
      in F_CFG_AUGMENT__reachableConf_of_certain_form)
     apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat nata)(*strict*)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat nata)(*strict*)
    apply(rule cfgSTD.derivation_initialI)
     apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat nata)(*strict*)
     apply(rule cfgRM_derivations_are_cfg_derivations)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat nata)(*strict*)
    apply(simp add: cfg_initial_configurations_def get_configuration_def cfg_configurations_def valid_cfg_def)
    apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
   apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat nata)(*strict*)
   apply(force)
  apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat nata)(*strict*)
  apply(clarsimp)
  apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat nata w wa)(*strict*)
  apply(case_tac "\<delta>")
   apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat nata w wa)(*strict*)
   apply(clarsimp)
  apply(rename_tac c d da \<delta> e1 e2 zb \<delta>'a e1a e2a zaa nat nata w wa a list)(*strict*)
  apply(clarsimp)
  apply(rename_tac c d da e1 e2 zb \<delta>' e1a e2a zaa nat nata w wa list)(*strict*)
  apply(rename_tac w1)
  apply(rename_tac c d da e1 e2 zb \<delta>' e1a e2a zaa nat nata w wa w1)(*strict*)
  apply(case_tac "\<delta>'")
   apply(rename_tac c d da e1 e2 zb \<delta>' e1a e2a zaa nat nata w wa w1)(*strict*)
   apply(clarsimp)
  apply(rename_tac c d da e1 e2 zb \<delta>' e1a e2a zaa nat nata w wa w1 a list)(*strict*)
  apply(clarsimp)
  apply(rename_tac c d da e1 e2 zb e1a e2a zaa nat nata w wa w1 list)(*strict*)
  apply(rename_tac w2)
  apply(rename_tac c d da e1 e2 zb e1a e2a zaa nat nata w wa w1 w2)(*strict*)
  apply(case_tac zb)
   apply(rename_tac c d da e1 e2 zb e1a e2a zaa nat nata w wa w1 w2)(*strict*)
   apply(clarsimp)
  apply(rename_tac c d da e1 e2 zb e1a e2a zaa nat nata w wa w1 w2 a list)(*strict*)
  apply(subgoal_tac "\<exists>w' x'. zb = w' @ [x']")
   apply(rename_tac c d da e1 e2 zb e1a e2a zaa nat nata w wa w1 w2 a list)(*strict*)
   prefer 2
   apply(rule NonEmptyListHasTailElem)
   apply(force)
  apply(rename_tac c d da e1 e2 zb e1a e2a zaa nat nata w wa w1 w2 a list)(*strict*)
  apply(thin_tac "zb=a#list")
  apply(clarsimp)
  apply(rename_tac c d da e1 e2 e1a e2a zaa nat nata wa w1 w2 w')(*strict*)
  apply(rename_tac w3)
  apply(rename_tac c d da e1 e2 e1a e2a zaa nat nata wa w1 w2 w3)(*strict*)
  apply(case_tac zaa)
   apply(rename_tac c d da e1 e2 e1a e2a zaa nat nata wa w1 w2 w3)(*strict*)
   apply(clarsimp)
  apply(rename_tac c d da e1 e2 e1a e2a zaa nat nata wa w1 w2 w3 a list)(*strict*)
  apply(subgoal_tac "\<exists>w' x'. zaa = w' @ [x']")
   apply(rename_tac c d da e1 e2 e1a e2a zaa nat nata wa w1 w2 w3 a list)(*strict*)
   prefer 2
   apply(rule NonEmptyListHasTailElem)
   apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a zaa nat nata wa w1 w2 w3 a list)(*strict*)
  apply(thin_tac "zaa=a#list")
  apply(clarsimp)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 w')(*strict*)
  apply(rename_tac w4)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 w4)(*strict*)
  apply(simp add: suffix_def)
  apply(clarsimp)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 w4 ca)(*strict*)
  apply(case_tac "k - length w4")
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 w4 ca)(*strict*)
   apply(clarsimp)
   apply (metis Nat.add_0_right liftB_reflects_length add_Suc diff_is_0_eq' le_refl less_diff_conv add.commute not_less0 take_all_length)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 w4 ca natb)(*strict*)
  apply(clarsimp)
  apply(subgoal_tac "\<exists>y. z = y@[Do]")
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 w4 ca natb)(*strict*)
   prefer 2
   apply(case_tac "z")
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 w4 ca natb)(*strict*)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 w4 ca natb a list)(*strict*)
   apply(subgoal_tac "\<exists>w' x'. z = w' @ [x']")
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 w4 ca natb a list)(*strict*)
    prefer 2
    apply(rule NonEmptyListHasTailElem)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 w4 ca natb a list)(*strict*)
   apply(thin_tac "z=a#list")
   apply(clarsimp)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 w4 ca natb w' x')(*strict*)
   apply(rule liftB_terminal_tail_equals)
   apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 w4 ca natb)(*strict*)
  apply(clarsimp)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 w4 ca natb y)(*strict*)
  apply(subgoal_tac "w4=liftB y")
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 w4 ca natb y)(*strict*)
   prefer 2
   apply(rule liftB_terminal_butlast_equals)
   apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 w4 ca natb y)(*strict*)
  apply(clarsimp)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y)(*strict*)
  apply(thin_tac "liftB y @ [teB Do] = liftB (y @ [Do])")
  apply(case_tac "k - length w3")
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y)(*strict*)
   prefer 2
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc)(*strict*)
   apply(clarsimp)
   apply(thin_tac "ca @ y @ [Do] \<in> cfgSTD_first G' (k - Suc 0) (\<beta> @ liftB (y @ [Do]))")
   apply(simp add: cfgSTD_first_def)
   apply(clarsimp)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc x db e1b n)(*strict*)
   apply(subgoal_tac "suffix x za")
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc x db e1b n)(*strict*)
    prefer 2
    apply(rule liftB_creates_suffix)
    apply(subgoal_tac "\<exists>d' e. cfgRM.derivation G' d' \<and> maximum_of_domain d' n \<and> d' 0 = Some (pair None \<lparr>cfg_conf=\<beta>' @ liftB za\<rparr>) \<and> d' n = Some (pair e \<lparr>cfg_conf=liftB x\<rparr>)")
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc x db e1b n)(*strict*)
     prefer 2
     apply(rule_tac
      d="db"
      in cfg_derivation_can_be_translated_to_cfgRM_derivation)
          apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc x db e1b n)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc x db e1b n)(*strict*)
         apply(force)
        apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc x db e1b n)(*strict*)
        apply(simp add: maximum_of_domain_def)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc x db e1b n)(*strict*)
       apply(force)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc x db e1b n)(*strict*)
      apply(force)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc x db e1b n)(*strict*)
     apply (metis setA_liftB)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc x db e1b n)(*strict*)
    apply(clarsimp)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc x db e1b n d' e)(*strict*)
    apply(rule_tac
      d="d'"
      and i="0"
      and j="n"
      in CFGRM_terminals_stay_at_end)
         apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc x db e1b n d' e)(*strict*)
         apply(force)
        apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc x db e1b n d' e)(*strict*)
        apply(force)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc x db e1b n d' e)(*strict*)
       apply (metis setA_liftB)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc x db e1b n d' e)(*strict*)
      apply(force)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc x db e1b n d' e)(*strict*)
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc x db e1b n d' e)(*strict*)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc x db e1b n)(*strict*)
   apply(simp add: suffix_def)
   apply(clarsimp)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
   apply(case_tac "(k - Suc (length cb))")
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
    apply(clarsimp)
    apply(subgoal_tac "set cb \<subseteq> cfg_events G")
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
     apply(subgoal_tac "Do \<in> set cb")
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
      apply(subgoal_tac "Do \<notin> set cb")
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
       apply(force)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
      apply(rule_tac
      B="cfg_events G"
      in nset_mp)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
       apply(force)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
      apply(simp add: AF_LR_PARSER_input_def two_elements_construct_domain_def)
      apply(clarsimp)
      apply(subgoal_tac "F_FRESH (cfg_events G) \<notin> cfg_events G")
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
       apply(force)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
      apply(rule F_FRESH_is_fresh)
      apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def valid_cfg_def)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
     apply(rule_tac
      A="set(take (k - Suc 0) cb)"
      in set_mp)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
      apply(rule List.set_take_subset)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
     apply(rule_tac
      t="take (k - Suc 0) cb"
      and s="ca @ y @ Do # c"
      in ssubst)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
      apply(force)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
     apply(simp (no_asm))
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
    apply(rule liftB_in_two_elements_construct_domain_to_subset)
    apply(subgoal_tac "\<exists>v. set v \<subseteq> two_elements_construct_domain (cfg_nonterminals G) (cfg_events G) \<and> (case e1b of None \<Rightarrow> True|Some e' \<Rightarrow> e' \<in> cfg_productions G) \<and> SSc=\<lparr>cfg_conf = v @ liftB za\<rparr>" for SSc)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
     prefer 2
     apply(rule_tac
      n="n"
      and d="db"
      in CFG_preserves_partial_belongs)
          apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
         prefer 2
         apply(force)
        apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
        prefer 2
        apply(force)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
       apply(rule_tac
      B="set (\<alpha>' @ teB aa # \<beta>')"
      in subset_trans)
        apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
        apply(force)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
       apply(rule SetxBiElem_check_vs_set_two_elements_construct_domain_check)
        apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
        apply(rule prod_rhs_in_cfg_events)
         apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
         apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def)
        apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
        apply(force)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
       apply(rule prod_rhs_in_nonterms)
        apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
        apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
       apply(force)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb p)(*strict*)
      apply(simp add: AF_LR_PARSER_input_def F_CFG_AUGMENT_def)
      apply(clarsimp)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
      apply(subgoal_tac "F_FRESH (cfg_nonterminals G) \<notin> cfg_nonterminals G")
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
       apply(force)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
      apply(rule F_FRESH_is_fresh)
      apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def valid_cfg_def)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb)(*strict*)
    apply(erule exE)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb v)(*strict*)
    apply(erule conjE)+
    apply(subgoal_tac "v=liftB cb")
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb v)(*strict*)
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb v)(*strict*)
    apply(clarsimp)
    apply(simp add: liftB_commutes_over_concat)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
   apply(clarsimp)
   apply(subgoal_tac "prefix (ca @ y @ [Do]) cb \<or> prefix cb (ca @ y @ [Do])")
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
    prefer 2
    apply(rule mutual_prefix_prefix)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
   apply(erule disjE)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
    apply(subgoal_tac "set cb \<subseteq> cfg_events G")
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
     apply(subgoal_tac "Do \<in> set cb")
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
      apply(subgoal_tac "Do \<notin> set cb")
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
       apply(force)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
      apply(rule_tac
      B="cfg_events G"
      in nset_mp)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
       apply(force)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
      apply(simp add: AF_LR_PARSER_input_def two_elements_construct_domain_def)
      apply(clarsimp)
      apply(subgoal_tac "F_FRESH (cfg_events G) \<notin> cfg_events G")
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
       apply(force)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
      apply(rule F_FRESH_is_fresh)
      apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def valid_cfg_def)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
     apply(simp add: prefix_def)
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
    apply(rule liftB_in_two_elements_construct_domain_to_subset)
    apply(subgoal_tac "\<exists>v. set v \<subseteq> two_elements_construct_domain (cfg_nonterminals G) (cfg_events G) \<and> (case e1b of None \<Rightarrow> True|Some e' \<Rightarrow> e' \<in> cfg_productions G) \<and> SSc=\<lparr>cfg_conf = v @ liftB za\<rparr>" for SSc)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
     prefer 2
     apply(rule_tac
      n="n"
      and d="db"
      in CFG_preserves_partial_belongs)
          apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
         prefer 2
         apply(force)
        apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
        prefer 2
        apply(force)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
       apply(rule_tac
      B="set (\<alpha>' @ teB aa # \<beta>')"
      in subset_trans)
        apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
        apply(force)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
       apply(rule SetxBiElem_check_vs_set_two_elements_construct_domain_check)
        apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
        apply(rule prod_rhs_in_cfg_events)
         apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
         apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def)
        apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
        apply(force)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
       apply(rule prod_rhs_in_nonterms)
        apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
        apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
       apply(force)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd p)(*strict*)
      apply(simp add: AF_LR_PARSER_input_def F_CFG_AUGMENT_def)
      apply(clarsimp)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
      apply(subgoal_tac "F_FRESH (cfg_nonterminals G) \<notin> cfg_nonterminals G")
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
       apply(force)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
      apply(rule F_FRESH_is_fresh)
      apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def valid_cfg_def)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
    apply(erule exE)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd v)(*strict*)
    apply(erule conjE)+
    apply(subgoal_tac "v=liftB cb")
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd v)(*strict*)
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd v)(*strict*)
    apply(clarsimp)
    apply(simp add: liftB_commutes_over_concat)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd)(*strict*)
   apply(simp add: prefix_def)
   apply(clarsimp)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
   apply(case_tac cc)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
    apply(subgoal_tac "set cb \<subseteq> cfg_events G")
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
     apply(subgoal_tac "Do \<in> set cb")
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
      apply(subgoal_tac "Do \<notin> set cb")
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
       apply(force)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
      apply(rule_tac
      B="cfg_events G"
      in nset_mp)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
       apply(force)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
      apply(simp add: AF_LR_PARSER_input_def two_elements_construct_domain_def)
      apply(clarsimp)
      apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n natd)(*strict*)
      apply(subgoal_tac "F_FRESH (cfg_events G) \<notin> cfg_events G")
       apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n natd)(*strict*)
       apply(force)
      apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n natd)(*strict*)
      apply(rule F_FRESH_is_fresh)
      apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def valid_cfg_def)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
    apply(rule liftB_in_two_elements_construct_domain_to_subset)
    apply(subgoal_tac "\<exists>v. set v \<subseteq> two_elements_construct_domain (cfg_nonterminals G) (cfg_events G) \<and> (case e1b of None \<Rightarrow> True|Some e' \<Rightarrow> e' \<in> cfg_productions G) \<and> SSc=\<lparr>cfg_conf = v @ liftB za\<rparr>" for SSc)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
     prefer 2
     apply(rule_tac
      n="n"
      and d="db"
      in CFG_preserves_partial_belongs)
          apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
         prefer 2
         apply(force)
        apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
        prefer 2
        apply(force)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
       apply(rule_tac
      B="set (\<alpha>' @ teB aa # \<beta>')"
      in subset_trans)
        apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
        apply(force)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
       apply(rule SetxBiElem_check_vs_set_two_elements_construct_domain_check)
        apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
        apply(rule prod_rhs_in_cfg_events)
         apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
         apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def)
        apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
        apply(force)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
       apply(rule prod_rhs_in_nonterms)
        apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
        apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
       apply(force)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc p)(*strict*)
      apply(simp add: AF_LR_PARSER_input_def F_CFG_AUGMENT_def)
      apply(clarsimp)
      apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n natd)(*strict*)
      apply(subgoal_tac "F_FRESH (cfg_nonterminals G) \<notin> cfg_nonterminals G")
       apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n natd)(*strict*)
       apply(force)
      apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n natd)(*strict*)
      apply(rule F_FRESH_is_fresh)
      apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def valid_cfg_def)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc)(*strict*)
    apply(erule exE)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc v)(*strict*)
    apply(erule conjE)+
    apply(subgoal_tac "v=liftB cb")
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc v)(*strict*)
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc v)(*strict*)
    apply(clarsimp)
    apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n natd v)(*strict*)
    apply(simp add: liftB_commutes_over_concat)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc a list)(*strict*)
   apply(subgoal_tac "\<exists>w' x'. cc = w' @ [x']")
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc a list)(*strict*)
    prefer 2
    apply(rule NonEmptyListHasTailElem)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd cc a list)(*strict*)
   apply(thin_tac "cc=a#list")
   apply(clarsimp)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd w')(*strict*)
   apply(subgoal_tac "take (Suc natd) za = w'@Do#c")
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd w')(*strict*)
    prefer 2
    apply(rule sym)
    apply(rule_tac
      w="cb"
      in append_linj)
    apply(metis concat_asso)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd w')(*strict*)
   apply(clarsimp)
   apply(case_tac za)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd w')(*strict*)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd w' a list)(*strict*)
   apply(subgoal_tac "\<exists>w' x'. za = w' @ [x']")
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd w' a list)(*strict*)
    prefer 2
    apply(rule NonEmptyListHasTailElem)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd w' a list)(*strict*)
   apply(thin_tac "za=a#list")
   apply(clarsimp)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd w' w'a x')(*strict*)
   apply(subgoal_tac "w3=liftB w'a")
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd w' w'a x')(*strict*)
    apply(subgoal_tac "Do=x'")
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd w' w'a x')(*strict*)
     apply(clarsimp)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 ca natb y natc db e1b n cb natd w' w'a)(*strict*)
     apply(case_tac c)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 ca natb y natc db e1b n cb natd w' w'a)(*strict*)
      apply(force)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 ca natb y natc db e1b n cb natd w' w'a a list)(*strict*)
     apply(subgoal_tac "\<exists>w' x'. c = w' @ [x']")
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 ca natb y natc db e1b n cb natd w' w'a a list)(*strict*)
      prefer 2
      apply(rule NonEmptyListHasTailElem)
      apply(force)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 ca natb y natc db e1b n cb natd w' w'a a list)(*strict*)
     apply(thin_tac "c=a#list")
     apply(clarsimp)
     apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 ca natb y natc db e1b n cb natd w' w'a w'b x')(*strict*)
     apply(subgoal_tac "teB Do \<in> set (liftB w'a)")
      apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 ca natb y natc db e1b n cb natd w' w'a w'b x')(*strict*)
      apply(subgoal_tac "teB Do \<notin> set (liftB w'a)")
       apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 ca natb y natc db e1b n cb natd w' w'a w'b x')(*strict*)
       apply(force)
      apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 ca natb y natc db e1b n cb natd w' w'a w'b x')(*strict*)
      apply(thin_tac "teB Do \<in> set (liftB w'a)")
      apply(rule_tac
      B="two_elements_construct_domain (cfg_nonterminals G) (cfg_events G)"
      in nset_mp)
       apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 ca natb y natc db e1b n cb natd w' w'a w'b x')(*strict*)
       apply(force)
      apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 ca natb y natc db e1b n cb natd w' w'a w'b x')(*strict*)
      apply(simp add: two_elements_construct_domain_def AF_LR_PARSER_input_def)
      apply(subgoal_tac "F_FRESH (cfg_events G) \<notin> cfg_events G")
       apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 ca natb y natc db e1b n cb natd w' w'a w'b x')(*strict*)
       apply(force)
      apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 ca natb y natc db e1b n cb natd w' w'a w'b x')(*strict*)
      apply(rule F_FRESH_is_fresh)
      apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def valid_cfg_def)
     apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 ca natb y natc db e1b n cb natd w' w'a w'b x')(*strict*)
     apply(case_tac "Suc natd - length w'a")
      apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 ca natb y natc db e1b n cb natd w' w'a w'b x')(*strict*)
      apply(clarsimp)
      apply (metis set_liftB_insert take_reflects_mem)
     apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 ca natb y natc db e1b n cb natd w' w'a w'b x' nate)(*strict*)
     apply(clarsimp)
     apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 ca natb y natc db e1b n cb natd w' w'b nate)(*strict*)
     apply (metis head_in_set set_liftB_insert set_append_contra2)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd w' w'a x')(*strict*)
    apply(rule sym)
    apply(rule liftB_terminal_tail_equals)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y natc db e1b n cb natd w' w'a x')(*strict*)
   apply(rule liftB_terminal_butlast_equals)
   apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y)(*strict*)
  apply(clarsimp)
  apply(thin_tac "ca @ y @ [Do] \<in> cfgSTD_first G' (k - Suc 0) (\<beta> @ liftB (y @ [Do]))")
  apply(simp add: cfgSTD_first_def)
  apply(clarsimp)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y x db e1b n)(*strict*)
  apply(subgoal_tac "suffix x za")
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y x db e1b n)(*strict*)
   prefer 2
   apply(rule liftB_creates_suffix)
   apply(subgoal_tac "\<exists>d' e. cfgRM.derivation G' d' \<and> maximum_of_domain d' n \<and> d' 0 = Some (pair None \<lparr>cfg_conf=\<beta>' @ liftB za\<rparr>) \<and> d' n = Some (pair e \<lparr>cfg_conf=liftB x\<rparr>)")
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y x db e1b n)(*strict*)
    prefer 2
    apply(rule_tac
      d="db"
      in cfg_derivation_can_be_translated_to_cfgRM_derivation)
         apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y x db e1b n)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
        apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y x db e1b n)(*strict*)
        apply(force)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y x db e1b n)(*strict*)
       apply(simp add: maximum_of_domain_def)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y x db e1b n)(*strict*)
      apply(force)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y x db e1b n)(*strict*)
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y x db e1b n)(*strict*)
    apply (metis setA_liftB)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y x db e1b n)(*strict*)
   apply(clarsimp)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y x db e1b n d' e)(*strict*)
   apply(rule_tac
      d="d'"
      and i="0"
      and j="n"
      in CFGRM_terminals_stay_at_end)
        apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y x db e1b n d' e)(*strict*)
        apply(force)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y x db e1b n d' e)(*strict*)
       apply(force)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y x db e1b n d' e)(*strict*)
      apply (metis setA_liftB)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y x db e1b n d' e)(*strict*)
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y x db e1b n d' e)(*strict*)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y x db e1b n d' e)(*strict*)
   apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y x db e1b n)(*strict*)
  apply(simp add: suffix_def)
  apply(clarsimp)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
  apply(case_tac "(k - Suc (length cb))")
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
  apply(clarsimp)
  apply(subgoal_tac "set cb \<subseteq> cfg_events G")
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
  apply(subgoal_tac "Do \<in> set cb")
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
   apply(subgoal_tac "Do \<notin> set cb")
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
   apply(rule_tac
    B="cfg_events G"
    in nset_mp)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
   apply(simp add: AF_LR_PARSER_input_def two_elements_construct_domain_def)
   apply(clarsimp)
   apply(subgoal_tac "F_FRESH (cfg_events G) \<notin> cfg_events G")
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
   apply(rule F_FRESH_is_fresh)
   apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def valid_cfg_def)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
  apply(rule_tac
    A="set(take (k - Suc 0) cb)"
    in set_mp)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
   apply(rule List.set_take_subset)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
  apply(rule_tac
    t="take (k - Suc 0) cb"
    and s="ca @ y @ Do # c"
    in ssubst)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
   apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
  apply(simp (no_asm))
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
  apply(rule liftB_in_two_elements_construct_domain_to_subset)
  apply(subgoal_tac "\<exists>v. set v \<subseteq> two_elements_construct_domain (cfg_nonterminals G) (cfg_events G) \<and> (case e1b of None \<Rightarrow> True|Some e' \<Rightarrow> e' \<in> cfg_productions G) \<and> SSc=\<lparr>cfg_conf = v @ liftB za\<rparr>" for SSc)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
  prefer 2
  apply(rule_tac
    n="n"
    and d="db"
    in CFG_preserves_partial_belongs)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
      prefer 2
      apply(force)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
     prefer 2
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
    apply(rule_tac
    B="set (\<alpha>' @ teB aa # \<beta>')"
    in subset_trans)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
    apply(rule SetxBiElem_check_vs_set_two_elements_construct_domain_check)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
     apply(rule prod_rhs_in_cfg_events)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
      apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
    apply(rule prod_rhs_in_nonterms)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
     apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb p)(*strict*)
   apply(simp add: AF_LR_PARSER_input_def F_CFG_AUGMENT_def)
   apply(clarsimp)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
   apply(subgoal_tac "F_FRESH (cfg_nonterminals G) \<notin> cfg_nonterminals G")
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
   apply(rule F_FRESH_is_fresh)
   apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def valid_cfg_def)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
  apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb)(*strict*)
  apply(erule exE)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb v)(*strict*)
  apply(erule conjE)+
  apply(subgoal_tac "v=liftB cb")
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb v)(*strict*)
  apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb v)(*strict*)
  apply(clarsimp)
  apply(simp add: liftB_commutes_over_concat)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
  apply(clarsimp)
  apply(subgoal_tac "prefix (ca @ y @ [Do]) cb \<or> prefix cb (ca @ y @ [Do])")
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
  prefer 2
  apply(rule mutual_prefix_prefix)
  apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
  apply(erule disjE)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
  apply(subgoal_tac "set cb \<subseteq> cfg_events G")
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
  apply(subgoal_tac "Do \<in> set cb")
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
   apply(subgoal_tac "Do \<notin> set cb")
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
   apply(rule_tac
    B="cfg_events G"
    in nset_mp)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
   apply(simp add: AF_LR_PARSER_input_def two_elements_construct_domain_def)
   apply(clarsimp)
   apply(subgoal_tac "F_FRESH (cfg_events G) \<notin> cfg_events G")
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
   apply(rule F_FRESH_is_fresh)
   apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def valid_cfg_def)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
  apply(simp add: prefix_def)
  apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
  apply(rule liftB_in_two_elements_construct_domain_to_subset)
  apply(subgoal_tac "\<exists>v. set v \<subseteq> two_elements_construct_domain (cfg_nonterminals G) (cfg_events G) \<and> (case e1b of None \<Rightarrow> True|Some e' \<Rightarrow> e' \<in> cfg_productions G) \<and> SSc=\<lparr>cfg_conf = v @ liftB za\<rparr>" for SSc)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
  prefer 2
  apply(rule_tac
    n="n"
    and d="db"
    in CFG_preserves_partial_belongs)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
      prefer 2
      apply(force)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
     prefer 2
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
    apply(rule_tac
    B="set (\<alpha>' @ teB aa # \<beta>')"
    in subset_trans)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
    apply(rule SetxBiElem_check_vs_set_two_elements_construct_domain_check)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
     apply(rule prod_rhs_in_cfg_events)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
      apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
    apply(rule prod_rhs_in_nonterms)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
     apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc p)(*strict*)
   apply(simp add: AF_LR_PARSER_input_def F_CFG_AUGMENT_def)
   apply(clarsimp)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
   apply(subgoal_tac "F_FRESH (cfg_nonterminals G) \<notin> cfg_nonterminals G")
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
   apply(rule F_FRESH_is_fresh)
   apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def valid_cfg_def)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
  apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
  apply(erule exE)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc v)(*strict*)
  apply(erule conjE)+
  apply(subgoal_tac "v=liftB cb")
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc v)(*strict*)
  apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc v)(*strict*)
  apply(clarsimp)
  apply(simp add: liftB_commutes_over_concat)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc)(*strict*)
  apply(simp add: prefix_def)
  apply(clarsimp)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
  apply(case_tac cc)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
  apply(subgoal_tac "set cb \<subseteq> cfg_events G")
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
  apply(subgoal_tac "Do \<in> set cb")
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
   apply(subgoal_tac "Do \<notin> set cb")
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
   apply(rule_tac
    B="cfg_events G"
    in nset_mp)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
   apply(simp add: AF_LR_PARSER_input_def two_elements_construct_domain_def)
   apply(clarsimp)
   apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n natc)(*strict*)
   apply(subgoal_tac "F_FRESH (cfg_events G) \<notin> cfg_events G")
    apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n natc)(*strict*)
    apply(force)
   apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n natc)(*strict*)
   apply(rule F_FRESH_is_fresh)
   apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def valid_cfg_def)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
  apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
  apply(rule liftB_in_two_elements_construct_domain_to_subset)
  apply(subgoal_tac "\<exists>v. set v \<subseteq> two_elements_construct_domain (cfg_nonterminals G) (cfg_events G) \<and> (case e1b of None \<Rightarrow> True|Some e' \<Rightarrow> e' \<in> cfg_productions G) \<and> SSc=\<lparr>cfg_conf = v @ liftB za\<rparr>" for SSc)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
  prefer 2
  apply(rule_tac
    n="n"
    and d="db"
    in CFG_preserves_partial_belongs)
       apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
      prefer 2
      apply(force)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
     prefer 2
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
    apply(rule_tac
    B="set (\<alpha>' @ teB aa # \<beta>')"
    in subset_trans)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
    apply(rule SetxBiElem_check_vs_set_two_elements_construct_domain_check)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
     apply(rule prod_rhs_in_cfg_events)
      apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
      apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
    apply(rule prod_rhs_in_nonterms)
     apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
     apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def)
    apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc p)(*strict*)
   apply(simp add: AF_LR_PARSER_input_def F_CFG_AUGMENT_def)
   apply(clarsimp)
   apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n natc)(*strict*)
   apply(subgoal_tac "F_FRESH (cfg_nonterminals G) \<notin> cfg_nonterminals G")
    apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n natc)(*strict*)
    apply(force)
   apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n natc)(*strict*)
   apply(rule F_FRESH_is_fresh)
   apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def valid_cfg_def)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
  apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc)(*strict*)
  apply(erule exE)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc v)(*strict*)
  apply(erule conjE)+
  apply(subgoal_tac "v=liftB cb")
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc v)(*strict*)
  apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc v)(*strict*)
  apply(clarsimp)
  apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n natc v)(*strict*)
  apply(simp add: liftB_commutes_over_concat)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc a list)(*strict*)
  apply(subgoal_tac "\<exists>w' x'. cc = w' @ [x']")
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc a list)(*strict*)
  prefer 2
  apply(rule NonEmptyListHasTailElem)
  apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc cc a list)(*strict*)
  apply(thin_tac "cc=a#list")
  apply(clarsimp)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w')(*strict*)
  apply(subgoal_tac "take (Suc natc) za = w'@Do#c")
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w')(*strict*)
  prefer 2
  apply(rule sym)
  apply(rule_tac
    w="cb"
    in append_linj)
  apply(metis concat_asso)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w')(*strict*)
  apply(clarsimp)
  apply(case_tac za)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w')(*strict*)
  apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' a list)(*strict*)
  apply(subgoal_tac "\<exists>w' x'. za = w' @ [x']")
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' a list)(*strict*)
  prefer 2
  apply(rule NonEmptyListHasTailElem)
  apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' a list)(*strict*)
  apply(thin_tac "za=a#list")
  apply(clarsimp)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x')(*strict*)
  apply(case_tac c)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x')(*strict*)
  apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' a list)(*strict*)
  apply(subgoal_tac "\<exists>w' x'. c = w' @ [x']")
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' a list)(*strict*)
  prefer 2
  apply(rule NonEmptyListHasTailElem)
  apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' a list)(*strict*)
  apply(thin_tac "c=a#list")
  apply(clarsimp)
  apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' w'b x'a)(*strict*)
  apply(subgoal_tac "teB Do \<in> set (liftB w'a)")
  apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' w'b x'a)(*strict*)
  apply(subgoal_tac "teB Do \<notin> set (liftB w'a)")
  apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' w'b x'a)(*strict*)
  apply(force)
  apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' w'b x'a)(*strict*)
  apply(thin_tac "teB Do \<in> set (liftB w'a)")
  apply(rule_tac
    B="set(liftB (w'a @ [x']))"
    in nset_mp)
  apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' w'b x'a)(*strict*)
  apply (smt set_liftB_commute set_app_subset)
  apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' w'b x'a)(*strict*)
  apply(rule_tac
    B="set(take k w3)"
    in nset_mp)
  apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' w'b x'a)(*strict*)
  apply(force)
  apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' w'b x'a)(*strict*)
  apply(rule_tac
    B="set w3"
    in nset_mp)
  apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' w'b x'a)(*strict*)
  apply(rule List.set_take_subset)
  apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' w'b x'a)(*strict*)
  apply(rule_tac
    B="two_elements_construct_domain (cfg_nonterminals G) (cfg_events G)"
    in nset_mp)
  apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' w'b x'a)(*strict*)
  apply(force)
  apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' w'b x'a)(*strict*)
  apply(simp add: AF_LR_PARSER_input_def F_CFG_AUGMENT_def two_elements_construct_domain_def)
  apply(clarsimp)
  apply(subgoal_tac "F_FRESH (cfg_events G) \<notin> cfg_events G")
  apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' w'b x'a)(*strict*)
  apply(force)
  apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' w'b x'a)(*strict*)
  apply(rule F_FRESH_is_fresh)
  apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def valid_cfg_def)
  apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' w'b x'a)(*strict*)
  apply(case_tac "Suc natc - length w'a")
  apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' w'b x'a)(*strict*)
  apply(clarsimp)
  apply (metis set_liftB_insert take_reflects_mem)
  apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'a x' w'b x'a natd)(*strict*)
  apply(clarsimp)
  apply(rename_tac d da e1 e2 e1a e2a nat nata w1 w2 w3 ca natb y db e1b n cb natc w' w'b x'a natd)(*strict*)
  apply (metis head_in_set set_liftB_insert set_append_contra2)
  done

theorem no_shift_shift_conflicts: "
  AF_LR_PARSER_input G F Do S' G' M P k
  \<Longrightarrow> (parser_marker P) r1 = Some None
  \<Longrightarrow> (parser_marker P) r2 = Some None
  \<Longrightarrow> r1 \<in> parser_rules P
  \<Longrightarrow> r2 \<in> parser_rules P
  \<Longrightarrow> rule_lpop r2 \<sqsupseteq> rule_lpop r1 \<or> rule_lpop r1 \<sqsupseteq> rule_lpop r2
  \<Longrightarrow> rule_rpop r1 \<sqsubseteq> rule_rpop r2 \<or> rule_rpop r2 \<sqsubseteq> rule_rpop r1
  \<Longrightarrow> r1 = r2"
  apply(case_tac r1)
  apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
  apply(subgoal_tac " \<exists>q\<delta> y \<beta> z A \<alpha> a \<delta>. y \<in> (cfgSTD_first G' (k- 1) (\<beta>@(liftB z))) \<and> \<lparr>prod_lhs=A,prod_rhs=\<alpha>@(teB a)#\<beta>\<rparr> \<in> cfg_productions G \<and> q\<delta>=last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do#\<delta>)) \<and> \<lparr>cfg_item_lhs = A,cfg_item_rhs1 = \<alpha>,cfg_item_rhs2 = (teB a)#\<beta>,cfg_item_look_ahead = z\<rparr> \<in> valid_item_set G' k (teB Do#\<delta>) \<and> rule_lpopa=[q\<delta>] \<and> rule_rpopa=a#y \<and> rule_lpush=[q\<delta>,F_DFA_GOTO M q\<delta> (teB a)] \<and> rule_rpush=y")
   apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
   prefer 2
   apply(rule_tac
      S'="S'"
      and Do="Do"
      and G'="G'"
      and G="G"
      in X6_3_InformationOnRules_shift2)
            apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
            apply(simp add: AF_LR_PARSER_input_def)
           apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
           apply(simp add: AF_LR_PARSER_input_def)
           apply(force)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
        apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
      apply(force)
     apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
     apply(force)
    apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
    apply(simp add: AF_LR_PARSER_input_def)
   apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
   apply(simp add: AF_LR_PARSER_input_def)
  apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
  apply(case_tac r2)
  apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
  apply(subgoal_tac " \<exists>q\<delta> y \<beta> z A \<alpha> a \<delta>. y \<in> (cfgSTD_first G' (k- 1) (\<beta>@(liftB z))) \<and> \<lparr>prod_lhs=A,prod_rhs=\<alpha>@(teB a)#\<beta>\<rparr> \<in> cfg_productions G \<and> q\<delta>=last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do#\<delta>)) \<and> \<lparr>cfg_item_lhs = A,cfg_item_rhs1 = \<alpha>,cfg_item_rhs2 = (teB a)#\<beta>,cfg_item_look_ahead = z\<rparr> \<in> valid_item_set G' k (teB Do#\<delta>) \<and> rule_lpopaa=[q\<delta>] \<and> rule_rpopaa=a#y \<and> rule_lpusha=[q\<delta>,F_DFA_GOTO M q\<delta> (teB a)] \<and> rule_rpusha=y")
   apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
   prefer 2
   apply(rule_tac
      S'="S'"
      and Do="Do"
      and G'="G'"
      and G="G"
      in X6_3_InformationOnRules_shift2)
            apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
            apply(simp add: AF_LR_PARSER_input_def)
           apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
           apply(simp add: AF_LR_PARSER_input_def)
           apply(force)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
        apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
      apply(force)
     apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
     apply(force)
    apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
    apply(simp add: AF_LR_PARSER_input_def)
   apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
   apply(simp add: AF_LR_PARSER_input_def)
  apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
  apply(clarsimp)
  apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> a Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
  apply(subgoal_tac "a=aa")
   apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> a Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
   prefer 2
   apply(erule_tac
      P="(a # y) \<sqsubseteq> (aa # ya)"
      in disjE)
    apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> a Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
    apply(simp add: prefix_def)
   apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> a Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
   apply(simp add: prefix_def)
  apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> a Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
  apply(clarsimp)
  apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
  apply(subgoal_tac "[last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>'))] = [last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>))]")
   apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
   prefer 2
   apply(erule_tac
      P="[last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>'))] \<sqsupseteq> [last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>))]"
      in disjE)
    apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
    apply(simp add: suffix_def)
   apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
   apply(simp add: suffix_def)
  apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
  apply(clarsimp)
  apply(thin_tac "parser_marker P \<lparr>rule_lpop = [last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>))], rule_rpop = aa # y, rule_lpush = [last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>)), F_DFA_GOTO M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>))) (teB aa)], rule_rpush = y\<rparr> = Some None")
  apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
  apply(thin_tac "parser_marker P \<lparr>rule_lpop = [last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>))], rule_rpop = aa # ya, rule_lpush = [last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>)), F_DFA_GOTO M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>))) (teB aa)], rule_rpush = ya\<rparr> = Some None")
  apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
  apply(thin_tac "\<lparr>rule_lpop = [last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>))], rule_rpop = aa # y, rule_lpush = [last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>)), F_DFA_GOTO M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>))) (teB aa)], rule_rpush = y\<rparr> \<in> parser_rules P")
  apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
  apply(thin_tac "\<lparr>rule_lpop = [last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>))], rule_rpop = aa # ya, rule_lpush = [last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>)), F_DFA_GOTO M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>))) (teB aa)], rule_rpush = ya\<rparr> \<in> parser_rules P")
  apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
  apply(thin_tac "[last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>))] \<sqsupseteq> [last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>))]")
  apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
  apply(erule disjE)
   apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
   apply(rule no_shift_shift_conflicts1)
           apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
           apply(force)
          apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
          apply(force)
         apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
         apply(force)
        apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
        apply(force)
       apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
       apply(force)
      apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
      apply(force)
     apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
     apply(force)
    apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
    apply(force)
   apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
   apply(force)
  apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
  apply(rule sym)
  apply(rule no_shift_shift_conflicts1)
          apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
          apply(force)
         apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
         apply(force)
        apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
        apply(force)
       apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
       apply(force)
      apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
      apply(force)
     apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
     apply(force)
    apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
    apply(force)
   apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
   apply(force)
  apply(rename_tac y ya \<beta> \<beta>' z za A \<alpha> Aa \<alpha>' aa \<delta> \<delta>')(*strict*)
  apply(force)
  done

lemma no_reduce_reduce_conflicts_hlp: "
  AF_LR_PARSER_input G F Do S' G' M P k
  \<Longrightarrow> valid_cfg G'
  \<Longrightarrow> \<lparr>cfg_item_lhs = A1, cfg_item_rhs1 = w1, cfg_item_rhs2 = [], cfg_item_look_ahead = y1\<rparr> \<in> valid_item_set G' k (teB Do # w)
  \<Longrightarrow> \<lparr>cfg_item_lhs = A2, cfg_item_rhs1 = w2, cfg_item_rhs2 = [], cfg_item_look_ahead = y2\<rparr> \<in> valid_item_set G' k (teB Do # w)
  \<Longrightarrow> prefix y1 y2
  \<Longrightarrow> y1 = y2"
  apply(simp add: valid_item_set_def valid_item_set_n_def prefix_def)
  apply(clarsimp)
  apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za)(*strict*)
  apply(subgoal_tac "\<exists>e c. d (Suc 0) = Some (pair e c)")
   apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za)(*strict*)
   prefer 2
   apply(rule_tac
      m="Suc n"
      in cfgRM.pre_some_position_is_some_position)
     apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za)(*strict*)
     apply(force)
    apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za)(*strict*)
    apply(force)
   apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za)(*strict*)
   apply(force)
  apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za)(*strict*)
  apply(subgoal_tac "\<exists>e c. da (Suc 0) = Some (pair e c)")
   apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za)(*strict*)
   prefer 2
   apply(rule_tac
      m="Suc na"
      in cfgRM.pre_some_position_is_some_position)
     apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za)(*strict*)
     apply(force)
    apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za)(*strict*)
    apply(force)
   apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za)(*strict*)
   apply(force)
  apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za)(*strict*)
  apply(clarsimp)
  apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
  apply(subgoal_tac "teB Do \<notin> two_elements_construct_domain (cfg_nonterminals G) (cfg_events G)")
   apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
   prefer 2
   apply(simp add: AF_LR_PARSER_input_def F_CFG_AUGMENT_def two_elements_construct_domain_def)
   apply(clarsimp)
   apply(rule conjI)
    apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
    apply(force)
   apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
   apply(clarsimp)
   apply(subgoal_tac "F_FRESH (cfg_events G) \<notin> cfg_events G")
    apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
    apply(force)
   apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
   apply(rule F_FRESH_is_fresh)
   apply(simp add: F_LR_MACHINE_def F_CFG_AUGMENT_def two_elements_construct_domain_def valid_cfg_def)
  apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
  apply(subgoal_tac "\<exists>w. set w \<subseteq> two_elements_construct_domain (cfg_nonterminals G) (cfg_events G) \<and> cfg_conf ca=[teB Do]@w@[teB Do]")
   apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
   prefer 2
   apply(rule_tac
      d="d"
      and i="0"
      in F_CFG_AUGMENT__reachableConf_of_certain_form)
     apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
    apply(rule cfgSTD.derivation_initialI)
     apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
     apply(rule cfgRM_derivations_are_cfg_derivations)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
    apply(simp add: cfg_initial_configurations_def get_configuration_def cfg_configurations_def valid_cfg_def)
    apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
   apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
   apply(force)
  apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
  apply(subgoal_tac "\<exists>w. set w \<subseteq> two_elements_construct_domain (cfg_nonterminals G) (cfg_events G) \<and> cfg_conf cb=[teB Do]@w@[teB Do]")
   apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
   prefer 2
   apply(rule_tac
      d="da"
      and i="0"
      in F_CFG_AUGMENT__reachableConf_of_certain_form)
     apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
    apply(rule cfgSTD.derivation_initialI)
     apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
     apply(rule cfgRM_derivations_are_cfg_derivations)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
    apply(simp add: cfg_initial_configurations_def get_configuration_def cfg_configurations_def valid_cfg_def)
    apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
   apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
   apply(force)
  apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
  apply(subgoal_tac "\<exists>w. set w \<subseteq> two_elements_construct_domain (cfg_nonterminals G) (cfg_events G) \<and> cfg_conf \<lparr>cfg_conf = \<delta> @ w1 @ z\<rparr>=[teB Do]@w@[teB Do]")
   apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
   prefer 2
   apply(rule_tac
      d="d"
      and i="n"
      in F_CFG_AUGMENT__reachableConf_of_certain_form)
     apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
    apply(rule cfgSTD.derivation_initialI)
     apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
     apply(rule cfgRM_derivations_are_cfg_derivations)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
    apply(simp add: cfg_initial_configurations_def get_configuration_def cfg_configurations_def valid_cfg_def)
    apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
   apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
   apply(force)
  apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
  apply(subgoal_tac "\<exists>w. set w \<subseteq> two_elements_construct_domain (cfg_nonterminals G) (cfg_events G) \<and> cfg_conf \<lparr>cfg_conf = \<delta>' @ w2 @ za\<rparr>=[teB Do]@w@[teB Do]")
   apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
   prefer 2
   apply(rule_tac
      d="da"
      and i="na"
      in F_CFG_AUGMENT__reachableConf_of_certain_form)
     apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
    apply(rule cfgSTD.derivation_initialI)
     apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
     apply(rule cfgRM_derivations_are_cfg_derivations)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
    apply(simp add: cfg_initial_configurations_def get_configuration_def cfg_configurations_def valid_cfg_def)
    apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
   apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
   apply(force)
  apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb)(*strict*)
  apply(clarsimp)
  apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb wa waa wb wc)(*strict*)
  apply(case_tac ca)
  apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb wa waa wb wc cfg_confa)(*strict*)
  apply(case_tac cb)
  apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea ca cb wa waa wb wc cfg_confa cfg_confaa)(*strict*)
  apply(clarsimp)
  apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc)(*strict*)
  apply(case_tac n)
   apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc)(*strict*)
   apply(clarsimp)
   apply(rename_tac na c d da \<delta> e2 z \<delta>' e1a e2a za ea wa wb wc)(*strict*)
   apply(case_tac "\<delta>")
    apply(rename_tac na c d da \<delta> e2 z \<delta>' e1a e2a za ea wa wb wc)(*strict*)
    prefer 2
    apply(rename_tac na c d da \<delta> e2 z \<delta>' e1a e2a za ea wa wb wc a list)(*strict*)
    apply(clarsimp)
   apply(rename_tac na c d da \<delta> e2 z \<delta>' e1a e2a za ea wa wb wc)(*strict*)
   apply(clarsimp)
   apply(rename_tac na c d da e2 \<delta>' e1a e2a za ea wa wb wc)(*strict*)
   apply(case_tac y1)
    apply(rename_tac na c d da e2 \<delta>' e1a e2a za ea wa wb wc)(*strict*)
    prefer 2
    apply(rename_tac na c d da e2 \<delta>' e1a e2a za ea wa wb wc a list)(*strict*)
    apply(clarsimp)
   apply(rename_tac na c d da e2 \<delta>' e1a e2a za ea wa wb wc)(*strict*)
   apply(clarsimp)
   apply(case_tac na)
    apply(rename_tac na c d da e2 \<delta>' e1a e2a za ea wa wb wc)(*strict*)
    apply(clarsimp)
    apply(rename_tac c d da e2 \<delta>' e2a za wb wc)(*strict*)
    apply(case_tac "\<delta>'")
     apply(rename_tac c d da e2 \<delta>' e2a za wb wc)(*strict*)
     prefer 2
     apply(rename_tac c d da e2 \<delta>' e2a za wb wc a list)(*strict*)
     apply(clarsimp)
    apply(rename_tac c d da e2 \<delta>' e2a za wb wc)(*strict*)
    apply(clarsimp)
    apply(rename_tac c d da e2 e2a wc)(*strict*)
    apply(case_tac c)
     apply(rename_tac c d da e2 e2a wc)(*strict*)
     apply(force)
    apply(rename_tac c d da e2 e2a wc a list)(*strict*)
    apply(force)
   apply(rename_tac na c d da e2 \<delta>' e1a e2a za ea wa wb wc nat)(*strict*)
   apply(clarsimp)
   apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat)(*strict*)
   apply(subgoal_tac "\<exists>w. set w \<subseteq> two_elements_construct_domain (cfg_nonterminals G) (cfg_events G) \<and> cfg_conf \<lparr>cfg_conf = \<delta>' @ teA A2 # za\<rparr>=[teB Do]@w@[teB Do]")
    apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat)(*strict*)
    prefer 2
    apply(rule_tac
      d="da"
      and i="nat"
      in F_CFG_AUGMENT__reachableConf_of_certain_form)
      apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat)(*strict*)
      apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
     apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat)(*strict*)
     apply(rule cfgSTD.derivation_initialI)
      apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat)(*strict*)
      apply(rule cfgRM_derivations_are_cfg_derivations)
      apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
     apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat)(*strict*)
     apply(simp add: cfg_initial_configurations_def get_configuration_def cfg_configurations_def valid_cfg_def)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat)(*strict*)
    apply(force)
   apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat)(*strict*)
   apply(subgoal_tac "\<exists>w. set w \<subseteq> two_elements_construct_domain (cfg_nonterminals G) (cfg_events G) \<and> cfg_conf \<lparr>cfg_conf = teB Do # wc @ [teB Do]\<rparr>=[teB Do]@w@[teB Do]")
    apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat)(*strict*)
    prefer 2
    apply(rule_tac
      d="da"
      and i="Suc nat"
      in F_CFG_AUGMENT__reachableConf_of_certain_form)
      apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat)(*strict*)
      apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
     apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat)(*strict*)
     apply(rule cfgSTD.derivation_initialI)
      apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat)(*strict*)
      apply(rule cfgRM_derivations_are_cfg_derivations)
      apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
     apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat)(*strict*)
     apply(simp add: cfg_initial_configurations_def get_configuration_def cfg_configurations_def valid_cfg_def)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat)(*strict*)
    apply(force)
   apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat)(*strict*)
   apply(clarsimp)
   apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat w)(*strict*)
   apply(case_tac w2)
    apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat w)(*strict*)
    apply(clarsimp)
    apply(rename_tac c d da e2 e1a e2a za ea wa wb wc nat w)(*strict*)
    apply(case_tac za)
     apply(rename_tac c d da e2 e1a e2a za ea wa wb wc nat w)(*strict*)
     apply(clarsimp)
    apply(rename_tac c d da e2 e1a e2a za ea wa wb wc nat w a list)(*strict*)
    apply(subgoal_tac "\<exists>w' x'. za = w' @ [x']")
     apply(rename_tac c d da e2 e1a e2a za ea wa wb wc nat w a list)(*strict*)
     prefer 2
     apply(rule NonEmptyListHasTailElem)
     apply(force)
    apply(rename_tac c d da e2 e1a e2a za ea wa wb wc nat w a list)(*strict*)
    apply(thin_tac "za=a#list")
    apply(clarsimp)
   apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat w a list)(*strict*)
   apply(subgoal_tac "\<exists>w' x'. w2 = w' @ [x']")
    apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat w a list)(*strict*)
    prefer 2
    apply(rule NonEmptyListHasTailElem)
    apply(force)
   apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat w a list)(*strict*)
   apply(thin_tac "w2=a#list")
   apply(clarsimp)
   apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat w w')(*strict*)
   apply(case_tac "\<delta>'")
    apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat w w')(*strict*)
    apply(clarsimp)
   apply(rename_tac c d da e2 \<delta>' e1a e2a za ea wa wb wc nat w w' a list)(*strict*)
   apply(clarsimp)
   apply(rename_tac c d da e2 e1a e2a za ea wa wc nat w w' list)(*strict*)
   apply(case_tac za)
    apply(rename_tac c d da e2 e1a e2a za ea wa wc nat w w' list)(*strict*)
    apply(clarsimp)
   apply(rename_tac c d da e2 e1a e2a za ea wa wc nat w w' list a lista)(*strict*)
   apply(subgoal_tac "\<exists>w' x'. za = w' @ [x']")
    apply(rename_tac c d da e2 e1a e2a za ea wa wc nat w w' list a lista)(*strict*)
    prefer 2
    apply(rule NonEmptyListHasTailElem)
    apply(force)
   apply(rename_tac c d da e2 e1a e2a za ea wa wc nat w w' list a lista)(*strict*)
   apply(thin_tac "za=a#lista")
   apply(clarsimp)
  apply(rename_tac n na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat)(*strict*)
  apply(clarsimp)
  apply(rename_tac na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat)(*strict*)
  apply(case_tac na)
   apply(rename_tac na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat)(*strict*)
   apply(clarsimp)
   apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e2a za e wa wb wc nat)(*strict*)
   apply(case_tac "\<delta>'")
    apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e2a za e wa wb wc nat)(*strict*)
    prefer 2
    apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e2a za e wa wb wc nat a list)(*strict*)
    apply(clarsimp)
   apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e2a za e wa wb wc nat)(*strict*)
   apply(clarsimp)
   apply(rename_tac c d da \<delta> e1 e2 z e2a e w wb wc nat)(*strict*)
   apply(case_tac c)
    apply(rename_tac c d da \<delta> e1 e2 z e2a e w wb wc nat)(*strict*)
    prefer 2
    apply(rename_tac c d da \<delta> e1 e2 z e2a e w wb wc nat a list)(*strict*)
    apply(clarsimp)
    apply(rename_tac d da \<delta> e1 e2 z e2a e w wb wc nat a list)(*strict*)
    apply (metis Nil_is_append_conv liftB_reflects_Nil list.simps(3))
   apply(rename_tac c d da \<delta> e1 e2 z e2a e w wb wc nat)(*strict*)
   apply(force)
  apply(rename_tac na c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat nata)(*strict*)
  apply(clarsimp)
  apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat nata)(*strict*)
  apply(subgoal_tac "\<exists>w. set w \<subseteq> two_elements_construct_domain (cfg_nonterminals G) (cfg_events G) \<and> cfg_conf \<lparr>cfg_conf = \<delta> @ teA A1 # z\<rparr>=[teB Do]@w@[teB Do]")
   apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat nata)(*strict*)
   prefer 2
   apply(rule_tac
      d="d"
      and i="nat"
      in F_CFG_AUGMENT__reachableConf_of_certain_form)
     apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat nata)(*strict*)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat nata)(*strict*)
    apply(rule cfgSTD.derivation_initialI)
     apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat nata)(*strict*)
     apply(rule cfgRM_derivations_are_cfg_derivations)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat nata)(*strict*)
    apply(simp add: cfg_initial_configurations_def get_configuration_def cfg_configurations_def valid_cfg_def)
    apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
   apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat nata)(*strict*)
   apply(force)
  apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat nata)(*strict*)
  apply(subgoal_tac "\<exists>w. set w \<subseteq> two_elements_construct_domain (cfg_nonterminals G) (cfg_events G) \<and> cfg_conf \<lparr>cfg_conf = \<delta>' @ teA A2 # za\<rparr>=[teB Do]@w@[teB Do]")
   apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat nata)(*strict*)
   prefer 2
   apply(rule_tac
      d="da"
      and i="nata"
      in F_CFG_AUGMENT__reachableConf_of_certain_form)
     apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat nata)(*strict*)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat nata)(*strict*)
    apply(rule cfgSTD.derivation_initialI)
     apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat nata)(*strict*)
     apply(rule cfgRM_derivations_are_cfg_derivations)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat nata)(*strict*)
    apply(simp add: cfg_initial_configurations_def get_configuration_def cfg_configurations_def valid_cfg_def)
    apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
   apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat nata)(*strict*)
   apply(force)
  apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat nata)(*strict*)
  apply(clarsimp)
  apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat nata wd we)(*strict*)
  apply(case_tac "\<delta>")
   apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat nata wd we)(*strict*)
   apply(clarsimp)
  apply(rename_tac c d da \<delta> e1 e2 z \<delta>' e1a e2a za e ea wa waa wb wc nat nata wd we a list)(*strict*)
  apply(clarsimp)
  apply(rename_tac c d da e1 e2 z \<delta>' e1a e2a za e ea w wa wb wc nat nata wd we list)(*strict*)
  apply(case_tac "\<delta>'")
   apply(rename_tac c d da e1 e2 z \<delta>' e1a e2a za e ea w wa wb wc nat nata wd we list)(*strict*)
   apply(clarsimp)
  apply(rename_tac c d da e1 e2 z \<delta>' e1a e2a za e ea w wa wb wc nat nata wd we list a lista)(*strict*)
  apply(clarsimp)
  apply(rename_tac c d da e1 e2 z e1a e2a za e ea w wa wb wc nat nata wd we list lista)(*strict*)
  apply(case_tac "z")
   apply(rename_tac c d da e1 e2 z e1a e2a za e ea w wa wb wc nat nata wd we list lista)(*strict*)
   apply(clarsimp)
  apply(rename_tac c d da e1 e2 z e1a e2a za e ea w wa wb wc nat nata wd we list lista a listb)(*strict*)
  apply(subgoal_tac "\<exists>w' x'. z = w' @ [x']")
   apply(rename_tac c d da e1 e2 z e1a e2a za e ea w wa wb wc nat nata wd we list lista a listb)(*strict*)
   prefer 2
   apply(rule NonEmptyListHasTailElem)
   apply(force)
  apply(rename_tac c d da e1 e2 z e1a e2a za e ea w wa wb wc nat nata wd we list lista a listb)(*strict*)
  apply(thin_tac "z=a#listb")
  apply(clarsimp)
  apply(rename_tac c d da e1 e2 e1a e2a za e ea w wa wc nat nata we list lista w')(*strict*)
  apply(case_tac "za")
   apply(rename_tac c d da e1 e2 e1a e2a za e ea w wa wc nat nata we list lista w')(*strict*)
   apply(clarsimp)
  apply(rename_tac c d da e1 e2 e1a e2a za e ea w wa wc nat nata we list lista w' a listb)(*strict*)
  apply(subgoal_tac "\<exists>w' x'. za = w' @ [x']")
   apply(rename_tac c d da e1 e2 e1a e2a za e ea w wa wc nat nata we list lista w' a listb)(*strict*)
   prefer 2
   apply(rule NonEmptyListHasTailElem)
   apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a za e ea w wa wc nat nata we list lista w' a listb)(*strict*)
  apply(thin_tac "za=a#listb")
  apply(clarsimp)
  apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w' w'a)(*strict*)
  apply(case_tac "k-length w'")
   apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w' w'a)(*strict*)
   apply(clarsimp)
   apply (metis liftB_reflects_length self_append_conv takeShorter take_all take_all_length take_append take_append_prime)
  apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w' w'a natb)(*strict*)
  apply(clarsimp)
  apply(case_tac y1)
   apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w' w'a natb)(*strict*)
   apply(clarsimp)
  apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w' w'a natb a listb)(*strict*)
  apply(subgoal_tac "\<exists>w' x'. y1 = w' @ [x']")
   apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w' w'a natb a listb)(*strict*)
   prefer 2
   apply(rule NonEmptyListHasTailElem)
   apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w' w'a natb a listb)(*strict*)
  apply(thin_tac "y1=a#listb")
  apply(clarsimp)
  apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w' w'a natb w'b x')(*strict*)
  apply(subgoal_tac "x'=Do")
   apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w' w'a natb w'b x')(*strict*)
   prefer 2
   apply(rule_tac
      v="w'"
      and w="w'b"
      in liftB_terminal_tail_equals)
   apply(blast)
  apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w' w'a natb w'b x')(*strict*)
  apply(clarsimp)
  apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w' w'a natb w'b)(*strict*)
  apply(subgoal_tac "w'=liftB w'b")
   apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w' w'a natb w'b)(*strict*)
   prefer 2
   apply(rule liftB_terminal_butlast_equals)
   apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w' w'a natb w'b)(*strict*)
  apply(clarsimp)
  apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b)(*strict*)
  apply(case_tac "k - length w'a")
   apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b)(*strict*)
   apply(clarsimp)
   apply(subgoal_tac "teB Do \<in> set w'a")
    apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b)(*strict*)
    apply(subgoal_tac "teB Do \<notin> set w'a")
     apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b)(*strict*)
     apply(force)
    apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b)(*strict*)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b)(*strict*)
   apply(rule_tac
      A="set(take k w'a)"
      in set_mp)
    apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b)(*strict*)
    apply(rule List.set_take_subset)
   apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b)(*strict*)
   apply(rule_tac
      A="set(liftB (w'b @ Do # c))"
      in set_mp)
    apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b)(*strict*)
    apply(force)
   apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b)(*strict*)
   apply (metis liftB_BiElem head_in_set not_in_setBI set_append_contra2)
  apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b natc)(*strict*)
  apply(clarsimp)
  apply(case_tac c)
   apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b natc)(*strict*)
   apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b natc a listb)(*strict*)
  apply(subgoal_tac "\<exists>w' x'. c = w' @ [x']")
   apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b natc a listb)(*strict*)
   prefer 2
   apply(rule NonEmptyListHasTailElem)
   apply(force)
  apply(rename_tac c d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b natc a listb)(*strict*)
  apply(thin_tac "c=a#listb")
  apply(clarsimp)
  apply(rename_tac d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b natc w' x')(*strict*)
  apply(subgoal_tac "x'=Do")
   apply(rename_tac d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b natc w' x')(*strict*)
   prefer 2
   apply(rule_tac
      v="w'a"
      and w="w'b@Do#w'"
      in liftB_terminal_tail_equals)
   apply(clarsimp)
  apply(rename_tac d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b natc w' x')(*strict*)
  apply(clarsimp)
  apply(rename_tac d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b natc w')(*strict*)
  apply(subgoal_tac "w'a=liftB (w'b@Do#w')")
   apply(rename_tac d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b natc w')(*strict*)
   prefer 2
   apply(rule liftB_terminal_butlast_equals)
   apply(force)
  apply(rename_tac d da e1 e2 e1a e2a e ea w wa nat nata list lista w'a natb w'b natc w')(*strict*)
  apply(clarsimp)
  apply(rename_tac d da e1 e2 e1a e2a e ea w wa nat nata list lista natb w'b natc w')(*strict*)
  apply(subgoal_tac "teB Do \<in> set (liftB (w'b @ Do # w'))")
   apply(rename_tac d da e1 e2 e1a e2a e ea w wa nat nata list lista natb w'b natc w')(*strict*)
   apply(subgoal_tac "teB Do \<notin> set (liftB (w'b @ Do # w'))")
    apply(rename_tac d da e1 e2 e1a e2a e ea w wa nat nata list lista natb w'b natc w')(*strict*)
    apply(force)
   apply(rename_tac d da e1 e2 e1a e2a e ea w wa nat nata list lista natb w'b natc w')(*strict*)
   apply(force)
  apply(rename_tac d da e1 e2 e1a e2a e ea w wa nat nata list lista natb w'b natc w')(*strict*)
  apply (metis liftB_BiElem head_in_set not_in_setBI set_append_contra2)
  done

theorem no_reduce_reduce_conflicts: "
  AF_LR_PARSER_input G F Do S' G' M P k
  \<Longrightarrow> conflict_free G G' k
  \<Longrightarrow> (parser_marker P) r1 = Some (Some \<lparr>prod_lhs = A1, prod_rhs = w1\<rparr>)
  \<Longrightarrow> (parser_marker P) r2 = Some (Some \<lparr>prod_lhs = A2, prod_rhs = w2\<rparr>)
  \<Longrightarrow> r1 \<in> parser_rules P
  \<Longrightarrow> r2 \<in> parser_rules P
  \<Longrightarrow> rule_lpop r2 \<sqsupseteq> rule_lpop r1 \<or> rule_lpop r1 \<sqsupseteq> rule_lpop r2
  \<Longrightarrow> rule_rpop r1 \<sqsubseteq> rule_rpop r2 \<or> rule_rpop r2 \<sqsubseteq> rule_rpop r1
  \<Longrightarrow> r1 = r2"
  apply(case_tac r1)
  apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
  apply(subgoal_tac " rule_rpopa=rule_rpush \<and> \<lparr>prod_lhs=A1,prod_rhs=w1\<rparr> \<in> (cfg_productions G) \<and> (\<exists>q\<delta>. rule_lpopa=q\<delta>#F_DFA_GOTO_SEQUENCE M q\<delta> w1 \<and> rule_lpush=q\<delta>#(F_DFA_GOTO_SEQUENCE M q\<delta> [teA A1]) \<and> (\<exists>\<delta>. \<lparr>cfg_item_lhs = A1,cfg_item_rhs1 = w1,cfg_item_rhs2 = [],cfg_item_look_ahead = rule_rpopa\<rparr> \<in> valid_item_set G' k (teB Do#\<delta>@w1) \<and> q\<delta>=last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do#\<delta>))))")
   apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
   prefer 2
   apply(rule_tac
      S'="S'"
      and Do="Do"
      and G'="G'"
      and G="G"
      in X6_3_InformationOnRules_reduce2)
            apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
            apply(simp add: AF_LR_PARSER_input_def)
           apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
           apply(simp add: AF_LR_PARSER_input_def)
           apply(force)
          apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(simp add: AF_LR_PARSER_input_def)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
      apply(simp add: AF_LR_PARSER_input_def)
     apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
     apply(force)
    apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
    apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
    apply(simp add: AF_LR_PARSER_input_def)
   apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
   apply(simp add: AF_LR_PARSER_input_def)
  apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
  apply(case_tac r2)
  apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
  apply(subgoal_tac " rule_rpopaa=rule_rpusha \<and> \<lparr>prod_lhs=A2,prod_rhs=w2\<rparr> \<in> (cfg_productions G) \<and> (\<exists>q\<delta>. rule_lpopaa=q\<delta>#F_DFA_GOTO_SEQUENCE M q\<delta> w2 \<and> rule_lpusha=q\<delta>#(F_DFA_GOTO_SEQUENCE M q\<delta> [teA A2]) \<and> (\<exists>\<delta>. \<lparr>cfg_item_lhs = A2,cfg_item_rhs1 = w2,cfg_item_rhs2 = [],cfg_item_look_ahead = rule_rpopaa\<rparr> \<in> valid_item_set G' k (teB Do#\<delta>@w2) \<and> q\<delta>=last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do#\<delta>))))")
   apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
   prefer 2
   apply(rule_tac
      S'="S'"
      and Do="Do"
      and G'="G'"
      and G="G"
      in X6_3_InformationOnRules_reduce2)
            apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
            apply(simp add: AF_LR_PARSER_input_def)
           apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
           apply(simp add: AF_LR_PARSER_input_def)
           apply(force)
          apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
        apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
      apply(force)
     apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
     apply(force)
    apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
    apply(simp add: AF_LR_PARSER_input_def)
   apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
   apply(simp add: AF_LR_PARSER_input_def)
  apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
  apply(thin_tac "parser_marker P r1 = Some (Some \<lparr>prod_lhs = A1, prod_rhs = w1\<rparr>)")
  apply(thin_tac "parser_marker P r2 = Some (Some \<lparr>prod_lhs = A2, prod_rhs = w2\<rparr>)")
  apply(clarsimp)
  apply(rename_tac rule_rpush rule_rpusha \<delta> \<delta>')(*strict*)
  apply(thin_tac "\<lparr>rule_lpop = last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>)) # F_DFA_GOTO_SEQUENCE M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>))) w1, rule_rpop = rule_rpush, rule_lpush = last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>)) # F_DFA_GOTO_SEQUENCE M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>))) [teA A1], rule_rpush = rule_rpush\<rparr> \<in> parser_rules P")
  apply(rename_tac rule_rpush rule_rpusha \<delta> \<delta>')(*strict*)
  apply(thin_tac "\<lparr>rule_lpop = last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>')) # F_DFA_GOTO_SEQUENCE M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>'))) w2, rule_rpop = rule_rpusha, rule_lpush = last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>')) # F_DFA_GOTO_SEQUENCE M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>'))) [teA A2], rule_rpush = rule_rpusha\<rparr> \<in> parser_rules P")
  apply(rename_tac rule_rpush rule_rpusha \<delta> \<delta>')(*strict*)
  apply(rename_tac y1 y2 v1 v2)
  apply(rename_tac y1 y2 v1 v2)(*strict*)
  apply(subgoal_tac "valid_cfg G'")
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   prefer 2
   apply(rule F_CFG_AUGMENT__makes_CFG)
   apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
   apply(force)
  apply(rename_tac y1 y2 v1 v2)(*strict*)
  apply(subgoal_tac "valid_dfa M")
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   prefer 2
   apply(rule_tac
      G="G'"
      in Theorem6__27_a)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(simp add: AF_LR_PARSER_input_def)
    apply(force)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
  apply(rename_tac y1 y2 v1 v2)(*strict*)
  apply(subgoal_tac "some_step_from_every_configuration M")
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   prefer 2
   apply(rule_tac
      G="G'"
      in F_LR_MACHINE_Complete)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(simp add: AF_LR_PARSER_input_def)
    apply(force)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
  apply(rename_tac y1 y2 v1 v2)(*strict*)
  apply(subgoal_tac "every_state_in_some_accessible_configuration M")
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   prefer 2
   apply(rule F_LR_MACHINE_all_Connected)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      prefer 2
      apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
      apply(force)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(force)
  apply(rename_tac y1 y2 v1 v2)(*strict*)
  apply(subgoal_tac "some_step_from_every_configuration M")
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   prefer 2
   apply(rule_tac
      G="G'"
      in F_LR_MACHINE_Complete)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(force)
   apply(simp add: AF_LR_PARSER_input_def)
  apply(rename_tac y1 y2 v1 v2)(*strict*)
  apply(subgoal_tac "valid_parser P")
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   prefer 2
   apply(rule_tac
      G="G"
      in AF_LR_PARSER_valid_parser)
         apply(rename_tac y1 y2 v1 v2)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
        apply(simp add: AF_LR_PARSER_input_def)
        apply(rename_tac y1 y2 v1 v2)(*strict*)
        apply(force)
       apply(rename_tac y1 y2 v1 v2)(*strict*)
       apply(force)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      apply(force)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(simp add: AF_LR_PARSER_input_def)
   apply(simp add: AF_LR_PARSER_input_def)
  apply(rename_tac y1 y2 v1 v2)(*strict*)
  apply(subgoal_tac "set (teB Do # v1 @ w1) \<subseteq> two_elements_construct_domain (cfg_nonterminals G') (cfg_events G')")
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   prefer 2
   apply(rule viable_prefix_in_CFG)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(simp add: AF_LR_PARSER_input_def)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(rule Fact6_12__1)
   apply(force)
  apply(rename_tac y1 y2 v1 v2)(*strict*)
  apply(subgoal_tac "set (teB Do # v2 @ w2) \<subseteq> two_elements_construct_domain (cfg_nonterminals G') (cfg_events G')")
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   prefer 2
   apply(rule viable_prefix_in_CFG)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(simp add: AF_LR_PARSER_input_def)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(rule Fact6_12__1)
   apply(force)
  apply(rename_tac y1 y2 v1 v2)(*strict*)
  apply(subgoal_tac "valid_item_set G' k (teB Do # v1 @ w1)=valid_item_set G' k (teB Do # v2 @ w2)")
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   prefer 2
   apply(subgoal_tac "valid_item_set G' k (teB Do # v1 @ w1) = (if (teB Do # v1 @ w1)=[] then (epda_initial M) else last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v1 @ w1)))")
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    prefer 2
    apply(rule F_LR_MACHINE_all_SOUND)
          apply(rename_tac y1 y2 v1 v2)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(rename_tac y1 y2 v1 v2)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
         apply(force)
        apply(rename_tac y1 y2 v1 v2)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(rename_tac y1 y2 v1 v2)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(simp add: AF_LR_PARSER_input_def)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     prefer 2
     apply (metis two_elements_construct_domain_setB)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply (metis two_elements_construct_domain_setA)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(subgoal_tac "valid_item_set G' k (teB Do # v2 @ w2) = (if (teB Do # v2 @ w2)=[] then (epda_initial M) else last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2 @ w2)))")
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    prefer 2
    apply(rule F_LR_MACHINE_all_SOUND)
          apply(rename_tac y1 y2 v1 v2)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(rename_tac y1 y2 v1 v2)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
         apply(force)
        apply(rename_tac y1 y2 v1 v2)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(rename_tac y1 y2 v1 v2)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(simp add: AF_LR_PARSER_input_def)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     prefer 2
     apply (metis two_elements_construct_domain_setB)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply (metis two_elements_construct_domain_setA)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(subgoal_tac "valid_item_set G' k (teB Do # v1) = (if (teB Do # v1)=[] then (epda_initial M) else last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v1)))")
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    prefer 2
    apply(rule F_LR_MACHINE_all_SOUND)
          apply(rename_tac y1 y2 v1 v2)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(rename_tac y1 y2 v1 v2)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
         apply(force)
        apply(rename_tac y1 y2 v1 v2)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(rename_tac y1 y2 v1 v2)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(simp add: AF_LR_PARSER_input_def)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     prefer 2
     apply (rule two_elements_construct_domain_setB)
     apply(rule_tac
      B="set (teB Do # v1 @ w1)"
      in subset_trans)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      apply(force)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply (rule two_elements_construct_domain_setA)
    apply(rule_tac
      B="set (teB Do # v1 @ w1)"
      in subset_trans)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(force)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(subgoal_tac "valid_item_set G' k (teB Do # v2) = (if (teB Do # v2)=[] then (epda_initial M) else last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2)))")
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    prefer 2
    apply(rule F_LR_MACHINE_all_SOUND)
          apply(rename_tac y1 y2 v1 v2)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(rename_tac y1 y2 v1 v2)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
         apply(force)
        apply(rename_tac y1 y2 v1 v2)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(rename_tac y1 y2 v1 v2)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(simp add: AF_LR_PARSER_input_def)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     prefer 2
     apply (rule two_elements_construct_domain_setB)
     apply(rule_tac
      B="set (teB Do # v2 @ w2)"
      in subset_trans)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      apply(force)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply (rule two_elements_construct_domain_setA)
    apply(rule_tac
      B="set (teB Do # v2 @ w2)"
      in subset_trans)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(force)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(clarsimp)
   apply(subgoal_tac "length w2 = length (F_DFA_GOTO_SEQUENCE M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2))) w2)")
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    prefer 2
    apply(rule F_DFA_GOTO_SEQUENCESound_main1)
         apply(rename_tac y1 y2 v1 v2)(*strict*)
         apply(force)
        apply(rename_tac y1 y2 v1 v2)(*strict*)
        apply(force)
       apply(rename_tac y1 y2 v1 v2)(*strict*)
       apply(force)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      prefer 2
      apply(simp add: AF_LR_PARSER_input_def F_LR_MACHINE_def)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     prefer 2
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(rule_tac
      t="last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2))"
      and s="valid_item_set G' k (teB Do # v2)"
      in ssubst)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(rule LRM_contains_theEqClasses2)
       apply(rename_tac y1 y2 v1 v2)(*strict*)
       apply(force)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      apply(simp add: AF_LR_PARSER_input_def)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      apply(force)
     apply(simp add: AF_LR_PARSER_input_def)
    apply(force)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(subgoal_tac "length w1 = length (F_DFA_GOTO_SEQUENCE M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v1))) w1)")
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    prefer 2
    apply(rule F_DFA_GOTO_SEQUENCESound_main1)
         apply(rename_tac y1 y2 v1 v2)(*strict*)
         apply(force)
        apply(rename_tac y1 y2 v1 v2)(*strict*)
        apply(force)
       apply(rename_tac y1 y2 v1 v2)(*strict*)
       apply(force)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      prefer 2
      apply(simp add: AF_LR_PARSER_input_def F_LR_MACHINE_def)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     prefer 2
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(rule_tac
      t="last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v1))"
      and s="valid_item_set G' k (teB Do # v1)"
      in ssubst)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(rule LRM_contains_theEqClasses2)
       apply(rename_tac y1 y2 v1 v2)(*strict*)
       apply(force)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      apply(simp add: AF_LR_PARSER_input_def)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      apply(force)
     apply(simp add: AF_LR_PARSER_input_def)
    apply(force)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(subgoal_tac "length (teB Do#v2) = length (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2))")
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    prefer 2
    apply(rule F_DFA_GOTO_SEQUENCESound_main1)
         apply(rename_tac y1 y2 v1 v2)(*strict*)
         apply(force)
        apply(rename_tac y1 y2 v1 v2)(*strict*)
        apply(force)
       apply(rename_tac y1 y2 v1 v2)(*strict*)
       apply(force)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      prefer 2
      apply(simp add: AF_LR_PARSER_input_def F_LR_MACHINE_def)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     prefer 2
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(simp add: valid_dfa_def valid_dpda_def valid_pda_def valid_epda_def)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(subgoal_tac "length (teB Do#v1) = length (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v1))")
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    prefer 2
    apply(rule F_DFA_GOTO_SEQUENCESound_main1)
         apply(rename_tac y1 y2 v1 v2)(*strict*)
         apply(force)
        apply(rename_tac y1 y2 v1 v2)(*strict*)
        apply(force)
       apply(rename_tac y1 y2 v1 v2)(*strict*)
       apply(force)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      prefer 2
      apply(simp add: AF_LR_PARSER_input_def F_LR_MACHINE_def)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     prefer 2
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(simp add: valid_dfa_def valid_dpda_def valid_pda_def valid_epda_def)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(rule_tac
      t="last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2 @ w2))"
      and s="last((last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2)) # F_DFA_GOTO_SEQUENCE M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2))) w2))"
      in ssubst)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(clarsimp)
    apply(case_tac w2)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2 a list)(*strict*)
    apply(rule conjI)
     apply(rename_tac y1 y2 v1 v2 a list)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2 a list)(*strict*)
    apply(rule impI)
    apply(subgoal_tac "\<exists>w' x'. w2 = w' @ [x']")
     apply(rename_tac y1 y2 v1 v2 a list)(*strict*)
     prefer 2
     apply(rule_tac
      n="length list"
      in NonEmptyListHasTailElem)
     apply(force)
    apply(rename_tac y1 y2 v1 v2 a list)(*strict*)
    apply(thin_tac "w2=a#list")
    apply(clarsimp)
    apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
    apply(rule_tac
      t="teB Do # v2 @ w' @ [x']"
      and s="(teB Do # v2) @ (w' @ [x'])"
      in ssubst)
     apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
    apply(rule_tac
      t="F_DFA_GOTO_SEQUENCE M (epda_initial M) ((teB Do # v2) @ (w' @ [x']))"
      and s="F_DFA_GOTO_SEQUENCE M SSp SSw1 @ (F_DFA_GOTO_SEQUENCE M (last (SSp#(F_DFA_GOTO_SEQUENCE M SSp SSw1))) SSw2)" for SSp SSw1 SSw2
      in ssubst)
     apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
     apply(rule F_DFA_GOTO_SEQUENCE_append_split)
          apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
          apply(force)
         apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
         apply(force)
        apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
        apply(force)
       apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
       apply(force)
      apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
      apply(simp add: AF_LR_PARSER_input_def F_LR_MACHINE_def)
     apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
     apply(simp add: AF_LR_PARSER_input_def F_LR_MACHINE_def)
    apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
    apply(clarsimp)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(rule_tac
      t="last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v1 @ w1))"
      and s="last((last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v1)) # F_DFA_GOTO_SEQUENCE M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v1))) w1))"
      in ssubst)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(clarsimp)
    apply(case_tac w1)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2 a list)(*strict*)
    apply(rule conjI)
     apply(rename_tac y1 y2 v1 v2 a list)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2 a list)(*strict*)
    apply(rule impI)
    apply(subgoal_tac "\<exists>w' x'. w1 = w' @ [x']")
     apply(rename_tac y1 y2 v1 v2 a list)(*strict*)
     prefer 2
     apply(rule_tac
      n="length list"
      in NonEmptyListHasTailElem)
     apply(force)
    apply(rename_tac y1 y2 v1 v2 a list)(*strict*)
    apply(thin_tac "w1=a#list")
    apply(clarsimp)
    apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
    apply(rule_tac
      t="teB Do # v1 @ w' @ [x']"
      and s="(teB Do # v1) @ (w' @ [x'])"
      in ssubst)
     apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
    apply(rule_tac
      t="F_DFA_GOTO_SEQUENCE M (epda_initial M) ((teB Do # v1) @ (w' @ [x']))"
      and s="F_DFA_GOTO_SEQUENCE M SSp SSw1 @ (F_DFA_GOTO_SEQUENCE M (last (SSp#(F_DFA_GOTO_SEQUENCE M SSp SSw1))) SSw2)" for SSp SSw1 SSw2
      in ssubst)
     apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
     apply(rule F_DFA_GOTO_SEQUENCE_append_split)
          apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
          apply(force)
         apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
         apply(force)
        apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
        apply(force)
       apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
       apply(force)
      apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
      apply(simp add: AF_LR_PARSER_input_def F_LR_MACHINE_def)
     apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
     apply(simp add: AF_LR_PARSER_input_def F_LR_MACHINE_def)
    apply(rename_tac y1 y2 v1 v2 w' x')(*strict*)
    apply(clarsimp)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(rule suffix_last_eq)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(force)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(force)
  apply(rename_tac y1 y2 v1 v2)(*strict*)
  apply(subgoal_tac "y1=y2")
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(simp only: conflict_free_def)
   apply(erule_tac
      x="(teB Do # v1 @ w1)"
      in allE)
   apply(erule impE)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(force)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(erule conjE)+
   apply(thin_tac "\<forall>I1 I2. I1 \<in> valid_item_set G' k (teB Do # v1 @ w1) \<and> I2 \<in> valid_item_set G' k (teB Do # v1 @ w1) \<and> item_core I1 \<in> cfg_productions G \<and> item_core I2 \<in> cfg_productions G \<longrightarrow> \<not> item_shift_reduce_conflict G' k I1 I2")
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(erule_tac
      x="\<lparr>cfg_item_lhs = A1, cfg_item_rhs1 = w1, cfg_item_rhs2 = [], cfg_item_look_ahead = y1\<rparr>"
      in allE)
   apply(erule_tac
      x="\<lparr>cfg_item_lhs = A2, cfg_item_rhs1 = w2, cfg_item_rhs2 = [], cfg_item_look_ahead = y2\<rparr>"
      in allE)
   apply(erule impE)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(rule conjI)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(rule conjI)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(simp add: item_core_def)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(simp add: item_reduce_reduce_conflict_def)
   apply(subgoal_tac " F_DFA_GOTO_SEQUENCE M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2))) w2 = F_DFA_GOTO_SEQUENCE M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v1))) w2 \<and> last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2)) = last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v1))")
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    prefer 2
    apply(rule mutual_prefix_equal_suffix)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(subgoal_tac "valid_item_set G' k (teB Do # v1) = (if (teB Do # v1)=[] then (epda_initial M) else last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v1)))")
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     prefer 2
     apply(rule F_LR_MACHINE_all_SOUND)
           apply(rename_tac y1 y2 v1 v2)(*strict*)
           apply(simp add: AF_LR_PARSER_input_def)
          apply(rename_tac y1 y2 v1 v2)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
          apply(force)
         apply(rename_tac y1 y2 v1 v2)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
        apply(rename_tac y1 y2 v1 v2)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      prefer 2
      apply (rule two_elements_construct_domain_setB)
      apply(rule_tac
      B="set (teB Do # v1 @ w1)"
      in subset_trans)
       apply(rename_tac y1 y2 v1 v2)(*strict*)
       apply(force)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      apply(force)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply (rule two_elements_construct_domain_setA)
     apply(rule_tac
      B="set (teB Do # v1 @ w1)"
      in subset_trans)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      apply(force)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(subgoal_tac "valid_item_set G' k (teB Do # v2) = (if (teB Do # v2)=[] then (epda_initial M) else last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2)))")
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     prefer 2
     apply(rule F_LR_MACHINE_all_SOUND)
           apply(rename_tac y1 y2 v1 v2)(*strict*)
           apply(simp add: AF_LR_PARSER_input_def)
          apply(rename_tac y1 y2 v1 v2)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
          apply(force)
         apply(rename_tac y1 y2 v1 v2)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
        apply(rename_tac y1 y2 v1 v2)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      prefer 2
      apply (rule two_elements_construct_domain_setB)
      apply(rule_tac
      B="set (teB Do # v2 @ w2)"
      in subset_trans)
       apply(rename_tac y1 y2 v1 v2)(*strict*)
       apply(force)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      apply(force)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply (rule two_elements_construct_domain_setA)
     apply(rule_tac
      B="set (teB Do # v2 @ w2)"
      in subset_trans)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      apply(force)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(clarsimp)
    apply(rename_tac y2 v1 v2)(*strict*)
    apply(subgoal_tac "length w2 = length (F_DFA_GOTO_SEQUENCE M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2))) w2)")
     apply(rename_tac y2 v1 v2)(*strict*)
     prefer 2
     apply(rule F_DFA_GOTO_SEQUENCESound_main1)
          apply(rename_tac y2 v1 v2)(*strict*)
          apply(force)
         apply(rename_tac y2 v1 v2)(*strict*)
         apply(force)
        apply(rename_tac y2 v1 v2)(*strict*)
        apply(force)
       apply(rename_tac y2 v1 v2)(*strict*)
       prefer 2
       apply(simp add: AF_LR_PARSER_input_def F_LR_MACHINE_def)
      apply(rename_tac y2 v1 v2)(*strict*)
      prefer 2
      apply(force)
     apply(rename_tac y2 v1 v2)(*strict*)
     apply(rule_tac
      t="last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2))"
      and s="valid_item_set G' k (teB Do # v2)"
      in ssubst)
      apply(rename_tac y2 v1 v2)(*strict*)
      apply(force)
     apply(rename_tac y2 v1 v2)(*strict*)
     apply(rule LRM_contains_theEqClasses2)
        apply(rename_tac y2 v1 v2)(*strict*)
        apply(force)
       apply(simp add: AF_LR_PARSER_input_def)
       apply(force)
      apply(rename_tac y2 v1 v2)(*strict*)
      apply(simp add: AF_LR_PARSER_input_def)
     apply(rename_tac y2 v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y2 v1 v2)(*strict*)
    apply(subgoal_tac "length w2 = length (F_DFA_GOTO_SEQUENCE M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v1))) w2)")
     apply(rename_tac y2 v1 v2)(*strict*)
     prefer 2
     apply(rule F_DFA_GOTO_SEQUENCESound_main1)
          apply(rename_tac y2 v1 v2)(*strict*)
          apply(force)
         apply(rename_tac y2 v1 v2)(*strict*)
         apply(force)
        apply(rename_tac y2 v1 v2)(*strict*)
        apply(force)
       apply(rename_tac y2 v1 v2)(*strict*)
       prefer 2
       apply(simp add: AF_LR_PARSER_input_def F_LR_MACHINE_def)
      apply(rename_tac y2 v1 v2)(*strict*)
      prefer 2
      apply(force)
     apply(rename_tac y2 v1 v2)(*strict*)
     apply(rule_tac
      t="last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v1))"
      and s="valid_item_set G' k (teB Do # v1)"
      in ssubst)
      apply(rename_tac y2 v1 v2)(*strict*)
      apply(force)
     apply(rename_tac y2 v1 v2)(*strict*)
     apply(rule LRM_contains_theEqClasses2)
        apply(rename_tac y2 v1 v2)(*strict*)
        apply(force)
       apply(rename_tac y2 v1 v2)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
       apply(rename_tac y2 v1 v2)(*strict*)
       apply(force)
      apply(simp add: AF_LR_PARSER_input_def)
     apply(force)
    apply(rename_tac y2 v1 v2)(*strict*)
    apply(clarsimp)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(clarsimp)
  apply(rename_tac y1 y2 v1 v2)(*strict*)
  apply(subgoal_tac "valid_item_set G' k (teB Do # v1 @ w1) \<in> epda_states M")
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   prefer 2
   apply(rule LRM_contains_theEqClasses2)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      apply(force)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(simp add: AF_LR_PARSER_input_def)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(simp add: AF_LR_PARSER_input_def)
   apply(force)
  apply(rename_tac y1 y2 v1 v2)(*strict*)
  apply(erule_tac
      P="y1 \<sqsubseteq> y2"
      in disjE)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(rule no_reduce_reduce_conflicts_hlp)
       apply(rename_tac y1 y2 v1 v2)(*strict*)
       apply(force)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      apply(force)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(force)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(force)
  apply(rename_tac y1 y2 v1 v2)(*strict*)
  apply(rule sym)
  apply(rule no_reduce_reduce_conflicts_hlp)
      apply(rename_tac y1 y2 v1 v2)(*strict*)
      apply(force)
     apply(rename_tac y1 y2 v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y2 v1 v2)(*strict*)
    apply(force)
   apply(rename_tac y1 y2 v1 v2)(*strict*)
   apply(force)
  apply(rename_tac y1 y2 v1 v2)(*strict*)
  apply(force)
  done

lemma translate_cfgSTD_first_with_single: "
  AF_LR_PARSER_input G F Do S' G' M P k
  \<Longrightarrow> y \<in> cfgSTD_first G' (k - Suc 0) w
  \<Longrightarrow> take k (a # y) \<in> cfgSTD_first G' k (teB a # w)"
  apply(simp add: cfgSTD_first_def)
  apply(clarsimp)
  apply(rename_tac x d e1 n)(*strict*)
  apply(rule inMap)
  apply(clarsimp)
  apply(rule_tac
      x="a # x"
      in exI)
  apply(clarsimp)
  apply(rule conjI)
   apply(rename_tac x d e1 n)(*strict*)
   prefer 2
   apply(case_tac k)
    apply(rename_tac x d e1 n)(*strict*)
    apply(clarsimp)
   apply(rename_tac x d e1 n nat)(*strict*)
   apply(clarsimp)
  apply(rename_tac x d e1 n)(*strict*)
  apply(rule_tac
      x="derivation_map d (\<lambda>v. \<lparr>cfg_conf=(teB a)#(cfg_conf v)\<rparr>)"
      in exI)
  apply(rule conjI)
   apply(rename_tac x d e1 n)(*strict*)
   apply(rule cfgSTD.derivation_map_preserves_derivation2)
    apply(rename_tac x d e1 n)(*strict*)
    apply(force)
   apply(rename_tac x d e1 n)(*strict*)
   apply(clarsimp)
   apply(rename_tac x d e1 n aa e b)(*strict*)
   apply(simp add: cfgSTD_step_relation_def)
   apply(clarsimp)
   apply(rename_tac x d e1 n aa e b l r)(*strict*)
   apply(rule_tac
      x="teB a#l"
      in exI)
   apply(rule_tac
      x="r"
      in exI)
   apply(clarsimp)
  apply(rename_tac x d e1 n)(*strict*)
  apply(rule_tac
      x="e1"
      in exI)
  apply(rule_tac
      x="n"
      in exI)
  apply(simp add: derivation_map_def maximum_of_domain_def)
  done

theorem no_shift_reduce_conflicts: "
  AF_LR_PARSER_input G F Do S' G' M P k
  \<Longrightarrow> conflict_free G G' k
  \<Longrightarrow> (parser_marker P) r1 = Some None
  \<Longrightarrow> (parser_marker P) r2 = Some (Some \<lparr>prod_lhs = A2, prod_rhs = w2\<rparr>)
  \<Longrightarrow> r1 \<in> parser_rules P
  \<Longrightarrow> r2 \<in> parser_rules P
  \<Longrightarrow> rule_lpop r2 \<sqsupseteq> rule_lpop r1 \<or> rule_lpop r1 \<sqsupseteq> rule_lpop r2
  \<Longrightarrow> rule_rpop r1 \<sqsubseteq> rule_rpop r2 \<or> rule_rpop r2 \<sqsubseteq> rule_rpop r1
  \<Longrightarrow> r1 = r2"
  apply(case_tac r1)
  apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
  apply(subgoal_tac " \<exists>q\<delta> y \<beta> z A \<alpha> a \<delta>. y \<in> (cfgSTD_first G' (k- 1) (\<beta>@(liftB z))) \<and> \<lparr>prod_lhs=A,prod_rhs=\<alpha>@(teB a)#\<beta>\<rparr> \<in> cfg_productions G \<and> q\<delta>=last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do#\<delta>)) \<and> \<lparr>cfg_item_lhs = A,cfg_item_rhs1 = \<alpha>,cfg_item_rhs2 = (teB a)#\<beta>,cfg_item_look_ahead = z\<rparr> \<in> valid_item_set G' k (teB Do#\<delta>) \<and> rule_lpopa=[q\<delta>] \<and> rule_rpopa=a#y \<and> rule_lpush=[q\<delta>,F_DFA_GOTO M q\<delta> (teB a)] \<and> rule_rpush=y")
   apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
   prefer 2
   apply(rule_tac
      S'="S'"
      and Do="Do"
      and G'="G'"
      and G="G"
      in X6_3_InformationOnRules_shift2)
            apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
            apply(simp add: AF_LR_PARSER_input_def)
           apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
           apply(simp add: AF_LR_PARSER_input_def)
           apply(force)
          apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
        apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(force)
     apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
     apply(force)
    apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
    apply(simp add: AF_LR_PARSER_input_def)
   apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
   apply(simp add: AF_LR_PARSER_input_def)
  apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush)(*strict*)
  apply(case_tac r2)
  apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
  apply(subgoal_tac " rule_rpopaa=rule_rpusha \<and> \<lparr>prod_lhs=A2,prod_rhs=w2\<rparr> \<in> (cfg_productions G) \<and> (\<exists>q\<delta>. rule_lpopaa=q\<delta>#F_DFA_GOTO_SEQUENCE M q\<delta> w2 \<and> rule_lpusha=q\<delta>#(F_DFA_GOTO_SEQUENCE M q\<delta> [teA A2]) \<and> (\<exists>\<delta>. \<lparr>cfg_item_lhs = A2,cfg_item_rhs1 = w2,cfg_item_rhs2 = [],cfg_item_look_ahead = rule_rpopaa\<rparr> \<in> valid_item_set G' k (teB Do#\<delta>@w2) \<and> q\<delta>=last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do#\<delta>))))")
   apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
   prefer 2
   apply(rule_tac
      S'="S'"
      and Do="Do"
      and G'="G'"
      and G="G"
      in X6_3_InformationOnRules_reduce2)
            apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
            apply(simp add: AF_LR_PARSER_input_def)
           apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
           apply(simp add: AF_LR_PARSER_input_def)
           apply(force)
          apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
        apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(force)
     apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
     apply(force)
    apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
    apply(simp add: AF_LR_PARSER_input_def)
   apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
   apply(simp add: AF_LR_PARSER_input_def)
  apply(rename_tac rule_lpopa rule_rpopa rule_lpush rule_rpush rule_lpopaa rule_rpopaa rule_lpusha rule_rpusha)(*strict*)
  apply(thin_tac "parser_marker P r1 = Some None")
  apply(thin_tac "parser_marker P r2 = Some (Some \<lparr>prod_lhs = A2, prod_rhs = w2\<rparr>)")
  apply(clarsimp)
  apply(rename_tac rule_rpusha y \<beta> z A \<alpha> a \<delta> \<delta>')(*strict*)
  apply(thin_tac "\<lparr>rule_lpop = [last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>))], rule_rpop = a # y, rule_lpush = [last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>)), F_DFA_GOTO M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>))) (teB a)], rule_rpush = y\<rparr> \<in> parser_rules P")
  apply(rename_tac rule_rpusha y \<beta> z A \<alpha> a \<delta> \<delta>')(*strict*)
  apply(thin_tac "\<lparr>rule_lpop = last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>')) # F_DFA_GOTO_SEQUENCE M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>'))) w2, rule_rpop = rule_rpusha, rule_lpush = last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>')) # F_DFA_GOTO_SEQUENCE M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # \<delta>'))) [teA A2], rule_rpush = rule_rpusha\<rparr> \<in> parser_rules P")
  apply(rename_tac rule_rpusha y \<beta> z A \<alpha> a \<delta> \<delta>')(*strict*)
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
  apply(subgoal_tac "valid_cfg G'")
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   prefer 2
   apply(rule F_CFG_AUGMENT__makes_CFG)
   apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
   apply(force)
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
  apply(subgoal_tac "valid_dfa M")
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   prefer 2
   apply(rule_tac
      G="G'"
      in Theorem6__27_a)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(force)
   apply(simp add: AF_LR_PARSER_input_def)
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
  apply(subgoal_tac "some_step_from_every_configuration M")
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   prefer 2
   apply(rule_tac
      G="G'"
      in F_LR_MACHINE_Complete)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(force)
   apply(simp add: AF_LR_PARSER_input_def)
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
  apply(subgoal_tac "every_state_in_some_accessible_configuration M")
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   prefer 2
   apply(rule F_LR_MACHINE_all_Connected)
      apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
      prefer 2
      apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
      apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
      apply(force)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(simp add: AF_LR_PARSER_input_def)
   apply(force)
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
  apply(subgoal_tac "some_step_from_every_configuration M")
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   prefer 2
   apply(rule_tac
      G="G'"
      in F_LR_MACHINE_Complete)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(force)
   apply(simp add: AF_LR_PARSER_input_def)
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
  apply(subgoal_tac "valid_parser P")
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   prefer 2
   apply(rule_tac
      G="G"
      in AF_LR_PARSER_valid_parser)
         apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
        apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
        apply(force)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
      apply(force)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply(force)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(simp add: AF_LR_PARSER_input_def)
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
  apply(subgoal_tac "set (teB Do # v1) \<subseteq> two_elements_construct_domain (cfg_nonterminals G') (cfg_events G')")
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   prefer 2
   apply(rule viable_prefix_in_CFG)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply(simp add: AF_LR_PARSER_input_def)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(rule Fact6_12__1)
   apply(force)
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
  apply(subgoal_tac "set (teB Do # v2 @ w2) \<subseteq> two_elements_construct_domain (cfg_nonterminals G') (cfg_events G')")
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   prefer 2
   apply(rule viable_prefix_in_CFG)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply(simp add: AF_LR_PARSER_input_def)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(rule Fact6_12__1)
   apply(force)
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
  apply(subgoal_tac "valid_item_set G' k (teB Do # v1)=valid_item_set G' k (teB Do # v2 @ w2)")
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   prefer 2
   apply(subgoal_tac "valid_item_set G' k (teB Do # v1) = (if (teB Do # v1)=[] then (epda_initial M) else last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v1)))")
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    prefer 2
    apply(rule F_LR_MACHINE_all_SOUND)
          apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
         apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
         apply(force)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(simp add: AF_LR_PARSER_input_def)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
     prefer 2
     apply (metis two_elements_construct_domain_setB)
    apply(simp add: AF_LR_PARSER_input_def)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply (metis two_elements_construct_domain_setA)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(subgoal_tac "valid_item_set G' k (teB Do # v2 @ w2) = (if (teB Do # v2 @ w2)=[] then (epda_initial M) else last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2 @ w2)))")
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    prefer 2
    apply(rule F_LR_MACHINE_all_SOUND)
          apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
         apply(force)
        apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(force)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
     prefer 2
     apply (metis two_elements_construct_domain_setB)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply (metis two_elements_construct_domain_setA)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(subgoal_tac "valid_item_set G' k (teB Do # v2) = (if (teB Do # v2)=[] then (epda_initial M) else last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2)))")
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    prefer 2
    apply(rule F_LR_MACHINE_all_SOUND)
          apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
         apply(force)
        apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(force)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
     prefer 2
     apply (rule two_elements_construct_domain_setB)
     apply(rule_tac
      B="set (teB Do # v2 @ w2)"
      in subset_trans)
      apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
      apply(force)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply (rule two_elements_construct_domain_setA)
    apply(rule_tac
      B="set (teB Do # v2 @ w2)"
      in subset_trans)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply(force)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(clarsimp)
   apply(subgoal_tac "length w2 = length (F_DFA_GOTO_SEQUENCE M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2))) w2)")
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    prefer 2
    apply(rule F_DFA_GOTO_SEQUENCESound_main1)
         apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
         apply(force)
        apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
        apply(force)
       apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
       apply(force)
      apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
      prefer 2
      apply(simp add: AF_LR_PARSER_input_def F_LR_MACHINE_def)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
     prefer 2
     apply(force)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply(rule_tac
      t="last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2))"
      and s="valid_item_set G' k (teB Do # v2)"
      in ssubst)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply(rule LRM_contains_theEqClasses2)
       apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
       apply(force)
      apply(simp add: AF_LR_PARSER_input_def)
      apply(force)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
     apply(simp add: AF_LR_PARSER_input_def)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply(force)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(subgoal_tac "length (teB Do#v2) = length (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2))")
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    prefer 2
    apply(rule F_DFA_GOTO_SEQUENCESound_main1)
         apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
         apply(force)
        apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
        apply(force)
       apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
       apply(force)
      apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
      prefer 2
      apply(simp add: AF_LR_PARSER_input_def F_LR_MACHINE_def)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
     prefer 2
     apply(force)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply(simp add: valid_dfa_def valid_dpda_def valid_pda_def valid_epda_def)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(subgoal_tac "length (teB Do#v1) = length (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v1))")
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    prefer 2
    apply(rule F_DFA_GOTO_SEQUENCESound_main1)
         apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
         apply(force)
        apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
        apply(force)
       apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
       apply(force)
      apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
      prefer 2
      apply(simp add: AF_LR_PARSER_input_def F_LR_MACHINE_def)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
     prefer 2
     apply(force)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply(simp add: valid_dfa_def valid_dpda_def valid_pda_def valid_epda_def)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(rule_tac
      t="last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2 @ w2))"
      and s="last((last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2)) # F_DFA_GOTO_SEQUENCE M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2))) w2))"
      in ssubst)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply(clarsimp)
    apply(case_tac w2)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 aa list)(*strict*)
    apply(rule conjI)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 aa list)(*strict*)
     apply(force)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 aa list)(*strict*)
    apply(rule impI)
    apply(subgoal_tac "\<exists>w' x'. w2 = w' @ [x']")
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 aa list)(*strict*)
     prefer 2
     apply(rule_tac
      n="length list"
      in NonEmptyListHasTailElem)
     apply(force)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 aa list)(*strict*)
    apply(thin_tac "w2=aa#list")
    apply(clarsimp)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 w' x')(*strict*)
    apply(rule_tac
      t="teB Do # v2 @ w' @ [x']"
      and s="(teB Do # v2) @ (w' @ [x'])"
      in ssubst)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 w' x')(*strict*)
     apply(force)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 w' x')(*strict*)
    apply(rule_tac
      t="F_DFA_GOTO_SEQUENCE M (epda_initial M) ((teB Do # v2) @ (w' @ [x']))"
      and s="F_DFA_GOTO_SEQUENCE M SSp SSw1 @ (F_DFA_GOTO_SEQUENCE M (last (SSp#(F_DFA_GOTO_SEQUENCE M SSp SSw1))) SSw2)" for SSp SSw1 SSw2
      in ssubst)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 w' x')(*strict*)
     apply(rule F_DFA_GOTO_SEQUENCE_append_split)
          apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 w' x')(*strict*)
          apply(force)
         apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 w' x')(*strict*)
         apply(force)
        apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 w' x')(*strict*)
        apply(force)
       apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 w' x')(*strict*)
       apply(force)
      apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 w' x')(*strict*)
      apply(simp add: AF_LR_PARSER_input_def F_LR_MACHINE_def)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 w' x')(*strict*)
     apply(simp add: AF_LR_PARSER_input_def F_LR_MACHINE_def)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 w' x')(*strict*)
    apply(clarsimp)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(rule_tac
      t="last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v1))"
      and s="last([last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v1))])"
      in ssubst)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    prefer 2
    apply(rule sym)
    apply(rule suffix_last_eq)
      apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
      apply(force)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
     apply(force)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply(force)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(force)
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
  apply(simp add: conflict_free_def)
  apply(erule_tac
      x="(teB Do # v2 @ w2)"
      in allE)
  apply(erule impE)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(force)
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
  apply(erule conjE)+
  apply(thin_tac "(\<forall>I1 I2. I1 \<in> valid_item_set G' k (teB Do # v2 @ w2) \<and> I2 \<in> valid_item_set G' k (teB Do # v2 @ w2) \<and> item_core I1 \<in> cfg_productions G \<and> item_core I2 \<in> cfg_productions G \<longrightarrow> \<not> item_reduce_reduce_conflict I1 I2)")
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
  apply(erule_tac
      x="\<lparr>cfg_item_lhs = A, cfg_item_rhs1 = \<alpha>, cfg_item_rhs2 = teB a # \<beta>, cfg_item_look_ahead = z\<rparr>"
      in allE)
  apply(erule_tac
      x="\<lparr>cfg_item_lhs = A2, cfg_item_rhs1 = w2, cfg_item_rhs2 = [], cfg_item_look_ahead = y1\<rparr>"
      in allE)
  apply(clarsimp)
  apply(erule impE)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(simp add: item_core_def)
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
  apply(simp add: item_shift_reduce_conflict_def)
  defer
  apply(subgoal_tac "valid_item_set G' k (teB Do # v2 @ w2) \<in> epda_states M")
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   prefer 2
   apply(rule LRM_contains_theEqClasses2)
      apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
      apply(force)
     apply(simp add: AF_LR_PARSER_input_def)
     apply(force)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply(simp add: AF_LR_PARSER_input_def)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(force)
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
  apply(subgoal_tac "y1 \<in> cfgSTD_first G' k (teB a # \<beta> @ liftB z)")
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(force)
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
  apply(subgoal_tac "take k (a#y) = y1")
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(clarify)
   apply(rule translate_cfgSTD_first_with_single)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply(force)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(force)
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
  apply(case_tac k)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(clarsimp)
   apply(subgoal_tac "valid_item G' 0 \<lparr>cfg_item_lhs = A2, cfg_item_rhs1 = w2, cfg_item_rhs2 = [], cfg_item_look_ahead = y1\<rparr>")
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply(simp add: valid_item_def)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(rule Fact6_12__2)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
    apply(force)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2)(*strict*)
   apply(force)
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
  apply(rule_tac
      t="k"
      and s="Suc nat"
      in ssubst)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
   apply(force)
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
  apply(rule_tac
      S'="S'"
      and Do="Do"
      and G'="G'"
      and G="G"
      in no_shift_reduce_conflicts_hlp)
              apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
              apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
             apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
             apply(force)
            apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
            apply(simp add: two_elements_construct_domain_def)
            apply(rule conjI)
             apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
             apply(clarsimp)
            apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
            apply(clarsimp)
            apply(erule_tac
      P="teB Do \<in> teA ` cfg_nonterminals G'"
      in disjE)
             apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
             apply(clarsimp)
            apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
            apply(clarsimp)
            apply(simp add: AF_LR_PARSER_input_def)
            apply(clarsimp)
            apply(subgoal_tac "F_FRESH (cfg_events G) \<notin> cfg_events G")
             apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
             apply(force)
            apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
            apply(rule F_FRESH_is_fresh)
            apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def F_LR_PARSER_def)
            apply(simp add: F_LR_MACHINE_def F_CFG_AUGMENT_def two_elements_construct_domain_def valid_cfg_def)
           apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
           apply(simp add: two_elements_construct_domain_def)
           apply(rule disjI2)
           apply(clarsimp)
           apply(rule inMap)
           apply(clarsimp)
           apply(simp add: AF_LR_PARSER_input_def valid_cfg_def)
           apply(clarsimp)
           apply(erule_tac
      A="cfg_productions G"
      and x="\<lparr>prod_lhs = A, prod_rhs = \<alpha> @ teB a # \<beta>\<rparr>"
      in ballE)
            apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
            prefer 2
            apply(force)
           apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
           apply(clarsimp)
           apply(simp add: setBConcat)
          apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
          apply(force)
         apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
         apply(force)
        apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
        prefer 3
        apply(force)
       apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
       prefer 3
       apply(force)
      apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
      apply(simp add: AF_LR_PARSER_input_def valid_cfg_def)
      apply(clarsimp)
      apply(erule_tac
      x="\<lparr>prod_lhs = A, prod_rhs = \<alpha> @ teB a # \<beta>\<rparr>"
      and A="cfg_productions G"
      in ballE)
       apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
       prefer 2
       apply(force)
      apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
      apply(clarsimp)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
     apply(simp add: AF_LR_PARSER_input_def valid_cfg_def)
     apply(clarsimp)
     apply(erule_tac
      x="\<lparr>prod_lhs = A2, prod_rhs = w2\<rparr>"
      and A="cfg_productions G"
      in ballE)
      apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
      prefer 2
      apply(force)
     apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
     apply(clarsimp)
    apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
    apply(force)
   apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
   apply(simp add: cfgSTD_first_def)
   apply(clarsimp)
  apply(rename_tac y1 y \<beta> z A \<alpha> a v1 v2 nat)(*strict*)
  apply(clarsimp)
  apply(rename_tac y1 \<beta> z A \<alpha> a v1 v2 nat w v)(*strict*)
  apply(thin_tac "(last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2)) # F_DFA_GOTO_SEQUENCE M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2))) w2) \<sqsupseteq> [last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v1))] \<or> [last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v1))] \<sqsupseteq> (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2)) # F_DFA_GOTO_SEQUENCE M (last (F_DFA_GOTO_SEQUENCE M (epda_initial M) (teB Do # v2))) w2)")
  apply(rename_tac y1 \<beta> z A \<alpha> a v1 v2 nat w v)(*strict*)
  apply(thin_tac "y1 \<notin> cfgSTD_first G' (Suc nat) (teB a # \<beta> @ liftB z)")
  apply(thin_tac "\<lparr>prod_lhs = A2, prod_rhs = w2\<rparr> \<in> cfg_productions G")
  apply(thin_tac "(a # w @ Do # v) \<sqsubseteq> y1 \<or> y1 \<sqsubseteq> (a # w @ Do # v)")
  apply(subgoal_tac " (\<exists>w. set w \<subseteq> cfg_events G \<and> ((cfg_item_look_ahead SSI = w \<and> length w=Suc nat) \<or> (cfg_item_look_ahead SSI = w@[Do] \<and> length w<Suc nat)))" for SSI)
   apply(rename_tac y1 \<beta> z A \<alpha> a v1 v2 nat w v)(*strict*)
   prefer 2
   apply(rule_tac
      I="\<lparr>cfg_item_lhs = A, cfg_item_rhs1 = \<alpha>, cfg_item_rhs2 = teB a # \<beta>, cfg_item_look_ahead = z\<rparr>"
      in lookaheads_are_kprefixes)
      apply(rename_tac y1 \<beta> z A \<alpha> a v1 v2 nat w v)(*strict*)
      apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
     apply(rename_tac y1 \<beta> z A \<alpha> a v1 v2 nat w v)(*strict*)
     apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
    apply(rename_tac y1 \<beta> z A \<alpha> a v1 v2 nat w v)(*strict*)
    apply(clarsimp)
    apply(simp add: AF_LR_PARSER_input_def valid_cfg_def)
    apply(clarsimp)
    apply(erule_tac
      x="\<lparr>prod_lhs = A, prod_rhs = \<alpha> @ teB a # \<beta>\<rparr>"
      and A="cfg_productions G"
      in ballE)
     apply(rename_tac y1 \<beta> z A \<alpha> a v1 v2 nat w v)(*strict*)
     prefer 2
     apply(force)
    apply(rename_tac y1 \<beta> z A \<alpha> a v1 v2 nat w v)(*strict*)
    apply(clarsimp)
   apply(rename_tac y1 \<beta> z A \<alpha> a v1 v2 nat w v)(*strict*)
   apply(simp add: AF_LR_PARSER_input_def valid_cfg_def)
  apply(rename_tac y1 \<beta> z A \<alpha> a v1 v2 nat w v)(*strict*)
  apply(clarsimp)
  apply(rename_tac y1 \<beta> z A \<alpha> a v1 v2 nat w v wa)(*strict*)
  apply(thin_tac "\<lparr>cfg_item_lhs = A, cfg_item_rhs1 = \<alpha>, cfg_item_rhs2 = teB a # \<beta>, cfg_item_look_ahead = z\<rparr> \<in> valid_item_set G' (Suc nat) (teB Do # v2 @ w2)")
  apply(rename_tac y1 \<beta> z A \<alpha> a v1 v2 nat w v wa)(*strict*)
  apply(thin_tac "\<lparr>cfg_item_lhs = A2, cfg_item_rhs1 = w2, cfg_item_rhs2 = [], cfg_item_look_ahead = y1\<rparr> \<in> valid_item_set G' (Suc nat) (teB Do # v2 @ w2)")
  apply(rename_tac y1 \<beta> z A \<alpha> a v1 v2 nat w v wa)(*strict*)
  apply(thin_tac "valid_dfa M")
  apply(thin_tac "every_state_in_some_accessible_configuration M")
  apply(thin_tac "some_step_from_every_configuration M")
  apply(thin_tac "valid_parser P")
  apply(clarsimp)
  apply(rename_tac \<beta> z A \<alpha> a v1 v2 nat w v wa)(*strict*)
  apply(thin_tac "valid_item_set G' (Suc nat) (teB Do # v1) = valid_item_set G' (Suc nat) (teB Do # v2 @ w2)")
  apply(rename_tac \<beta> z A \<alpha> a v1 v2 nat w v wa)(*strict*)
  apply(thin_tac "teB Do \<in> two_elements_construct_domain (cfg_nonterminals G') (cfg_events G')")
  apply(thin_tac "set v1 \<subseteq> two_elements_construct_domain (cfg_nonterminals G') (cfg_events G')")
  apply(thin_tac "set v2 \<subseteq> two_elements_construct_domain (cfg_nonterminals G') (cfg_events G')")
  apply(thin_tac "set w2 \<subseteq> two_elements_construct_domain (cfg_nonterminals G') (cfg_events G')")
  apply(simp add: cfgSTD_first_def)
  apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa)(*strict*)
  apply(clarsimp)
  apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa x d e1 n)(*strict*)
  apply(subgoal_tac "suffix x z")
   apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa x d e1 n)(*strict*)
   apply(simp add: suffix_def)
   apply(clarsimp)
   apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c)(*strict*)
   apply(subgoal_tac "set c \<subseteq> cfg_events G")
    apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c)(*strict*)
    apply(subgoal_tac "strict_prefix w (take nat c) \<or> prefix (take nat c) w")
     apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c)(*strict*)
     apply(erule_tac
      P="strict_prefix w (take nat c)"
      in disjE)
      apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c)(*strict*)
      apply(simp add: strict_prefix_def)
      apply(clarsimp)
      apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c ca)(*strict*)
      apply(case_tac ca)
       apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c ca)(*strict*)
       apply(clarsimp)
      apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c ca aa list)(*strict*)
      apply(clarsimp)
      apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c aa list)(*strict*)
      apply(subgoal_tac "aa=Do")
       apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c aa list)(*strict*)
       apply(clarsimp)
       apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c list)(*strict*)
       apply(subgoal_tac "Do \<in> cfg_events G")
        apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c list)(*strict*)
        apply(subgoal_tac "Do \<notin> cfg_events G")
         apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c list)(*strict*)
         apply(force)
        apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c list)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def F_CFG_AUGMENT_def)
        apply(clarsimp)
        apply(subgoal_tac "F_FRESH (cfg_events G) \<notin> cfg_events G")
         apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c list)(*strict*)
         apply(force)
        apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c list)(*strict*)
        apply(rule F_FRESH_is_fresh)
        apply(simp add: F_LR_MACHINE_def F_CFG_AUGMENT_def two_elements_construct_domain_def valid_cfg_def)
       apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c list)(*strict*)
       apply(rule_tac
      A="set c"
      in set_mp)
        apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c list)(*strict*)
        apply(force)
       apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c list)(*strict*)
       apply(rule_tac
      A="set(take nat c)"
      in set_mp)
        apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c list)(*strict*)
        apply (metis List.set_take_subset)
       apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c list)(*strict*)
       apply(rule_tac
      t="take nat c"
      and s="w@Do#list"
      in ssubst)
        apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c list)(*strict*)
        apply(force)
       apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c list)(*strict*)
       apply(simp (no_asm))
      apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c aa list)(*strict*)
      apply(rule_tac
      t="aa"
      and s="((w @ aa # list) @ take (nat - length c) z)!(length w)"
      in ssubst)
       apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c aa list)(*strict*)
       apply (metis Cons_eq_appendI append_eq_appendI nth_append_length)
      apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c aa list)(*strict*)
      apply(rule_tac
      t="Do"
      and s="(w @ Do # v)!(length w)"
      in ssubst)
       apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c aa list)(*strict*)
       apply (metis nth_append_length)
      apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c aa list)(*strict*)
      apply(rule_tac
      t="(w @ Do # v)"
      and s="(w @ aa # list) @ take (nat - length c) z"
      in ssubst)
       apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c aa list)(*strict*)
       apply(force)
      apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c aa list)(*strict*)
      apply(force)
     apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c)(*strict*)
     apply(simp add: prefix_def)
     apply(clarsimp)
     apply(rename_tac \<beta> z A \<alpha> a v2 nat v wa d e1 n c ca)(*strict*)
     apply(erule disjE)
      apply(rename_tac \<beta> z A \<alpha> a v2 nat v wa d e1 n c ca)(*strict*)
      apply(clarsimp)
      apply(rename_tac \<beta> A \<alpha> a v2 nat v wa d e1 n c ca)(*strict*)
      apply(subgoal_tac "Do \<in> cfg_events G")
       apply(rename_tac \<beta> A \<alpha> a v2 nat v wa d e1 n c ca)(*strict*)
       apply(subgoal_tac "Do \<notin> cfg_events G")
        apply(rename_tac \<beta> A \<alpha> a v2 nat v wa d e1 n c ca)(*strict*)
        apply(force)
       apply(rename_tac \<beta> A \<alpha> a v2 nat v wa d e1 n c ca)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def F_CFG_AUGMENT_def)
       apply(clarsimp)
       apply(subgoal_tac "F_FRESH (cfg_events G) \<notin> cfg_events G")
        apply(rename_tac \<beta> A \<alpha> a v2 nat v wa d e1 n c ca)(*strict*)
        apply(force)
       apply(rename_tac \<beta> A \<alpha> a v2 nat v wa d e1 n c ca)(*strict*)
       apply(rule F_FRESH_is_fresh)
       apply(simp add: F_LR_MACHINE_def F_CFG_AUGMENT_def two_elements_construct_domain_def valid_cfg_def)
      apply(rename_tac \<beta> A \<alpha> a v2 nat v wa d e1 n c ca)(*strict*)
      apply(rule_tac
      A="set wa"
      in set_mp)
       apply(rename_tac \<beta> A \<alpha> a v2 nat v wa d e1 n c ca)(*strict*)
       apply(force)
      apply(rename_tac \<beta> A \<alpha> a v2 nat v wa d e1 n c ca)(*strict*)
      apply(rule_tac
      A="set(take (nat - length c) wa)"
      in set_mp)
       apply(rename_tac \<beta> A \<alpha> a v2 nat v wa d e1 n c ca)(*strict*)
       apply (metis List.set_take_subset)
      apply(rename_tac \<beta> A \<alpha> a v2 nat v wa d e1 n c ca)(*strict*)
      apply(rule_tac
      t="take (nat - length c) wa"
      and s="ca@Do#v"
      in ssubst)
       apply(rename_tac \<beta> A \<alpha> a v2 nat v wa d e1 n c ca)(*strict*)
       apply(force)
      apply(rename_tac \<beta> A \<alpha> a v2 nat v wa d e1 n c ca)(*strict*)
      apply(simp (no_asm))
     apply(rename_tac \<beta> z A \<alpha> a v2 nat v wa d e1 n c ca)(*strict*)
     apply(clarsimp)
     apply(rename_tac \<beta> A \<alpha> a v2 nat v wa d e1 n c ca)(*strict*)
     apply(case_tac v)
      apply(rename_tac \<beta> A \<alpha> a v2 nat v wa d e1 n c ca)(*strict*)
      apply(clarsimp)
      apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca)(*strict*)
      apply(case_tac "nat - (length c + length wa)")
       apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca)(*strict*)
       apply(clarsimp)
       apply(subgoal_tac "Do \<in> cfg_events G")
        apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca)(*strict*)
        apply(subgoal_tac "Do \<notin> cfg_events G")
         apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca)(*strict*)
         apply(force)
        apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def F_CFG_AUGMENT_def)
        apply(clarsimp)
        apply(subgoal_tac "F_FRESH (cfg_events G) \<notin> cfg_events G")
         apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca)(*strict*)
         apply(force)
        apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca)(*strict*)
        apply(rule F_FRESH_is_fresh)
        apply(simp add: F_LR_MACHINE_def F_CFG_AUGMENT_def two_elements_construct_domain_def valid_cfg_def)
       apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca)(*strict*)
       apply(rule_tac
      A="set wa"
      in set_mp)
        apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca)(*strict*)
        apply(force)
       apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca)(*strict*)
       apply(rule_tac
      A="set(take (nat - length c) wa)"
      in set_mp)
        apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca)(*strict*)
        apply (metis List.set_take_subset)
       apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca)(*strict*)
       apply(rule_tac
      t="take (nat - length c) wa"
      and s="ca@[Do]"
      in ssubst)
        apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca)(*strict*)
        apply(force)
       apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca)(*strict*)
       apply(simp (no_asm))
      apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca nata)(*strict*)
      apply(clarsimp)
     apply(rename_tac \<beta> A \<alpha> a v2 nat v wa d e1 n c ca aa list)(*strict*)
     apply(subgoal_tac "\<exists>w' x'. v = w' @ [x']")
      apply(rename_tac \<beta> A \<alpha> a v2 nat v wa d e1 n c ca aa list)(*strict*)
      prefer 2
      apply(rule NonEmptyListHasTailElem)
      apply(force)
     apply(rename_tac \<beta> A \<alpha> a v2 nat v wa d e1 n c ca aa list)(*strict*)
     apply(thin_tac "v=aa#list")
     apply(clarsimp)
     apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca w' x')(*strict*)
     apply(case_tac "nat - (length c + length wa)")
      apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca w' x')(*strict*)
      apply(clarsimp)
      apply(subgoal_tac "Do \<in> cfg_events G")
       apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca w' x')(*strict*)
       apply(subgoal_tac "Do \<notin> cfg_events G")
        apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca w' x')(*strict*)
        apply(force)
       apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca w' x')(*strict*)
       apply(simp add: AF_LR_PARSER_input_def F_CFG_AUGMENT_def)
       apply(clarsimp)
       apply(subgoal_tac "F_FRESH (cfg_events G) \<notin> cfg_events G")
        apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca w' x')(*strict*)
        apply(force)
       apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca w' x')(*strict*)
       apply(rule F_FRESH_is_fresh)
       apply(simp add: F_LR_MACHINE_def F_CFG_AUGMENT_def two_elements_construct_domain_def valid_cfg_def)
      apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca w' x')(*strict*)
      apply(rule_tac
      A="set wa"
      in set_mp)
       apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca w' x')(*strict*)
       apply(force)
      apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca w' x')(*strict*)
      apply(rule_tac
      A="set(take (nat - length c) wa)"
      in set_mp)
       apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca w' x')(*strict*)
       apply (metis List.set_take_subset)
      apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca w' x')(*strict*)
      apply(rule_tac
      t="take (nat - length c) wa"
      and s="ca @ Do # w' @ [x']"
      in ssubst)
       apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca w' x')(*strict*)
       apply(force)
      apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca w' x')(*strict*)
      apply(simp (no_asm))
     apply(rename_tac \<beta> A \<alpha> a v2 nat wa d e1 n c ca w' x' nata)(*strict*)
     apply(clarsimp)
     apply(rename_tac \<beta> A \<alpha> a v2 nat d e1 n c ca w' nata)(*strict*)
     apply(simp add: AF_LR_PARSER_input_def F_CFG_AUGMENT_def)
     apply(clarsimp)
     apply(subgoal_tac "F_FRESH (cfg_events G) \<notin> cfg_events G")
      apply(rename_tac \<beta> A \<alpha> a v2 nat d e1 n c ca w' nata)(*strict*)
      apply(force)
     apply(rename_tac \<beta> A \<alpha> a v2 nat d e1 n c ca w' nata)(*strict*)
     apply(rule F_FRESH_is_fresh)
     apply(simp add: F_LR_MACHINE_def F_CFG_AUGMENT_def two_elements_construct_domain_def valid_cfg_def)
    apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c)(*strict*)
    apply(rule mutual_strict_prefix_prefix)
    apply(force)
   apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c)(*strict*)
   prefer 2
   apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa x d e1 n)(*strict*)
   apply(rule liftB_creates_suffix)
   apply(subgoal_tac "\<exists>d' e. cfgRM.derivation G' d' \<and> maximum_of_domain d' n \<and> d' 0 = Some (pair None \<lparr>cfg_conf=\<beta> @ liftB z\<rparr>) \<and> d' n = Some (pair e \<lparr>cfg_conf=liftB x\<rparr>)")
    apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa x d e1 n)(*strict*)
    prefer 2
    apply(rule_tac
      d="d"
      in cfg_derivation_can_be_translated_to_cfgRM_derivation)
         apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa x d e1 n)(*strict*)
         apply(simp add: AF_LR_PARSER_input_def)
        apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa x d e1 n)(*strict*)
        apply(force)
       apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa x d e1 n)(*strict*)
       apply(simp add: maximum_of_domain_def)
      apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa x d e1 n)(*strict*)
      apply(force)
     apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa x d e1 n)(*strict*)
     apply(force)
    apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa x d e1 n)(*strict*)
    apply (metis setA_liftB)
   apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa x d e1 n)(*strict*)
   apply(clarsimp)
   apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa x d e1 n d' e)(*strict*)
   apply(rule_tac
      d="d'"
      and i="0"
      and j="n"
      in CFGRM_terminals_stay_at_end)
        apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa x d e1 n d' e)(*strict*)
        apply(force)
       apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa x d e1 n d' e)(*strict*)
       apply(force)
      apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa x d e1 n d' e)(*strict*)
      apply (metis setA_liftB)
     apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa x d e1 n d' e)(*strict*)
     apply(force)
    apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa x d e1 n d' e)(*strict*)
    apply(force)
   apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa x d e1 n d' e)(*strict*)
   apply(force)
  apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c)(*strict*)
  apply(subgoal_tac "\<exists>v. set v \<subseteq> two_elements_construct_domain (cfg_nonterminals G) (cfg_events G) \<and> (case e1 of None \<Rightarrow> True|Some e' \<Rightarrow> e' \<in> cfg_productions G) \<and> SSc=\<lparr>cfg_conf = v @ liftB z\<rparr>" for SSc)
   apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c)(*strict*)
   prefer 2
   apply(rule_tac
      n="n"
      and d="d"
      in CFG_preserves_partial_belongs)
        apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c)(*strict*)
       prefer 2
       apply(force)
      apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c)(*strict*)
      prefer 2
      apply(force)
     apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c)(*strict*)
     apply(simp add: AF_LR_PARSER_input_def valid_cfg_def)
     apply(clarsimp)
     apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c x)(*strict*)
     apply(erule_tac
      x="\<lparr>prod_lhs = A, prod_rhs = \<alpha> @ teB a # \<beta>\<rparr>"
      and A="cfg_productions G"
      in ballE)
      apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c x)(*strict*)
      prefer 2
      apply(force)
     apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c x)(*strict*)
     apply(clarsimp)
     apply(simp add: setAConcat setBConcat two_elements_construct_domain_def)
     apply(clarsimp)
     apply(case_tac x)
      apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c x aa)(*strict*)
      apply(clarsimp)
      apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c aa)(*strict*)
      apply(rule inMap)
      apply(clarsimp)
      apply (metis setA_set_not subsetE)
     apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c x b)(*strict*)
     apply(clarsimp)
     apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c b)(*strict*)
     apply (metis inMap2 set_setB set_mp_prime)
    apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c p)(*strict*)
    apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def)
    apply(clarsimp)
    apply(simp add: AF_LR_PARSER_input_def F_CFG_AUGMENT_def)
    apply(clarsimp)
    apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c)(*strict*)
    apply(subgoal_tac "F_FRESH (cfg_nonterminals G) \<notin> cfg_nonterminals G")
     apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c)(*strict*)
     apply(force)
    apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c)(*strict*)
    apply(rule F_FRESH_is_fresh)
    apply(simp add: AF_LR_PARSER_def AF_LR_PARSER_input_def valid_cfg_def)
   apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c)(*strict*)
   apply(force)
  apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c)(*strict*)
  apply(erule exE)
  apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c va)(*strict*)
  apply(clarsimp)
  apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c va x)(*strict*)
  apply(simp add: liftB_commutes_over_concat take_liftB)
  apply(clarsimp)
  apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c x)(*strict*)
  apply(subgoal_tac "teB x \<in> set(liftB c)")
   apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c x)(*strict*)
   prefer 2
   apply(rule set_liftB_insert)
   apply(force)
  apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c x)(*strict*)
  apply(thin_tac "x \<in> set c")
  apply(subgoal_tac "teB x \<in> two_elements_construct_domain (cfg_nonterminals G) (cfg_events G)")
   apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c x)(*strict*)
   apply(simp add: two_elements_construct_domain_def)
   apply(erule_tac
      P="teB x \<in> teA ` cfg_nonterminals G"
      in disjE)
    apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c x)(*strict*)
    apply(force)
   apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c x)(*strict*)
   apply(clarsimp)
  apply(rename_tac \<beta> z A \<alpha> a v2 nat w v wa d e1 n c x)(*strict*)
  apply(force)
  done

theorem Lemma_6_36_ReduceReduce_Conflict_implies_nondeterminism: "
  AF_LR_PARSER_input G F Do S' G' M P k
  \<Longrightarrow> conflict_free G G' k
  \<Longrightarrow> parserS.is_forward_edge_deterministic_accessible P"
  apply(subgoal_tac "valid_cfg G'")
   prefer 2
   apply(rule F_CFG_AUGMENT__makes_CFG)
   apply(simp add: F_CFG_AUGMENT__input_def AF_LR_PARSER_input_def)
   apply(force)
  apply(simp add: parserS.is_forward_edge_deterministic_accessible_def)
  apply(clarsimp)
  apply(rename_tac c c1 c2 e1 e2)(*strict*)
  apply(rename_tac r1 r2)
  apply(rename_tac c c1 c2 r1 r2)(*strict*)
  apply(subgoal_tac "r1 \<in> parser_rules P")
   apply(rename_tac c c1 c2 r1 r2)(*strict*)
   prefer 2
   apply(simp add: parserS_step_relation_def)
  apply(rename_tac c c1 c2 r1 r2)(*strict*)
  apply(subgoal_tac "r2 \<in> parser_rules P")
   apply(rename_tac c c1 c2 r1 r2)(*strict*)
   prefer 2
   apply(simp add: parserS_step_relation_def)
  apply(rename_tac c c1 c2 r1 r2)(*strict*)
  apply(subgoal_tac "(rule_lpop r2 \<sqsupseteq> rule_lpop r1 \<or> rule_lpop r1 \<sqsupseteq> rule_lpop r2) \<and> (rule_rpop r1 \<sqsubseteq> rule_rpop r2 \<or> rule_rpop r2 \<sqsubseteq> rule_rpop r1)")
   apply(rename_tac c c1 c2 r1 r2)(*strict*)
   prefer 2
   apply(simp add: parserS_step_relation_def)
   apply(case_tac c1)
   apply(rename_tac c c1 c2 r1 r2 parserS_conf_stacka parserS_conf_schedulera)(*strict*)
   apply(case_tac c2)
   apply(rename_tac c c1 c2 r1 r2 parserS_conf_stacka parserS_conf_schedulera parserS_conf_stackaa parserS_conf_scheduleraa)(*strict*)
   apply(case_tac c)
   apply(rename_tac c c1 c2 r1 r2 parserS_conf_stacka parserS_conf_schedulera parserS_conf_stackaa parserS_conf_scheduleraa parserS_conf_stackb parserS_conf_schedulerb)(*strict*)
   apply(rule context_conjI)
    apply(rename_tac c c1 c2 r1 r2 parserS_conf_stacka parserS_conf_schedulera parserS_conf_stackaa parserS_conf_scheduleraa parserS_conf_stackb parserS_conf_schedulerb)(*strict*)
    prefer 2
    apply(erule conjE)+
    apply(erule exE)+
    apply(rename_tac c c1 c2 r1 r2 parserS_conf_stacka parserS_conf_schedulera parserS_conf_stackaa parserS_conf_scheduleraa parserS_conf_stackb parserS_conf_schedulerb x xa xb xc)(*strict*)
    apply(rule_tac
      b="xa"
      and d="xc"
      in mutual_prefix_prefix)
    apply(force)
   apply(rename_tac c c1 c2 r1 r2 parserS_conf_stacka parserS_conf_schedulera parserS_conf_stackaa parserS_conf_scheduleraa parserS_conf_stackb parserS_conf_schedulerb)(*strict*)
   apply(erule conjE)+
   apply(erule exE)+
   apply(rename_tac c c1 c2 r1 r2 parserS_conf_stacka parserS_conf_schedulera parserS_conf_stackaa parserS_conf_scheduleraa parserS_conf_stackb parserS_conf_schedulerb x xa xb xc)(*strict*)
   apply(subgoal_tac "x @ rule_lpop r1 = xb @ rule_lpop r2")
    apply(rename_tac c c1 c2 r1 r2 parserS_conf_stacka parserS_conf_schedulera parserS_conf_stackaa parserS_conf_scheduleraa parserS_conf_stackb parserS_conf_schedulerb x xa xb xc)(*strict*)
    prefer 2
    apply(force)
   apply(rename_tac c c1 c2 r1 r2 parserS_conf_stacka parserS_conf_schedulera parserS_conf_stackaa parserS_conf_scheduleraa parserS_conf_stackb parserS_conf_schedulerb x xa xb xc)(*strict*)
   apply(rule_tac
      a="xb"
      in mutual_suffix_suffix)
   apply(rule sym)
   apply(force)
  apply(rename_tac c c1 c2 r1 r2)(*strict*)
  apply(clarsimp)
  apply(case_tac "(parser_marker P) r1")
   apply(rename_tac c c1 c2 r1 r2)(*strict*)
   apply(subgoal_tac "parser_marker P r1 \<noteq> None")
    apply(rename_tac c c1 c2 r1 r2)(*strict*)
    apply(force)
   apply(rename_tac c c1 c2 r1 r2)(*strict*)
   apply(rule_tac
      G="G"
      in X6_3_InformationOnRules_EffectNotNone)
          apply(rename_tac c c1 c2 r1 r2)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(simp add: AF_LR_PARSER_input_def)
         apply(force)
        apply(rename_tac c c1 c2 r1 r2)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(rename_tac c c1 c2 r1 r2)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(rename_tac c c1 c2 r1 r2)(*strict*)
      apply(simp add: AF_LR_PARSER_input_def)
     apply(rename_tac c c1 c2 r1 r2)(*strict*)
     apply(simp add: AF_LR_PARSER_input_def)
    apply(rename_tac c c1 c2 r1 r2)(*strict*)
    apply(simp add: AF_LR_PARSER_input_def)
   apply(rename_tac c c1 c2 r1 r2)(*strict*)
   apply(force)
  apply(rename_tac c c1 c2 r1 r2 a)(*strict*)
  apply(case_tac "(parser_marker P) r2")
   apply(rename_tac c c1 c2 r1 r2 a)(*strict*)
   apply(subgoal_tac "parser_marker P r2 \<noteq> None")
    apply(rename_tac c c1 c2 r1 r2 a)(*strict*)
    apply(force)
   apply(rename_tac c c1 c2 r1 r2 a)(*strict*)
   apply(rule_tac
      G="G"
      in X6_3_InformationOnRules_EffectNotNone)
          apply(rename_tac c c1 c2 r1 r2 a)(*strict*)
          apply(simp add: AF_LR_PARSER_input_def)
         apply(simp add: AF_LR_PARSER_input_def)
         apply(force)
        apply(rename_tac c c1 c2 r1 r2 a)(*strict*)
        apply(simp add: AF_LR_PARSER_input_def)
       apply(rename_tac c c1 c2 r1 r2 a)(*strict*)
       apply(simp add: AF_LR_PARSER_input_def)
      apply(rename_tac c c1 c2 r1 r2 a)(*strict*)
      apply(simp add: AF_LR_PARSER_input_def)
     apply(rename_tac c c1 c2 r1 r2 a)(*strict*)
     apply(simp add: AF_LR_PARSER_input_def)
    apply(rename_tac c c1 c2 r1 r2 a)(*strict*)
    apply(simp add: AF_LR_PARSER_input_def)
   apply(rename_tac c c1 c2 r1 r2 a)(*strict*)
   apply(force)
  apply(rename_tac c c1 c2 r1 r2 a aa)(*strict*)
  apply(case_tac a)
   apply(rename_tac c c1 c2 r1 r2 a aa)(*strict*)
   apply(case_tac aa)
    apply(rename_tac c c1 c2 r1 r2 a aa)(*strict*)
    apply(rule no_shift_shift_conflicts)
          apply(rename_tac c c1 c2 r1 r2 a aa)(*strict*)
          apply(force)
         apply(rename_tac c c1 c2 r1 r2 a aa)(*strict*)
         apply(force)
        apply(rename_tac c c1 c2 r1 r2 a aa)(*strict*)
        apply(force)
       apply(rename_tac c c1 c2 r1 r2 a aa)(*strict*)
       apply(force)
      apply(rename_tac c c1 c2 r1 r2 a aa)(*strict*)
      apply(force)
     apply(rename_tac c c1 c2 r1 r2 a aa)(*strict*)
     apply(force)
    apply(rename_tac c c1 c2 r1 r2 a aa)(*strict*)
    apply(force)
   apply(rename_tac c c1 c2 r1 r2 a aa ab)(*strict*)
   apply(case_tac ab)
   apply(rename_tac c c1 c2 r1 r2 a aa ab prod_lhs prod_rhs)(*strict*)
   apply(rule no_shift_reduce_conflicts)
          apply(rename_tac c c1 c2 r1 r2 a aa ab prod_lhs prod_rhs)(*strict*)
          apply(force)
         apply(rename_tac c c1 c2 r1 r2 a aa ab prod_lhs prod_rhs)(*strict*)
         apply(force)
        apply(rename_tac c c1 c2 r1 r2 a aa ab prod_lhs prod_rhs)(*strict*)
        apply(force)
       apply(rename_tac c c1 c2 r1 r2 a aa ab prod_lhs prod_rhs)(*strict*)
       apply(force)
      apply(rename_tac c c1 c2 r1 r2 a aa ab prod_lhs prod_rhs)(*strict*)
      apply(force)
     apply(rename_tac c c1 c2 r1 r2 a aa ab prod_lhs prod_rhs)(*strict*)
     apply(force)
    apply(rename_tac c c1 c2 r1 r2 a aa ab prod_lhs prod_rhs)(*strict*)
    apply(force)
   apply(rename_tac c c1 c2 r1 r2 a aa ab prod_lhs prod_rhs)(*strict*)
   apply(force)
  apply(rename_tac c c1 c2 r1 r2 a aa ab)(*strict*)
  apply(case_tac aa)
   apply(rename_tac c c1 c2 r1 r2 a aa ab)(*strict*)
   apply(rule sym)
   apply(case_tac ab)
   apply(rename_tac c c1 c2 r1 r2 a aa ab prod_lhs prod_rhs)(*strict*)
   apply(rule no_shift_reduce_conflicts)
          apply(rename_tac c c1 c2 r1 r2 a aa ab prod_lhs prod_rhs)(*strict*)
          apply(force)
         apply(rename_tac c c1 c2 r1 r2 a aa ab prod_lhs prod_rhs)(*strict*)
         apply(force)
        apply(rename_tac c c1 c2 r1 r2 a aa ab prod_lhs prod_rhs)(*strict*)
        apply(force)
       apply(rename_tac c c1 c2 r1 r2 a aa ab prod_lhs prod_rhs)(*strict*)
       apply(force)
      apply(rename_tac c c1 c2 r1 r2 a aa ab prod_lhs prod_rhs)(*strict*)
      apply(force)
     apply(rename_tac c c1 c2 r1 r2 a aa ab prod_lhs prod_rhs)(*strict*)
     apply(force)
    apply(rename_tac c c1 c2 r1 r2 a aa ab prod_lhs prod_rhs)(*strict*)
    apply(force)
   apply(rename_tac c c1 c2 r1 r2 a aa ab prod_lhs prod_rhs)(*strict*)
   apply(force)
  apply(rename_tac c c1 c2 r1 r2 a aa ab ac)(*strict*)
  apply(case_tac ab)
  apply(rename_tac c c1 c2 r1 r2 a aa ab ac prod_lhs prod_rhs)(*strict*)
  apply(case_tac ac)
  apply(rename_tac c c1 c2 r1 r2 a aa ab ac prod_lhs prod_rhs prod_lhsa prod_rhsa)(*strict*)
  apply(rule no_reduce_reduce_conflicts)
         apply(rename_tac c c1 c2 r1 r2 a aa ab ac prod_lhs prod_rhs prod_lhsa prod_rhsa)(*strict*)
         apply(force)
        apply(rename_tac c c1 c2 r1 r2 a aa ab ac prod_lhs prod_rhs prod_lhsa prod_rhsa)(*strict*)
        apply(force)
       apply(rename_tac c c1 c2 r1 r2 a aa ab ac prod_lhs prod_rhs prod_lhsa prod_rhsa)(*strict*)
       apply(force)
      apply(rename_tac c c1 c2 r1 r2 a aa ab ac prod_lhs prod_rhs prod_lhsa prod_rhsa)(*strict*)
      apply(force)
     apply(rename_tac c c1 c2 r1 r2 a aa ab ac prod_lhs prod_rhs prod_lhsa prod_rhsa)(*strict*)
     apply(force)
    apply(rename_tac c c1 c2 r1 r2 a aa ab ac prod_lhs prod_rhs prod_lhsa prod_rhsa)(*strict*)
    apply(force)
   apply(rename_tac c c1 c2 r1 r2 a aa ab ac prod_lhs prod_rhs prod_lhsa prod_rhsa)(*strict*)
   apply(force)
  apply(rename_tac c c1 c2 r1 r2 a aa ab ac prod_lhs prod_rhs prod_lhsa prod_rhsa)(*strict*)
  apply(force)
  done

theorem F_LR_PARSER_is_forward_edge_deterministic_accessible: "
  AF_LR_PARSER_input G F Do S' G' M P k
  \<Longrightarrow> cfgSTD.Nonblockingness_branching G
  \<Longrightarrow> cfg_LRk G k
  \<Longrightarrow> parserS.is_forward_edge_deterministic_accessible P"
  apply(rule Lemma_6_36_ReduceReduce_Conflict_implies_nondeterminism)
   apply(force)
  apply(rule cfg_LRk_implies_conflict_free)
   apply(simp add: AF_LR_PARSER_input_def F_CFG_AUGMENT__input_def)
  apply(force)
  done

end
